<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类：软件开发 | 飘飘白云]]></title>
  <link href="http://luozhaohui.github.io/blog/categories/ruan-jian-kai-fa/atom.xml" rel="self"/>
  <link href="http://luozhaohui.github.io/"/>
  <updated>2017-11-14T14:54:00+08:00</updated>
  <id>http://luozhaohui.github.io/</id>
  <author>
    <name><![CDATA[飘飘白云]]></name>
    <email><![CDATA[kesalin@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android框架学习资料]]></title>
    <link href="http://luozhaohui.github.io/blog/2015/04/02/study-android-fw/"/>
    <updated>2015-04-02T19:00:34+08:00</updated>
    <id>http://luozhaohui.github.io/blog/2015/04/02/study-android-fw</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>这两年在做一个与 Android 类似的系统（参考：<a href="http://blog.csdn.net/kesalin/article/details/10474007">招聘：有兴趣做一个与Android对等的操作系统么？</a>），因此有机会对 Android framework 进行系统地学习与研究。期间也阅读了一些不错的书籍与资料，特此分享在这里，或许对其他有兴趣研究 Android framework 的朋友有所帮助。</p>

<!--more-->


<h2>推荐资料</h2>

<h3><a href="http://book.douban.com/subject/11530748/">Android开发精要</a></h3>

<p>这一本是作为入门本，主要是从 app 开发者的角度来介绍 framework 中的各要素，从这个角度来理解框架中哪些部分直接和 App 开发相关，又起什么作用。要仔细研究 framework 内部机制，首先从外部特性入手，这样在横向层面对 framework 有一个整体的认识与把握。第3章至第6章是这本书的精华所在，重点介绍了 Android 的组件思想以及组件之间的交互媒介 Intent。</p>

<h3><a href="http://book.douban.com/subject/10570841/">Android框架揭秘</a></h3>

<p>对比过《深入理解Android》等书籍，还是觉得这本书讲得有体系，透彻，著者非常用心。尤其是对 C++/Java 两个层面的 framework，以及对 Client/Server 的交互过程讲得比较详细。</p>

<h3><a href="http://blog.csdn.net/universus/article/details/6211589/">Android Bander设计与实现 - 设计篇</a></h3>

<p>引用原文内容：</p>

<blockquote><p>这篇文章首先通过介绍 Binder 通信模型和 Binder 通信协议了解 Binder 的设计需求；然后分别阐述 Binder 在系统不同部分的表述方式和起的作用；最后还会解释 Binder 在数据接收端的设计考虑，包括线程池管理，内存映射和等待队列管理等。通过本文对 Binder 的详细介绍以及与其它 IPC 通信方式的对比，读者将对 Binder 的优势和使用 Binder 作为 Android 主要 IPC 方式的原因有深入了解。</p></blockquote>

<h3><a href="http://book.douban.com/subject/19986441/">Android系统源代码情景分析</a></h3>

<p>这是讲解 Android Binder 以及匿名共享内存最详细的书，没有之一。作者花了进200页的篇幅来透彻讲解 Binder，此外对各种组件的启动过程也介绍得相当详细，如 Activity、Service、Content Provider 等。</p>

<h3><a href="http://book.douban.com/subject/25921329/">深入理解Android内核设计思想</a></h3>

<p>从操作系统的基础知识入手，讲解进程线程、内存管理、Binder 机制、Surface、SurfaceFlinger、WindowManagerService、View 体系、音频系统、输入系统等在 Android framework 中的实现原理。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用Python编写博客导出工具]]></title>
    <link href="http://luozhaohui.github.io/blog/2014/10/12/export-blog-using-python-on-windows/"/>
    <updated>2014-10-12T08:35:02+08:00</updated>
    <id>http://luozhaohui.github.io/blog/2014/10/12/export-blog-using-python-on-windows</id>
    <content type="html"><![CDATA[<h3>写在前面的话</h3>

<p>我在 github 上用 octopress 搭建了<a href="http://kesalin.github.io/">个人博客</a>，octopress 使用Markdown语法编写博文。之前我在CSDN博客上也写过不少的技术博文，都说自己的孩子再丑也是个宝，所以就起了把CSDN博客里面的文章导出到个人博客上的念头。刚开始想找个工具把CSDN博客导出为xml或文本，然后再把xml或文本转换为Markdown博文。可惜搜了一下现有博客导出工具，大部分要收费才能将全部博文导出为xml格式，所以就只好发明轮子了：写个工具将全部博文导出为Markdown博文（也是txt格式的）。</p>

<p>我将详细介绍这个工具的编写过程，希望没有学习过编程的人也能够学会一些简单的Python语法来修改这个脚本工具，以满足他们将其他类型的博客导出为文本格式。这也是我第一次学习和使用Python，所以相信我，你一定也可以将自己的博客导出为想要的文本格式。</p>

<p>本文源代码在这里：<a href="https://github.com/luozhaohui/python/blob/master/exportCSDNBlogAsMarkdown.py">ExportCSDNBlog.py</a></p>

<!--more-->


<p>考虑到大部分非程序员使用Windows系统，下面将介绍在Windows下如何编写这个工具。</p>

<h3>下载工具</h3>

<p>在 Windows 下安装Python开发环境（Linux/Mac下用pip安装相应包即可，程序员自己解决咯）：</p>

<p><strong>Python 2.7.3</strong><br/>
请安装这个版本，更高版本的Python与一些库不兼容。<br/>
<a href="https://www.python.org/download/releases/2.7.3/">下载页面</a><br/>
下载完毕双击可执行文件进行安装，默认安装在C:\Python2.7。</p>

<p><strong>six</strong><br/>
<a href="https://pypi.python.org/pypi/six">下载页面</a>
下载完毕，解压到Python安装目录下，如C:\Python2.7\six-1.8.0目录下。</p>

<p><strong>BeautifulSoup 4.3.2</strong><br/>
<a href="http://www.crummy.com/software/BeautifulSoup/bs4/download/">下载页面</a>，
下载完毕，解压到Python安装目录下，如C:\Python2.7\BeautifulSoup目录下。</p>

<p><strong>html5lib</strong><br/>
<a href="https://pypi.python.org/pypi/html5lib">下载页面</a>
下载完毕，解压到Python安装目录下，如C:\Python2.7\html5lib-0.999目录下。</p>

<h3>安装工具</h3>

<p>Windows下启动命令行，依次进入如下目录，执行setup.py install进行安装：</p>

<pre><code>C:\Python2.7\six-1.8.0&gt;setup.py install  
C:\Python2.7\html5lib-0.999&gt;setup.py install  
C:\Python2.7\BeautifulSoup&gt;setup.py install  
</code></pre>

<h3>参考文档</h3>

<p><a href="https://docs.python.org/2/">Python 2.X文档</a><br/>
<a href="http://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html">BeautifulSoup文档</a><br/>
<a href="http://www.regexlab.com/zh/regref.htm">正则表达式文档</a><br/>
<a href="http://tool.oschina.net/regex">正则表达式在线测试</a></p>

<h3>用到的Python语法</h3>

<p>这个工具只用到了一些基本的Python语法，如果你没有Python基础，稍微了解一下如下博文是很有好处的。</p>

<ul>
<li>string: 字符串操作，参考<a href="http://www.cnblogs.com/sevenyuan/archive/2010/12/10/1902145.html">python: string的操作函数</a></li>
<li>list: 列表操作，参考<a href="http://www.cnblogs.com/zhengyuxin/articles/1938300.html">Python list 操作</a></li>
<li>dictionary: 字典操作，参考<a href="http://www.cnblogs.com/yangyongzhi/archive/2012/09/17/2688326.html">Python中dict详解</a></li>
<li>datetime: 日期时间，参考<a href="http://www.cnblogs.com/lhj588/archive/2012/04/23/2466653.html">python datetime处理时间</a></li>
</ul>


<p><br/></p>

<h3>编写博客导出工具</h3>

<h4>分析</h4>

<p>首先来分析这样一个工具的需求：</p>

<pre><code>导出所有CSDN博客文章为Markdown文本。
</code></pre>

<p>这个总需求其实可以分两步来做：</p>

<pre><code>* 获得CSDN博客文章
* 将文章转换为Markdown文本
</code></pre>

<p>针对第一步：如何获取博客文章呢？</p>

<p>打开任何一个CSDN博客，我们都可以看到下方的页面导航显示“XXX条数据 共XXX页 1 2 3 &hellip; 尾页”，我们从这个地方入手考虑。每个页面上都会显示属于该页的文章标题及文章链接，如果我们依次访问这些页面链接，就能从每个页面链接中找出属于该页面的文章标题及文章链接。这样所有的文章标题以及文章链接就都获取到了，有了这些文章链接，我们就能获取对应文章的html内容，然后通过解析这些html页面来生成相应Markdown文本了。</p>

<h4>实现</h4>

<p>从上面的分析可以看出，首先我们需要根据首页获取所有的页面链接，然后遍历每一个页面链接来获取文章链接。</p>

<ul>
<li>获取页面链接的代码：</li>
</ul>


<pre><code class="python 获取所有的页面的 url https://github.com/luozhaohui/python/blob/master/exportCSDNBlogAsMarkdown.py View Source">
def getHtml(url):
    try :
        if gUseCookie:
            opener = urllib2.build_opener()
            for k, v in gHeaders.items():
                opener.addheaders.append((k, v))
            response = opener.open(url)
            data = response.read().decode('utf-8')
        else:
            request = urllib2.Request(url, None, gHeaders)
            response = urllib2.urlopen(request)
            data = response.read().decode('utf-8')
    except urllib2.URLError, e :
        if hasattr(e, "code"):
            print "The server couldn't fulfill the request: " + url
            print "Error code: %s" % e.code
        elif hasattr(e, "reason"):
            print "We failed to reach a server. Please check your url: " + url + ", and read the Reason."
            print "Reason: %s" % e.reason
    return data

def getPageUrlList(url):
    page = getHtml(url)
    soup = BeautifulSoup(page)

    lastArticleHref = None
    pageListDocs = soup.find_all(id="papelist")
    for pageList in pageListDocs:
        hrefDocs = pageList.find_all("a")
        if len(hrefDocs) &gt; 0:
            lastArticleHrefDoc = hrefDocs[len(hrefDocs) - 1]
            lastArticleHref = lastArticleHrefDoc["href"].encode('UTF-8')

    if lastArticleHref == None:
        return []

    print " &gt; last page href:" + lastArticleHref
    lastPageIndex = lastArticleHref.rfind("/")
    lastPageNum = int(lastArticleHref[lastPageIndex+1:])
    urlInfo = "http://blog.csdn.net" + lastArticleHref[0:lastPageIndex]

    pageUrlList = []
    for x in xrange(1, lastPageNum + 1):
        pageUrl = urlInfo + "/" + str(x)
        pageUrlList.append(pageUrl)
        log(" &gt; page " + str(x) + ": " + pageUrl)

    log("total pages: " + str(len(pageUrlList)) + "\n")
    return pageUrlList
</code></pre>

<p>参数 url = &ldquo;<a href="http://blog.csdn.net/">http://blog.csdn.net/</a>&rdquo; + username，即你首页的网址。通过urllib2库打开这个url发起一个web请求，从response中获取返回的html页面内容保存到data中。你可以被注释的 print data 来查看到底返回了什么内容。</p>

<p>有了html页面内容，接下来就用BeautifulSoup来解析它。BeautifulSoup极大地减少了我们的工作量。我会详细在这里介绍它的使用，后面再次出现类似的解析就会从略了。soup.find_all(id=&ldquo;papelist&rdquo;) 将会查找html页面中所有id=&ldquo;papelist"的tag，然后返回包含这些tag的list。对应 CSDN 博文页面来说，只有一处地方：</p>

<p>``` html papelist html内容示例</p>

<div id="papelist" class="pagelist">
    <span> 236条数据  共12页</span>
    <strong>1</strong> 
    <a href="http://luozhaohui.github.io/kesalin/article/list/2">2</a>
    <a href="http://luozhaohui.github.io/kesalin/article/list/3">3</a>
    <a href="http://luozhaohui.github.io/kesalin/article/list/4">4</a> 
    <a href="http://luozhaohui.github.io/kesalin/article/list/5">5</a> 
    <a href="http://luozhaohui.github.io/kesalin/article/list/6">...</a> 
    <a href="http://luozhaohui.github.io/kesalin/article/list/2">下一页</a> 
    <a href="http://luozhaohui.github.io/kesalin/article/list/12">尾页</a>
</div>


<pre><code class="">
好，我们获得了papelist 的tag对象，通过这个tag对象我们能够找出尾页tag a对象，从这个tag a解析出对应的href属性，获得尾页的编号12，然后自己拼出所有page页面的访问url来，并保存在pageUrlList中返回。page页面的访问url形式示例如下：

    &gt; page 1: http://blog.csdn.net/kesalin/article/list/1

* 根据page来获取文章链接的代码：
</code></pre>

<p>def getArticleList(url):
    # 获取所有的文章的 url/title
    pageUrlList = getPageUrlList(url)</p>

<pre><code>articleListDocs = []

strPage = " &gt; parsing page {0}"
for pageUrl in pageUrlList:
    retryCount = 0
    print " &gt; parsing page {0}".format(pageUrl)

    slow_down() #访问太快会不响应
    page = getHtml(pageUrl);
    soup = BeautifulSoup(page)

    # 获取置顶文章
    topArticleDocs = soup.find_all(id="article_toplist")
    if topArticleDocs != None:
        articleListDocs = articleListDocs + topArticleDocs

    # 获取文章
    articleDocs = soup.find_all(id="article_list")
    if articleDocs != None:
        articleListDocs = articleListDocs + articleDocs

    break

artices = []
topTile = "[置顶]"
for articleListDoc in articleListDocs:
    linkDocs = articleListDoc.find_all("span", "link_title")
    for linkDoc in linkDocs:
        #print linkDoc.prettify().encode('UTF-8')
        link = linkDoc.a
        url = link["href"].encode('UTF-8')
        title = link.get_text().encode('UTF-8')
        title = title.replace(topTile, '').strip()
        oneHref = "http://blog.csdn.net" + url
        #log("   &gt; title:" + title + ", url:" + oneHref)
        artices.append([oneHref, title])

log("total articles: " + str(len(artices)) + "\n")
return artices
</code></pre>

<pre><code class="">
从第一步获得所有的page链接保存在pageUrlList中，接下来就根据这些page 页面来获取对应page的article链接和标题。关键代码如下面：
</code></pre>

<pre><code>    # 获取置顶文章
    topArticleDocs = soup.find_all(id="article_toplist")
    if topArticleDocs != None:
        articleListDocs = articleListDocs + topArticleDocs

    # 获取文章
    articleDocs = soup.find_all(id="article_list")
    if articleDocs != None:
        articleListDocs = articleListDocs + articleDocs
</code></pre>

<pre><code class="">
从page的html内容中查找置顶的文章（article_toplist）以及普通的文章（article_list）的tag对象，然后将这些tag保存到articleListDocs中。

article_toplist示例：(article_list的格式是类似的)
</code></pre>

<div id="article_toplist" class="list">
    <div class="list_item article_item">
        <div class="article_title">   
            <span class="ico ico_type_Original"></span>
            <h1>
                <span class="link_title">
                <a href="http://luozhaohui.github.io/kesalin/article/details/10474007">
                <font color="red">[置顶]</font>
                招聘：有兴趣做一个与Android对等的操作系统么？
                </a>
                </span>
            </h1>
        </div>
        ... ...
    </div>
    ... ...
</div>


<pre><code class="">
然后遍历所有的保存到articleListDocs里的tag对象，从中解析出link_title的span tag对象保存到linkDocs中；然后从中解析出链接的url和标题，这里去掉了置顶文章标题中的“置顶”两字；最后将url和标题保存到artices列表中返回。artices列表中的每一项内容示例：

       title:招聘：有兴趣做一个与Android对等的操作系统么？  
       url:http://blog.csdn.net/kesalin/article/details/10474007

* 根据文章链接获取文章html内容并解析转换为Markdown文本
</code></pre>

<p>def download(title, url, output):
    # 下载文章，并保存为 markdown 格式
    log(&ldquo; >> download: &rdquo; + url)</p>

<pre><code>categories = ""
content = ""
postDate = datetime.datetime.now()

slow_down();
page = getHtml(url)
soup = BeautifulSoup(page)

manageDocs = soup.find_all("div", "article_manage")
for managerDoc in manageDocs:
    categoryDoc = managerDoc.find_all("span", "link_categories")
    if len(categoryDoc) &gt; 0:
        categories = categoryDoc[0].a.get_text().encode('UTF-8').strip()

    postDateDoc = managerDoc.find_all("span", "link_postdate")
    if len(postDateDoc) &gt; 0:
        postDateStr = postDateDoc[0].string.encode('UTF-8').strip()
        postDate = datetime.datetime.strptime(postDateStr, '%Y-%m-%d %H:%M')

contentDocs = soup.find_all(id="article_content")
for contentDoc in contentDocs:
    htmlContent = contentDoc.prettify().encode('UTF-8')
    content = htmlContent2String(htmlContent)

exportToMarkdown(output, postDate, categories, title, content)
</code></pre>

<pre><code class="">
同前面的分析类似，在这里通过访问具体文章页面获得html内容，从中解析出文章标题，分类，发表时间，文章内容信息。然后把这些内容传递给函数exportToMarkdown，在其中生成相应的Markdown文本文件。值得一提的是，在解析文章内容信息时，由于html文档内容有一些特殊的标签或转义符号，需要作特殊处理，这些特殊处理在函数htmlContent2String中进行。目前只导出了所有的文本内容，图片，url链接以及表格都没有处理，后续我会尽量完善这些转换。
</code></pre>

<p>def htmlContent2String(contentStr):
    patternImg = re.compile(r'(&lt;img.+?src=&ldquo;)(.+?)(&rdquo;.+ />)&lsquo;)
    patternHref = re.compile(r&rsquo;(&lt;a.+?href=&ldquo;)(.+?)(&rdquo;.+?>)(.+?)(</a>)&lsquo;)
    patternRemoveHtml = re.compile(r&rsquo;&lt;/?[^>]+>&lsquo;)</p>

<pre><code>resultContent = patternImg.sub(r'![image_mark](\2)', contentStr)
resultContent = patternHref.sub(r'[\4](\2)', resultContent)
resultContent = re.sub(patternRemoveHtml, r'', resultContent)
resultContent = decodeHtmlSpecialCharacter(resultContent)
return resultContent
</code></pre>

<pre><code class="">
目前仅仅是删除所有的html标签，并在函数decodeHtmlSpecialCharacter中转换转义字符。

* 生成Markdown文本文件
</code></pre>

<p>def exportToMarkdown(exportDir, postdate, categories, title, content):
    titleDate = postdate.strftime(&lsquo;%Y-%m-%d&rsquo;)
    contentDate = postdate.strftime(&lsquo;%Y-%m-%d %H:%M:%S %z&rsquo;)
    filename = titleDate + &lsquo;-&rsquo; + title
    filename = repalceInvalidCharInFilename(filename)
    filepath = exportDir + &lsquo;/&rsquo; + filename + &lsquo;.markdown&rsquo;
    log(&ldquo; >> save as &rdquo; + filename)</p>

<pre><code>newFile = open(unicode(filepath, "utf8"), 'w')
newFile.write('---' + '\n')
newFile.write('layout: post' + '\n')
newFile.write('title: \"' + title + '\"\n')
newFile.write('date: ' + contentDate + '\n')
newFile.write('comments: true' + '\n')
newFile.write('categories: [' + categories + ']' + '\n')
newFile.write('tags: [' + categories + ']' + '\n')
newFile.write('description: \"' + title + '\"\n')
newFile.write('keywords: ' + categories + '\n') 
newFile.write('---' + '\n\n')
newFile.write(content)
newFile.write('\n')
newFile.close()
</code></pre>

<p>```</p>

<p>生成Markdown文本文件就很简单了，在这里我需要生成github page用的Markdown博文形式，所以内容如此，你可以根据你的需要修改为其他形式的文本内容。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android多线程分析之五：使用AsyncTask异步下载图像]]></title>
    <link href="http://luozhaohui.github.io/blog/2014/07/19/android-thread-tutoria05/"/>
    <updated>2014-07-19T21:12:40+08:00</updated>
    <id>http://luozhaohui.github.io/blog/2014/07/19/android-thread-tutoria05</id>
    <content type="html"><![CDATA[<h2>引言</h2>

<p>在本系列文章的第一篇<a href="https://luozhaohui.github.io/blog/2014/07/08/android-thread-tutoria01/">Android多线程分析之一：使用Thread异步下载图像</a>中，曾演示了如何使用 <code>Thread</code> 来完成异步任务。<code>Android</code> 为了简化在 <code>UI</code> 线程中完成异步任务（毕竟 <code>UI</code> 线程是 <code>app</code> 最重要的线程），实现了一个名为 <code>AysncTask</code> 的模板类。使用 <code>AysncTask</code> 能够在异步任务进行的同时，将任务进度状态反馈给 <code>UI</code> 线程（如让 <code>UI</code> 线程更新进度条）。正是由于它与 <code>UI</code> 线程紧密相关，使用的时候要就有一些限制，<code>AysncTask</code> 必须在 <code>UI</code> 线程中创建，并在 <code>UI</code> 线程中启动（通过调用其 <code>execute()</code> 方法）；此外，<code>AysncTask</code> 设计的目的是用于一些耗时较短的任务，如果是耗时较长的任务不推荐使用 <code>AysncTask</code>。</p>

<p>可以用简化记忆 “三参数，四步骤” 来学习 <code>AysncTask</code>。 即带有三个模板参数 <code>Params</code>, <code>Progress</code>, <code>Result</code>，四个处理步骤：<code>onPreExecute</code>，<code>doInBackground</code>，<code>onProgressUpdate</code>，<code>onPostExecute</code>。</p>

<!--more-->


<h2>简介</h2>

<h2>三参数</h2>

<blockquote><p><code>Params</code> 是异步任务所需的参数类型，也即 <code>doInBackground(Params&hellip; params)</code> 方法的参数类型；<br/>
<code>Progress</code> 是指进度的参数类型，也即 <code>onProgressUpdate(Progress&hellip; values)</code> 方法的参数类型；<br/>
<code>Result</code> 是指任务完成返回的参数类型，也即 <code>onPostExecute(Result result)</code> 或 <code>onCancelled(Result result)</code> 方法的参数类型。</p></blockquote>

<p>如果某一个参数类型没有意义或没有被用到，传递 <code>void</code> 即可。</p>

<h3>四步骤</h3>

<blockquote><p><code>protected void onPreExecute()</code>：在 <code>UI</code> 线程中运行，在异步任务开始之前被执行，以便 <code>UI</code> 线程完成一些初始化动作，如将进度条清零；<br/>
<code>protected abstract Result doInBackground(Params&hellip; params)</code>：在后台线程中运行，这是完成异步任务的地方，它是抽象接口，子类必须提供实现；<br/>
<code>protected void onProgressUpdate(Progress&hellip; values)</code>：在 <code>UI</code> 线程中运行，在异步任务执行的过程中可以通过调用 <code>void publishProgress(Progress&hellip; values)</code> 方法通知 <code>UI</code> 线程在 <code>onProgressUpdate</code> 方法内更新进度状态；<br/>
<code>protected void onPostExecute(Result result)</code>：在 <code>UI</code> 线程中运行，当异步任务完成之后被执行，以便 <code>UI</code> 线程更新任务完成状态。</p></blockquote>

<p><code>AysncTask</code> 支持取消异步任务，当异步任务被取消之后，上面的步骤四就不会被执行了，取而代之将执行 <code>onCancelled(Result result)</code>，以便 <code>UI</code> 线程更新任务被取消之后的状态。谨记：上面提到的这些方法都是回调函数，不需要用户手动去调用。</p>

<p>以前的 <code>AysncTask</code> 是基于单一后台线程实现的，而从 <code>Android 3.0</code> 起 <code>AysncTask</code> 是基于 <code>Android</code> 的并发库（<code>java.util.concurrent</code>）实现的，本文中不会展开讨论其具体实现，只是演示如何使用 <code>AysncTask。</p>

<h2>使用示例</h2>

<p>有了前面的轮廓介绍，再来使用 <code>AysncTask</code> 是非常容易的，下面的例子与<a href="https://luozhaohui.github.io/blog/2014/07/08/android-thread-tutoria01/">Android多线程分析之一：使用Thread异步下载图像</a>中的例子非常相似，只不过是使用 <code>AysncTask</code> 来完成异步任务罢了。</p>

<h2>权限</h2>

<p>这是一个使用 <code>AysncTask</code> 从网络上异步下载图片并在 <code>ImageView</code> 中显示的的简单示例。因为需要访问网络，所以要在 <code>manifest.xml</code> 中添加网络访问权限：
<code>xml
    &lt;uses-permission android:name="android.permission.INTERNET"&gt;
    &lt;/uses-permission&gt;
</code></p>

<h3>布局</h3>

<p>布局文件很简单，一个 <code>Button</code>，一个 <code>ImageView</code>：</p>

<pre><code class="xml">&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:padding="10dip" &gt;

    &lt;Button
        android:id="@+id/LoadButton"
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:text="Load"&gt;
    &lt;/Button&gt;

    &lt;ImageView
        android:id="@+id/ImageVivew" 
        android:layout_width="match_parent" 
        android:layout_height="400dip" 
        android:scaleType="centerInside" 
        android:padding="2dp"&gt;
    &lt;/ImageView&gt; 

&lt;/LinearLayout&gt;
</code></pre>

<h3>代码：</h3>

<p>首先来看定义：图片的 <code>url</code> 路径，两个消息值以及一些控件：</p>

<pre><code class="java">    private static final String sImageUrl = "http://fashion.qqread.com/ArtImage/20110225/0083_13.jpg";
    private Button mLoadButton;
    private ImageView mImageView;
</code></pre>

<p>然后来看控件的设置：</p>

<pre><code class="java">    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        Log.i("UI thread", " &gt;&gt; onCreate()");

        mImageView = (ImageView)this.findViewById(R.id.ImageVivew);

        mLoadButton = (Button)this.findViewById(R.id.LoadButton);
        mLoadButton.setOnClickListener(new View.OnClickListener() {
            @Override 
            public void onClick(View v) {
                LoadImageTask task = new LoadImageTask(v.getContext());
                task.execute(sImageUrl);
            }
        });
    }
</code></pre>

<p><code>LoadImageTask</code> 继承自 <code>AysncTask</code>，由这个类去完成异步图片下载任务，并相应地更新 <code>UI</code> 状态。</p>

<pre><code class="java">    class LoadImageTask extends AsyncTask&lt;String, Integer, Bitmap&gt; 
    {
        private ProgressDialog mProgressBar;

        LoadImageTask(Context context)
        {
            mProgressBar = new ProgressDialog(context);
            mProgressBar.setCancelable(true);
            mProgressBar.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
            mProgressBar.setMax(100);
        }

        @Override
        protected Bitmap doInBackground(String... params) {
            Log.i("Load thread", " &gt;&gt; doInBackground()");

            Bitmap bitmap = null;

            try{
                publishProgress(10);
                Thread.sleep(1000);

                InputStream in = new java.net.URL(sImageUrl).openStream();
                publishProgress(60);
                Thread.sleep(1000);

                bitmap = BitmapFactory.decodeStream(in);
                in.close();
            } catch (Exception e) {
                e.printStackTrace();
            }

            publishProgress(100);
            return bitmap;
        }

        @Override
        protected void onCancelled() {
            super.onCancelled();
        }

        @Override
        protected void onPreExecute() {

            mProgressBar.setProgress(0);
            mProgressBar.setMessage("Image downloading ... %0");
            mProgressBar.show();

            Log.i("UI thread", " &gt;&gt; onPreExecute()");
        }

        @Override
        protected void onPostExecute(Bitmap result) {
            Log.i("UI thread", " &gt;&gt; onPostExecute()");
            if (result != null) {
                mProgressBar.setMessage("Image downloading success!");
                mImageView.setImageBitmap(result);
            }
            else {
                mProgressBar.setMessage("Image downloading failure!");
            }

            mProgressBar.dismiss(); 
        }

       @Override
        protected void onProgressUpdate(Integer... values) {
           Log.i("UI thread", " &gt;&gt; onProgressUpdate() %" + values[0]);
           mProgressBar.setMessage("Image downloading ... %" + values[0]);
           mProgressBar.setProgress(values[0]);
        }
    };
</code></pre>

<p>在 <code>LoadImageTask 中，前面提到的四个步骤都涉及到了：</p>

<p>首先在任务开始之前在 <code>onPreExecute()</code> 方法中设置进度条的初始状态（<code>UI</code>线程）；然后在下载线程中执行 <code>doInBackground()</code> 以完成下载任务，并在其中调用 <code>publishProgress()</code> 来通知 <code>UI</code> 线程更新进度状态；<code>UI</code> 线程在 <code>onProgressUpdate()</code> 中得知进度，并更新进度条（<code>UI线程</code>）；最后下载任务完成，<code>UI</code> 线程在 <code>onPostExecute()</code>中得知下载好的图像，并更新<code>UI</code>显示该图像（<code>UI</code>线程）。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android多线程分析之四：MessageQueue的实现]]></title>
    <link href="http://luozhaohui.github.io/blog/2014/07/12/android-thread-tutoria04/"/>
    <updated>2014-07-12T20:53:20+08:00</updated>
    <id>http://luozhaohui.github.io/blog/2014/07/12/android-thread-tutoria04</id>
    <content type="html"><![CDATA[<h2>引言</h2>

<p>在前面两篇文章<a href="https://luozhaohui.github.io/blog/2014/07/10/android-thread-tutoria02/">Android多线程分析之二：Thread的实现</a>，<a href="https://luozhaohui.github.io/blog/2014/07/12/android-thread-tutoria03/">Android多线程分析之三：Handler，Looper的实现</a>中分别介绍了 <code>Thread</code> 的创建，运行，销毁的过程以及 <code>Thread</code>与 <code>Handler</code>，<code>Looper</code> 之间的关联：<code>Thread</code> 在其 <code>run()</code> 方法中创建和运行消息处理循环 <code>Looper</code>，而 <code>Looper::loop()</code> 方法不断地从 <code>MessageQueue</code> 中获取消息，并由 <code>Handler</code> 分发处理该消息。接下来就来介绍 <code>MessageQueue</code> 的运作机制。</p>

<h2>参考源码：</h2>

<pre><code>android/framework/base/core/java/android/os/MessageQueue.java
android/framework/base/core/java/android/os/Message.java
android/frameworks/base/core/jni/android_os_MessageQueue.h
android/frameworks/base/core/jni/android_os_MessageQueue.cpp
</code></pre>

<!--more-->


<h2>构造函数及成员变量</h2>

<p>先来看 <code>MessageQueue</code> 的构造函数以及重要的成员变量：</p>

<pre><code class="java">    // True if the message queue can be quit.
    private final boolean mQuitAllowed;
    private int mPtr; // used by native code
    Message mMessages;
    private boolean mQuiting;
    // Indicates whether next() is blocked waiting in pollOnce() with a non-zero timeout.
    private boolean mBlocked;
</code></pre>

<p><code>mQuitAllowed</code>: 其含义与 <code>Looper.prepare(boolean quitAllowed)</code> 中参数含义一直，是否允许中止；
<code>mPtr</code>：<code>Android MessageQueue</code> 是通过调用 <code>C++ native MessageQueue</code> 实现的，这个 <code>mPtr</code> 就是指向 <code>native MessageQueue</code>；
<code>mMessages</code>：<code>Message</code> 是链表结构的，因此这个变量就代表 <code>Message</code> 链表；
<code>mQuiting</code>：是否终止了；
<code>mBlocked</code>：是否正在等待被激活以获取消息；</p>

<p><code>MessageQueue</code> 的构造函数很简单：</p>

<pre><code class="java">    MessageQueue(boolean quitAllowed) {
        mQuitAllowed = quitAllowed;
        nativeInit();
    }
</code></pre>

<p>它通过转调 <code>native</code> 方法 <code>nativeInit()</code> 实现的，后者是定义在 <code>android_os_MessageQueue.cpp</code>中：</p>

<pre><code class="cpp">static void android_os_MessageQueue_nativeInit(JNIEnv* env, jobject obj) {
    NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();
    if (!nativeMessageQueue) {
        jniThrowRuntimeException(env, "Unable to allocate native queue");
        return;
    }

    nativeMessageQueue-&gt;incStrong(env);
    android_os_MessageQueue_setNativeMessageQueue(env, obj, nativeMessageQueue);
}
static void android_os_MessageQueue_setNativeMessageQueue(JNIEnv* env, jobject messageQueueObj,
        NativeMessageQueue* nativeMessageQueue) {
    env-&gt;SetIntField(messageQueueObj, gMessageQueueClassInfo.mPtr,
             reinterpret_cast&lt;jint&gt;(nativeMessageQueue));
}
</code></pre>

<p><code>nativeInit()</code> 方法创建 <code>NativeMessageQueue</code> 对象，并将这个对象的指针复制给 <code>Android MessageQueue</code> 的 <code>mPtr</code>。<code>NativeMessageQueue</code> 的定义如下：</p>

<pre><code class="java">class MessageQueue : public RefBase {
public:
    /* Gets the message queue's looper. */
    inline sp&lt;Looper&gt; getLooper() const {
        return mLooper;
    }

    bool raiseAndClearException(JNIEnv* env, const char* msg);
    virtual void raiseException(JNIEnv* env, const char* msg, jthrowable exceptionObj) = 0;
protected:
    MessageQueue();
    virtual ~MessageQueue();
protected:
    sp&lt;Looper&gt; mLooper;
};

class NativeMessageQueue : public MessageQueue {
public:
    NativeMessageQueue();
    virtual ~NativeMessageQueue();
    virtual void raiseException(JNIEnv* env, const char* msg, jthrowable exceptionObj);
    void pollOnce(JNIEnv* env, int timeoutMillis);
    void wake();

private:
    bool mInCallback;
    jthrowable mExceptionObj;
};
</code></pre>

<h2>消息同步</h2>

<p>其中值得关注的是 <code>NativeMessageQueue</code> 的构造以及<code>pollOnce</code>，<code>wake</code> 两个方法，它们是<code>Java MessageQueue</code> 中 <code>nativePollOnce</code> 和 <code>nativeWake</code> 的 <code>native</code> 方法：</p>

<pre><code class="cpp">NativeMessageQueue::NativeMessageQueue() : mInCallback(false), mExceptionObj(NULL) {
    mLooper = Looper::getForThread();
    if (mLooper == NULL) {
        mLooper = new Looper(false);
        Looper::setForThread(mLooper);
    }
}

void NativeMessageQueue::pollOnce(JNIEnv* env, int timeoutMillis) {
    mInCallback = true;
    mLooper-&gt;pollOnce(timeoutMillis);
    mInCallback = false;
}

void NativeMessageQueue::wake() {
    mLooper-&gt;wake();
}
</code></pre>

<p>在 <code>NativeMessageQueue</code> 的构造函数中，会获取当前线程的 <code>Looper</code>(注意这是 <code>C++ Looper</code>,定义在<code>frameworks/native/libs/utils/Looper.h</code> 中)，如果当前线程还没有 <code>Looper</code>，就创建一个，并保存在线程的 <code>TLS</code> 中。<code>pollOnce</code> 和 <code>wake</code> 最终都是通过 <code>Linux</code> 的 <code>epoll</code> 模型来实现的。<code>pollOnce()</code> 通过等待被激活，然后从消息队列中获取消息；<code>wake()</code> 则是激活处于等待状态的消息队列，通知它有消息到达了。这是典型的生产者-消费者模型。</p>

<p>对于<code>Android MessageQueue</code> 来说，其主要的工作就是：接收投递进来的消息，获取下一个需要处理的消息。这两个功能是通过 <code>enqueueMessage()</code> 和 <code>next()</code> 方法实现的。<code>next()</code> 在前一篇文章介绍 <code>Looper.loop()</code> 时提到过。</p>

<h2>Message</h2>

<p>在分析这两个函数之前，先来介绍一下 <code>Message</code>：前面说过 <code>Message</code> 是完备的，即它同时带有消息内容和处理消息的 <code>Handler</code> 或 <code>callback</code>。下面列出它的主要成员变量：</p>

<pre><code class="cpp">public int what;     // 消息 id
public int arg1;     // 消息参数
public int arg2;     // 消息参数
public Object obj;   // 消息参数
long when;           // 处理延迟时间，由 Handler 的 sendMessageDelayed/postDelayed 设置
Handler target;    // 处理消息的 Handler
Runnable callback;   // 处理消息的回调
Message next;    // 链表结构，指向下一个消息
</code></pre>

<p><code>Message</code> 有一些名为 <code>obtain</code> 的静态方法用于创建 <code>Message</code>，通常我们都是通过 <code>Handler</code> 的 <code>obtain</code> 静态方法转调 <code>Message</code> 的静态方法来创建新的 <code>Message</code>。</p>

<p>接下来分析 <code>enqueueMessage()</code>enqueueMessage：
``` java
    final boolean enqueueMessage(Message msg, long when) {
        if (msg.isInUse()) {
            throw new AndroidRuntimeException(msg + &ldquo; This message is already in use.&rdquo;);
        }
        if (msg.target == null) {
            throw new AndroidRuntimeException(&ldquo;Message must have a target.&rdquo;);
        }</p>

<pre><code>    boolean needWake;
    synchronized (this) {
        if (mQuiting) {
            return false;
        }

        msg.when = when;
        Message p = mMessages;
        if (p == null || when == 0 || when &lt; p.when) {
            // New head, wake up the event queue if blocked.
            msg.next = p;
            mMessages = msg;
            needWake = mBlocked;
        } else {
            // Inserted within the middle of the queue.  Usually we don't have to wake
            // up the event queue unless there is a barrier at the head of the queue
            // and the message is the earliest asynchronous message in the queue.
            needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();
            Message prev;
            for (;;) {
                prev = p;
                p = p.next;
                if (p == null || when &lt; p.when) {
                    break;
                }
                if (needWake &amp;&amp; p.isAsynchronous()) {
                    needWake = false;
                }
            }
            msg.next = p; // invariant: p == prev.next
            prev.next = msg;
        }
    }
    if (needWake) {
        nativeWake(mPtr);
    }
    return true;
}
</code></pre>

<pre><code>
首先检测消息的合法性：是否已经在处理中和是否有处理它的 &lt;code&gt;Handler&lt;/code&gt;，然后判断 &lt;code&gt;mQuiting&lt;/code&gt; 是否中止了，如果没有则根据消息处理时间排序将消息插入链表中的合适位置。在这其中作了一些减少同步操作的优化，即使当前消息队列已经处于 &lt;code&gt;Blocked&lt;/code&gt; 状态，且队首是一个消息屏障(和内存屏障的理念一样，这里是通过 &lt;code&gt;p.target == null&lt;/code&gt; 来判断队首是否是消息屏障)，并且要插入的消息是所有异步消息中最早要处理的才会 &lt;code&gt;needwake&lt;/code&gt; 激活消息队列去获取下一个消息。&lt;code&gt;Handler&lt;/code&gt; 的 &lt;code&gt;post/sendMessage&lt;/code&gt; 系列方法最后都是通过转调 &lt;code&gt;MessageQueue&lt;/code&gt; 的 &lt;code&gt;enqueueMessage&lt;/code&gt; 来实现的，比如：
</code></pre>

<pre><code>public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
    MessageQueue queue = mQueue;
    if (queue == null) {
        RuntimeException e = new RuntimeException(
                this + " sendMessageAtTime() called with no mQueue");
        Log.w("Looper", e.getMessage(), e);
        return false;
    }
    return enqueueMessage(queue, msg, uptimeMillis);
}

private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
    msg.target = this;
    if (mAsynchronous) {
        msg.setAsynchronous(true);
    }
    return queue.enqueueMessage(msg, uptimeMillis);
}
</code></pre>

<pre><code>
其实 &lt;code&gt;Handler&lt;/code&gt; 中与 &lt;code&gt;Message&lt;/code&gt; 相关的静态方法都是通过 &lt;code&gt;MessageQueue&lt;/code&gt; 的对应的静态方法实现的，比如 &lt;code&gt;removeMessages&lt;/code&gt;, &lt;code&gt;hasMessages&lt;/code&gt;, &lt;code&gt;hasCallbacks&lt;/code&gt; 等等，这里就不一一详述了。至此，已经完整地分析了如何通过 &lt;code&gt;Handler&lt;/code&gt; 提交消息到 &lt;code&gt;MessageQueue&lt;/code&gt; 中了。

## 获取消息
下面来分析如何从 &lt;code&gt;MessageQueue&lt;/code&gt; 中获取合适的消息, 这是 &lt;code&gt;next()&lt;/code&gt; 要做的最主要的事情，&lt;code&gt;next()&lt;/code&gt; 方法还做了其他一些事情，这些其它事情是为了提高系统效果，利用消息队列在空闲时通过 &lt;code&gt;idle handler&lt;/code&gt; 做一些事情，比如 &lt;code&gt;gc&lt;/code&gt; 等等。但它们和获取消息关系不大，所以这部分将从略介绍。
</code></pre>

<p>   final Message next() {
        int pendingIdleHandlerCount = -1; // -1 only during first iteration
        int nextPollTimeoutMillis = 0;</p>

<pre><code>    for (;;) {
        if (nextPollTimeoutMillis != 0) {
            Binder.flushPendingCommands();
        }
        nativePollOnce(mPtr, nextPollTimeoutMillis);

        synchronized (this) {
            if (mQuiting) {
                return null;
            }

            // Try to retrieve the next message.  Return if found.
            final long now = SystemClock.uptimeMillis();
            Message prevMsg = null;
            Message msg = mMessages;
            if (msg != null &amp;&amp; msg.target == null) {
                // Stalled by a barrier.  Find the next asynchronous message in the queue.
                do {
                    prevMsg = msg;
                    msg = msg.next;
                } while (msg != null &amp;&amp; !msg.isAsynchronous());
            }
            if (msg != null) {
                if (now &lt; msg.when) {
                    // Next message is not ready.  Set a timeout to wake up when it is ready.
                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                } else {
                    // Got a message.
                    mBlocked = false;
                    if (prevMsg != null) {
                        prevMsg.next = msg.next;
                    } else {
                        mMessages = msg.next;
                    }
                    msg.next = null;
                    if (false) Log.v("MessageQueue", "Returning message: " + msg);
                    msg.markInUse();
                    return msg;
                }
            } else {
                // No more messages.
                nextPollTimeoutMillis = -1;
            }

            // If first time idle, then get the number of idlers to run.
            // Idle handles only run if the queue is empty or if the first message
            // in the queue (possibly a barrier) is due to be handled in the future.
            if (pendingIdleHandlerCount &lt; 0
                    &amp;&amp; (mMessages == null || now &lt; mMessages.when)) {
                pendingIdleHandlerCount = mIdleHandlers.size();
            }
            if (pendingIdleHandlerCount &lt;= 0) {
                // No idle handlers to run.  Loop and wait some more.
                mBlocked = true;
                continue;
            }

            if (mPendingIdleHandlers == null) {
                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
            }
            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
        }

        // Run the idle handlers.
        // We only ever reach this code block during the first iteration.
        for (int i = 0; i &lt; pendingIdleHandlerCount; i++) {
            final IdleHandler idler = mPendingIdleHandlers[i];
            mPendingIdleHandlers[i] = null; // release the reference to the handler

            boolean keep = false;
            try {
                keep = idler.queueIdle();
            } catch (Throwable t) {
                Log.wtf("MessageQueue", "IdleHandler threw exception", t);
            }

            if (!keep) {
                synchronized (this) {
                    mIdleHandlers.remove(idler);
                }
            }
        }

        // Reset the idle handler count to 0 so we do not run them again.
        pendingIdleHandlerCount = 0;

        // While calling an idle handler, a new message could have been delivered
        // so go back and look again for a pending message without waiting.
        nextPollTimeoutMillis = 0;
    }
}
</code></pre>

<pre><code>
队列被激活之后，首先判断队首是不是消息屏障，如果是则跳过所有的同步消息，查找最先要处理的异步消息。如果第一个待处理的消息还没有到要处理的时机则设置激活等待时间；否则这个消息就是需要处理的消息，将该消息设置为 &lt;code&gt;inuse&lt;/code&gt;，并将队列设置为非  &lt;code&gt;blocked&lt;/code&gt; 状态，然后返回该消息。&lt;code&gt;next()&lt;/code&gt; 方法是在  &lt;code&gt;Looper.loop()&lt;/code&gt; 中被调用的，&lt;code&gt;Looper&lt;/code&gt; 在获得要处理的消息之后就会调用和消息关联的 &lt;code&gt;Handler&lt;/code&gt; 来分发消息，这里再回顾一下：
</code></pre>

<p>  public static void loop() {
        final Looper me = myLooper();
        if (me == null) {
            throw new RuntimeException(&ldquo;No Looper; Looper.prepare() wasn&rsquo;t called on this thread.&rdquo;);
        }
        final MessageQueue queue = me.mQueue;
        &hellip;
        for (;;) {
            Message msg = queue.next(); // might block
            if (msg == null) {
                // No message indicates that the message queue is quitting.
                return;
            }</p>

<pre><code>        msg.target.dispatchMessage(msg);

        msg.recycle();
    }
}
</code></pre>

<p>```</p>

<p>如果队列中没有消息或者第一个待处理的消息时机未到，且也没有其他利用队列空闲要处理的事务，则将队列设置为设置 <code>blocked</code> 状态，进入等待状态；否则就利用队列空闲处理其它事务。</p>

<p>至此，已经对 <code>Android</code> 多线程相关的主要概念 <code>Thread</code>, <code>HandlerThread</code>, <code>Handler</code>, <code>Looper</code>, <code>Message</code>, <code>MessageQueue</code> 作了一番介绍，下一篇就要讲讲 <code>AsyncTask</code>，这是为了简化 <code>UI</code> 多线程编程为提供的一个便利工具类。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android多线程分析之三：Handler，Looper的实现]]></title>
    <link href="http://luozhaohui.github.io/blog/2014/07/12/android-thread-tutoria03/"/>
    <updated>2014-07-12T20:53:20+08:00</updated>
    <id>http://luozhaohui.github.io/blog/2014/07/12/android-thread-tutoria03</id>
    <content type="html"><![CDATA[<h2>引言</h2>

<p>在前文<a href="https://luozhaohui.github.io/blog/2014/07/10/android-thread-tutoria02/">Android多线程分析之二：Thread的实现</a>中已经详细分析了<code>Android Thread</code> 是如何创建，运行以及销毁的，其重点是对相应 <code>native</code> 方法进行分析，今天我将聚焦于 <code>Android Framework</code> 层多线程相关的类：<code>Handler</code>, <code>Looper</code>, <code>MessageQueue</code>, <code>Message</code> 以及它们与<code>Thread</code> 之间的关系。可以用一个不太妥当的比喻来形容它们之间的关联：如果把 <code>Thread</code> 比作生产车间，那么 <code>Looper</code> 就是放在这车间里的生产线，这条生产线源源不断地从 <code>MessageQueue</code> 中获取材料 <code>Messsage</code>，并分发处理 <code>Message</code> (由于 <code>Message</code> 通常是完备的，所以 <code>Looper</code> 大多数情况下只是调度让 <code>Message</code> 的 <code>Handler</code> 去处理 <code>Message</code>)。正是因为消息需要在 <code>Looper</code> 中处理，而 <code>Looper</code> 又需运行在 <code>Thread</code> 中，所以不能随随便便在非 <code>UI</code> 线程中进行 <code>UI</code> 操作。 <code>UI</code> 操作通常会通过投递消息来实现，只有往正确的 <code>Looper</code> 投递消息才能得到处理，对于 <code>UI</code> 来说，这个 <code>Looper</code> 一定是运行在 <code>UI</code> 线程中。</p>

<!--more-->


<h2>示例</h2>

<p>在编写 <code>app</code> 的过程中，我们常常会这样来使用 <code>Handler</code>：</p>

<pre><code class="java">Handler mHandler = new Handler();
mHandler.post(new Runnable(){
    @Override
    public void run() {
        // do somework
    }
});
</code></pre>

<p>或者如这系列文章<a href="https://luozhaohui.github.io/blog/2014/07/08/android-thread-tutoria01/">Android多线程分析之一：使用Thread异步下载图像</a>中的示例那样：</p>

<pre><code class="java">    private Handler mHandler= new Handler(){
        @Override
        public void handleMessage(Message msg) {
            Log.i("UI thread", " &gt;&gt; handleMessage()");

            switch(msg.what){
            case MSG_LOAD_SUCCESS:
                Bitmap bitmap = (Bitmap) msg.obj;
                mImageView.setImageBitmap(bitmap);

                mProgressBar.setProgress(100);
                mProgressBar.setMessage("Image downloading success!");
                mProgressBar.dismiss();
                break;

            case MSG_LOAD_FAILURE:
                mProgressBar.setMessage("Image downloading failure!");
                mProgressBar.dismiss();
                break;
            }
        }
    };

    Message msg = mHandler.obtainMessage(MSG_LOAD_FAILURE, null);
    mHandler.sendMessage(msg);
</code></pre>

<h2>Handler</h2>

<p>那么，在 <code>Handler</code> 的 <code>post/sendMessage</code> 背后到底发生了什么事情呢？下面就来解开这个谜团。
首先我们从 <code>Handler</code> 的构造函数开始分析：</p>

<pre><code class="java">    final MessageQueue mQueue; 
    final Looper mLooper; 
    final Callback mCallback; 
    final boolean mAsynchronous;

    public Handler(Looper looper, Callback callback, boolean async) {
        mLooper = looper;
        mQueue = looper.mQueue;
        mCallback = callback;
        mAsynchronous = async;
    }

    public Handler(Callback callback, boolean async) {
        mLooper = Looper.myLooper();
        if (mLooper == null) {
            throw new RuntimeException(
                "Can't create handler inside thread that has not called Looper.prepare()");
        }
        mQueue = mLooper.mQueue;
        mCallback = callback;
        mAsynchronous = async;
    }

    public Handler() {
        this(null, false);
    }
</code></pre>

<p>上面列出了 <code>Handler</code> 的一些成员变量：</p>

<blockquote><p><code>mLooper</code>：线程的消息处理循环，注意：并非每一个线程都有消息处理循环，因此 <code>Framework</code> 中线程可以分为两种：有 <code>Looper</code> 的和无 <code>Looper</code> 的。为了方便 <code>app</code> 开发，<code>Framework</code> 提供了一个有 <code>Looper</code> 的 <code>Thread</code> 实现：<code>HandlerThread</code>。在前一篇<a href="https://luozhaohui.github.io/blog/2014/07/10/android-thread-tutoria02/">Android多线程分析之二：Thread的实现</a>中也提到了两种不同 <code>Thread</code> 的 <code>run()</code> 方法的区别。</p></blockquote>

<pre><code class="java">/**
 * Handy class for starting a new thread that has a looper. The looper can then be 
 * used to create handler classes. Note that start() must still be called.
 */
public class HandlerThread extends Thread {
    Looper mLooper;
    /**
     * Call back method that can be explicitly overridden if needed to execute some
     * setup before Looper loops.
     */
    protected void onLooperPrepared() {
    }

    public void run() {
        mTid = Process.myTid();
        Looper.prepare();
        synchronized (this) {
            mLooper = Looper.myLooper();
            notifyAll();
        }
        Process.setThreadPriority(mPriority);
        onLooperPrepared();
        Looper.loop();
        mTid = -1;
    }

    /**
     * This method returns the Looper associated with this thread. If this thread not been started
     * or for any reason is isAlive() returns false, this method will return null. If this thread 
     * has been started, this method will block until the looper has been initialized.  
     * @return The looper.
     */
    public Looper getLooper() {
        if (!isAlive()) {
            return null;
        }

        // If the thread has been started, wait until the looper has been created.
        synchronized (this) {
            while (isAlive() &amp;&amp; mLooper == null) {
                try {
                    wait();
                } catch (InterruptedException e) {
                }
            }
        }
        return mLooper;
    }
}
</code></pre>

<h2>Looper</h2>

<p>这个 <code>HandlerThread</code> 与 <code>Thread</code> 相比，多了一个类型为 <code>Looper</code> 成员变量 <code>mLooper</code>，它是在 <code>run()</code> 函数中由 <code>Looper::prepare()</code> 创建的，并保存在 <code>TLS</code> 中：</p>

<pre><code class="java">/** Initialize the current thread as a looper.
      * This gives you a chance to create handlers that then reference
      * this looper, before actually starting the loop. Be sure to call
      * {@link #loop()} after calling this method, and end it by calling
      * {@link #quit()}.
      */
    public static void prepare() {
        prepare(true);
    }

    private static void prepare(boolean quitAllowed) {
        if (sThreadLocal.get() != null) {
            throw new RuntimeException("Only one Looper may be created per thread");
        }
        sThreadLocal.set(new Looper(quitAllowed));
    }
</code></pre>

<p>然后通过 <code>Looper::myLooper()</code> 获取创建的 <code>Looper</code>：</p>

<pre><code class="java">    /**
     * Return the Looper object associated with the current thread.  Returns
     * null if the calling thread is not associated with a Looper.
     */
    public static Looper myLooper() {
        return sThreadLocal.get();
    }
</code></pre>

<p>最后通过 <code>Looper::Loop()</code> 方法运行消息处理循环：从 <code>MessageQueue</code> 中取出消息，并分发处理该消息，不断地循环这个过程。这个方法将在后面介绍。</p>

<blockquote><p><code>Handler</code> 的成员变量 <code>mQueue</code> 是其成员变量 <code>mLooper</code> 的成员变量，这里只是为了简化书写，单独拿出来作为 <code>Handler</code> 的成员变量；成员变量 <code>mCallback</code> 提供了另一种使用<code>Handler</code> 的简便途径：只需实现回调接口 <code>Callback</code>，而无需子类化<code>Handler</code>，下面会讲到的：</p></blockquote>

<pre><code class="java">    /**
     * Callback interface you can use when instantiating a Handler to avoid
     * having to implement your own subclass of Handler.
     */
    public interface Callback {
        public boolean handleMessage(Message msg);
    }
</code></pre>

<p>成员变量 <code>mAsynchronous</code> 是标识是否异步处理消息，如果是的话，通过该 <code>Handler obtain</code> 得到的消息都被强制设置为异步的。
同是否有无 <code>Looper</code> 来区分 <code>Thread</code> 一样，<code>Handler</code> 的构造函数也分为自带 <code>Looper</code> 和外部 <code>Looper</code> 两大类：如果提供了 <code>Looper</code>，在消息会在该 <code>Looper</code> 中处理，否则消息就会在当前线程的 <code>Looper</code> 中处理，注意这里要确保当前线程一定有 <code>Looper</code>。所有的 <code>UI thread</code> 都是有 <code>Looper</code> 的，因为 <code>view/widget</code> 的实现中大量使用了消息，需要 <code>UI thread</code> 提供 <code>Looper</code> 来处理，可以参考<code>view.java</code>：</p>

<p>view.java
<code>java
    public boolean post(Runnable action) {
        final AttachInfo attachInfo = mAttachInfo;
        if (attachInfo != null) {
            return attachInfo.mHandler.post(action);
        }
        // Assume that post will succeed later
        ViewRootImpl.getRunQueue().post(action);
        return true;
    }
</code></p>

<p>ViewRootImpl.java</p>

<pre><code class="java">    private void performTraversals() {
        ....
        // Execute enqueued actions on every traversal in case a detached view enqueued an action
        getRunQueue().executeActions(attachInfo.mHandler);
      ...
    }

    static RunQueue getRunQueue() {
        RunQueue rq = sRunQueues.get();
        if (rq != null) {
            return rq;
        }
        rq = new RunQueue();
        sRunQueues.set(rq);
        return rq;
    }

    /**
     * The run queue is used to enqueue pending work from Views when no Handler is
     * attached.  The work is executed during the next call to performTraversals on
     * the thread.
     * @hide
     */
    static final class RunQueue {
    ...
        void executeActions(Handler handler) {
            synchronized (mActions) {
                final ArrayList&lt;HandlerAction&gt; actions = mActions;
                final int count = actions.size();

                for (int i = 0; i &lt; count; i++) {
                    final HandlerAction handlerAction = actions.get(i);
                    handler.postDelayed(handlerAction.action, handlerAction.delay);
                }

                actions.clear();
            }
        }
    }
</code></pre>

<p>从上面的代码可以看出，作为所有控件基类的 <code>view</code> 提供了 <code>post</code> 方法，用于向 <code>UI thread</code> 发送消息，并在 <code>UI thread</code> 的 <code>Looper</code> 中处理这些消息，而 <code>UI thread</code> 一定有 <code>Looper</code> 这是由 <code>ActivityThread</code> 来保证的：</p>

<pre><code class="java">public final class ActivityThread {
...
    final Looper mLooper = Looper.myLooper();
}
</code></pre>

<p><code>UI</code> 操作需要向 <code>UI</code> 线程发送消息并在其 <code>Looper</code> 中处理这些消息。这就是为什么我们不能在非 <code>UI</code> 线程中更新 <code>UI</code> 的原因，在控件在非 <code>UI</code> 线程中构造 <code>Handler</code> 时，要么由于非 <code>UI</code> 线程没有 <code>Looper</code> 使得获取 <code>myLooper</code> 失败而抛出 <code>RunTimeException</code>，要么即便提供了 <code>Looper</code>，但这个 <code>Looper</code> 并非 <code>UI</code> 线程的 <code>Looper</code> 而不能处理控件消息。为此在 <code>ViewRootImpl</code> 中有一个强制检测 <code>UI</code> 操作是否是在 <code>UI</code> 线程中处理的方法 <code>checkThread()</code>：该方法中的 <code>mThread</code> 是在 <code>ViewRootImpl</code> 的构造函数中赋值的，它就是 <code>UI</code> 线程；该方法中的 <code>Thread.currentThread()</code> 是当前进行 <code>UI</code> 操作的线程，如果这个线程不是非 <code>UI</code> 线程就会抛出异常<code>CalledFromWrongThreadException</code>。</p>

<pre><code class="java">    void checkThread() {
        if (mThread != Thread.currentThread()) {
            throw new CalledFromWrongThreadException(
                    "Only the original thread that created a view hierarchy can touch its views.");
        }
    }
</code></pre>

<p>如果修改<a href="https://luozhaohui.github.io/blog/2014/07/08/android-thread-tutoria01/">Android多线程分析之一：使用Thread异步下载图像</a>中示例，下载完图像 <code>bitmap</code> 之后，在 <code>Thread</code> 的 <code>run()</code> 函数中设置 <code>ImageView</code> 的图像为该 <code>bitmap</code>，即会抛出上面提到的异常：</p>

<pre><code>W/dalvikvm(796): threadid=11: thread exiting with uncaught exception (group=0x40a71930)
E/AndroidRuntime(796): FATAL EXCEPTION: Thread-75
E/AndroidRuntime(796): android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.
E/AndroidRuntime(796):  at android.view.ViewRootImpl.checkThread(ViewRootImpl.java:4746)
E/AndroidRuntime(796):  at android.view.ViewRootImpl.requestLayout(ViewRootImpl.java:823)
E/AndroidRuntime(796):  at android.view.View.requestLayout(View.java:15473)
E/AndroidRuntime(796):  at android.view.View.requestLayout(View.java:15473)
E/AndroidRuntime(796):  at android.view.View.requestLayout(View.java:15473)
E/AndroidRuntime(796):  at android.view.View.requestLayout(View.java:15473)
E/AndroidRuntime(796):  at android.view.View.requestLayout(View.java:15473)
E/AndroidRuntime(796):  at android.widget.ImageView.setImageDrawable(ImageView.java:406)
E/AndroidRuntime(796):  at android.widget.ImageView.setImageBitmap(ImageView.java:421)
E/AndroidRuntime(796):  at com.example.thread01.MainActivity$2$1.run(MainActivity.java:80)
</code></pre>

<h2>处理消息</h2>

<p><code>Handler</code> 的构造函数暂且介绍到这里，接下来介绍：<code>handleMessage</code> 和 <code>dispatchMessage</code>：</p>

<pre><code class="java">/**
     * Subclasses must implement this to receive messages.
     */
    public void handleMessage(Message msg) {
    }

    /**
     * Handle system messages here.
     */
    public void dispatchMessage(Message msg) {
        if (msg.callback != null) {
            handleCallback(msg);
        } else {
            if (mCallback != null) {
                if (mCallback.handleMessage(msg)) {
                    return;
                }
            }
            handleMessage(msg);
        }
    }
</code></pre>

<p>前面提到有两种方式来设置处理消息的代码：一种是设置 <code>Callback</code> 回调，一种是子类化 <code>Handler</code>。而子类化 <code>Handler</code> 其子类就要实现 <code>handleMessage</code> 来处理自定义的消息，如前面的匿名子类示例一样。<code>dispatchMessage</code> 是在 <code>Looper::Loop()</code> 中被调用，即它是在线程的消息处理循环中被调用，这样就能让 <code>Handler</code> 不断地处理各种消息。在 <code>dispatchMessage</code> 的实现中可以看到，如果 <code>Message</code> 有自己的消息处理回调，那么就优先调用消息自己的消息处理回调：</p>

<pre><code class="java">    private static void handleCallback(Message message) {
        message.callback.run();
    }
</code></pre>

<p>否则看 <code>Handler</code> 是否有消息处理回调 <code>mCallback</code>，如果有且 <code>mCallback</code> 成功处理了这个消息就返回了，否则就调用 <code>handleMessage</code>（通常是子类的实现） 来处理消息。</p>

<p>在分析 <code>Looper::Loop()</code> 这个关键函数之前，先来理一理 <code>Thread，Looper，Handler，MessageQueue</code> 的关系：<code>Thread</code> 需要有 <code>Looper</code> 才能处理消息（也就是说 <code>Looper</code> 是运行在 <code>Thread</code> 中），这是通过在自定义 <code>Thread</code> 的 <code>run()</code> 函数中调用 <code>Looper::prepare()</code> 和 <code>Looper::loop()</code> 来实现，然后在 <code>Looper::loop()</code> 中不断地从 <code>MessageQueue</code> 获取由 <code>Handler</code> 投递到其中的 <code>Message</code>，并调用 <code>Message</code> 的成员变量 <code>Handler</code> 的 <code>dispatchMessage</code> 来处理消息。</p>

<p>下面先来看看 <code>Looper</code> 的构造函数：</p>

<pre><code class="java">    final MessageQueue mQueue;
    final Thread mThread;
    volatile boolean mRun;

    private Looper(boolean quitAllowed) {
        mQueue = new MessageQueue(quitAllowed);
        mRun = true;
        mThread = Thread.currentThread();
    }
</code></pre>

<p><code>Looper</code> 的构造函数很简单，创建 <code>MessageQueue</code>，保存当前线程到 <code>mThread</code> 中。但它是私有的，只能通过两个静态函数 <code>prepare()</code>/<code>prepareMainLooper()</code> 来调用，前面已经介绍了 <code>prepare()</code>,下面来介绍 <code>prepareMainLooper()</code>:</p>

<pre><code class="java">/**
     * Initialize the current thread as a looper, marking it as an
     * application's main looper. The main looper for your application
     * is created by the Android environment, so you should never need
     * to call this function yourself.  See also: {@link #prepare()}
     */
    public static void prepareMainLooper() {
        prepare(false);
        synchronized (Looper.class) {
            if (sMainLooper != null) {
                throw new IllegalStateException("The main Looper has already been prepared.");
            }
            sMainLooper = myLooper();
        }
    }
</code></pre>

<p><code>prepareMainLooper</code> 是通过调用 <code>prepare</code> 实现的，不过传入的参数为 <code>false</code>，表示 <code>main Looper</code> 不允许中途被中止，创建之后将 <code>looper</code> 保持在静态变量 <code>sMainLooper</code> 中。整个 <code>Framework</code> 框架只有两个地方调用了 <code>prepareMainLooper</code> 方法：</p>

<h3>ServerThread</h3>

<p><code>SystemServer.java</code> 中的 <code>ServerThread</code>，<code>ServerThread</code> 的重要性就不用说了，绝大部分 <code>Android Service</code> 都是这个线程中初始化的。这个线程是在 <code>Android</code> 启动过程中的 <code>init2()</code> 方法启动的：</p>

<pre><code class="java">    public static final void init2() {
        Slog.i(TAG, "Entered the Android system server!");
        Thread thr = new ServerThread();
        thr.setName("android.server.ServerThread");
        thr.start();
    }

class ServerThread extends Thread {
    @Override
    public void run() {
        ...
        Looper.prepareMainLooper();
        ...
        Looper.loop();
        Slog.d(TAG, "System ServerThread is exiting!");
    }
}
</code></pre>

<h3>ActivityThread</h3>

<p>以及 <code>ActivityThread.java</code> 的 <code>main()</code> 方法：</p>

<pre><code class="java">public static void main(String[] args) {
        ....
        Looper.prepareMainLooper();

        ActivityThread thread = new ActivityThread();
        thread.attach(false);

        if (sMainThreadHandler == null) {
            sMainThreadHandler = thread.getHandler();
        }

        AsyncTask.init();

        Looper.loop();

        throw new RuntimeException("Main thread loop unexpectedly exited");
    }
</code></pre>

<p><code>ActivityThread</code> 的重要性也不言而喻，它是 <code>Activity</code> 的主线程，也就是 <code>UI</code> 线程。注意这里的 <code>AsyncTask.init()</code>，在后面介绍 <code>AsyncTask</code> 时会详细介绍的，这里只提一下：<code>AsyncTask</code> 能够进行 <code>UI</code> 操作正是由于在这里调用了 <code>init()</code>。</p>

<h2>Looper::Loop()</h2>

<p>有了前面的铺垫，这下我们就可以来分析 <code>Looper::Loop()</code> 这个关键函数了：</p>

<pre><code class="java">/**
     * Run the message queue in this thread. Be sure to call
     * {@link #quit()} to end the loop.
     */
    public static void loop() {
        final Looper me = myLooper();
        if (me == null) {
            throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");
        }
        final MessageQueue queue = me.mQueue;
        ...
        for (;;) {
            Message msg = queue.next(); // might block
            if (msg == null) {
                // No message indicates that the message queue is quitting.
                return;
            }

            msg.target.dispatchMessage(msg);

            msg.recycle();
        }
    }
</code></pre>

<p><code>loop()</code> 的实现非常简单，一如前面一再说过的那样：不断地从 <code>MessageQueue</code> 中获取消息，分发消息，回收消息。从上面的代码可以看出: <code>loop()</code> 仅仅是一个不断循环作业的生产流水线，而 <code>MessageQueue</code> 则为它提供原材料 <code>Message</code>，让它去分发处理。至于 <code>Handler</code> 是怎么提交消息到 <code>MessageQueue</code> 中，<code>MessageQueue</code> 又是怎么管理消息的，且待下文分解。</p>
]]></content>
  </entry>
  
</feed>
