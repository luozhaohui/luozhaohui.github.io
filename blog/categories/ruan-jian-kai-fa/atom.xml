<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类：软件开发 | 飘飘白云]]></title>
  <link href="http://luozhaohui.github.io/blog/categories/ruan-jian-kai-fa/atom.xml" rel="self"/>
  <link href="http://luozhaohui.github.io/"/>
  <updated>2017-11-14T15:52:37+08:00</updated>
  <id>http://luozhaohui.github.io/</id>
  <author>
    <name><![CDATA[飘飘白云]]></name>
    <email><![CDATA[kesalin@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[基于C++11模板元编程实现Scheme中的list及相关函数式编程接口]]></title>
    <link href="http://luozhaohui.github.io/blog/2017/03/15/cpp-scheme/"/>
    <updated>2017-03-15T09:03:20+08:00</updated>
    <id>http://luozhaohui.github.io/blog/2017/03/15/cpp-scheme</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>本文将介绍如何使用<code>C++11</code>模板元编程实现<code>Scheme</code>中的<code>list</code>及相关函数式编程接口，如<code>list</code>，<code>cons</code>，<code>car</code>，<code>cdr</code>，<code>length</code>，<code>is_empty</code>，<code>reverse</code>，<code>append</code>,<code>map</code>，<code>transform</code>，<code>enumerate</code>，<code>lambda</code>等。</p>

<h2>预备知识</h2>

<h3>Scheme简介</h3>

<p><a href="http://schemers.org/">Scheme</a>语言是<code>lisp</code>语言的一个方言(或说成变种)，它诞生于1975年的<code>MIT</code>，对于这个有近三十年历史的编程语言来说，它并没有象 C++，java，C#那样受到商业领域的青睐，在国内更是鲜为人知。但它在国外的计算机教育领域内却是有着广泛应用的，有很多人学的第一门计算机语言就 是<code>Scheme</code>语言（<a href="https://book.douban.com/subject/1148282/">SICP</a>曾经就是以<code>Scheme</code>为教学语言）。</p>

<p>它是一个小巧而又强大的语言，作为一个多用途的编程语言，它可以作为脚本语言使用，也可以作为应用软件的扩展语言来使用，它具有元语言特性，还有很多独到的特色,以致于它被称为编程语言中的"皇后"。</p>

<p>如果你对<code>Scheme</code>感兴趣，推荐使用<a href="http://racket-lang.org/">drracket</a>这个</ode>GUI</code>解释器，入门教程有：<a href="http://www.htdp.org/">How to Design Programs</a>，高级教程有：<a href="https://book.douban.com/subject/1148282/">SICP</a>。</p>

<h3>Scheme中的list及相关操作</h3>

<p><code>list</code>可以说是<code>Lisp</code>系语言的根基，其名就得自于<code><strong>LIS</strong>t <strong>P</strong>rocessor</code>，其重要性就像文件概念之于<code>unix</code>。</p>

<h3>模板元编程</h3>

<p>C++中的Meta Programming，即模板元编程，是图灵完备的，而且是编译期间完成的。模板元编程通常用于编写工具库，如STL、Boost等。</p>

<p>比如通常我们使用递归来实现实现阶乘：
```</p>

<h1>include <iostream></h1>

<p>unsigned int factorial(unsigned int n) {
    return n == 0 ? 1 : n * factorial(n - 1);
}</p>

<p>int main() {
    std::cout &lt;&lt; factorial(5) &lt;&lt; std::endl;
    return 0;
}
<code>  
我们也可以通过模板元编程来实现：
</code></p>

<h1>include <iostream></h1>

<p>template <unsigned int n>
struct factorial {
    static constexpr unsigned int value = n * factorial<n - 1>::value;
};</p>

<p>template &lt;>
struct factorial<0> {
    static constexpr unsigned int value = 1;
};</p>

<p>int main() {
    std::cout &lt;&lt; factorial<5>::value &lt;&lt; std::endl; // 120
    return 0;
}
```</p>

<h2>实现</h2>

<p>本文完整代码可以在这里查看：<a href="https://github.com/luozhaohui/cpp/blob/master/cons.cpp">点击查看代码</a></p>

<h3>基本数据结构</h3>

<p>为了用模板元编程来模拟Scheme中<code>list</code>即相关操作，我们需要先定义一些模板数据结构。这些数据结构非常简单，即重新定义基本数据类型，为了简化，在这里我只特化了必须的<code>int</code>、<code>uint</code>、<code>bool</code>以及<code>empty</code>的实现。<code>empty</code>是递归实现<code>list</code>的最后一个元素，其作用相当于<code>&lsquo;\0&rsquo;</code>之于字符串。</p>

<pre><code class="">// type_
//
template &lt;typename T, T N&gt;
struct type_ {
    using type = type_&lt;T, N&gt;;
    using value_type = T;
    static constexpr T value = N;
};

// int_
//
template &lt;int N&gt;
struct int_ {
    using type = int_&lt;N&gt;;
    using value_type = int;
    static constexpr int value = N;
};

// uint_
//
template &lt;unsigned int N&gt;
struct uint_ {
    using type = uint_&lt;N&gt;;
    using value_type = unsigned int;
    static constexpr unsigned int value = N;
};

template &lt;&gt;
struct uint_&lt;0&gt; {
    using type = uint_&lt;0&gt;;
    using value_type = unsigned int;
    static constexpr unsigned int value = 0;
};

// bool_
template &lt;bool N&gt;
struct bool_ {
    using type = bool_&lt;N&gt;;
    using value_type = bool;
    static constexpr bool value = N;
};

// empty
//
struct empty {
    using type = empty;
    using value = empty;
};
</code></pre>

<p>下面我们先来个小示例，看看怎么使用这些模板数据结构。这个示例的作用是将仅仅用0和1表示的十进制数字当成二进制看，转换为十进制数值。如：101 转换为十进制数值为 5.
```
template <unsigned int N>
struct binary : uint_ &lt; binary &lt; N / 10 >::type::value * 2 + (N % 10) > {};</p>

<p>template &lt;>
struct binary<0> : uint_<0> {};
<code>
测试示例：
</code>
std::cout &lt;&lt; binary<101>::value &lt;&lt; std::endl;               // 5
```</p>

<h3>cons &amp; car &amp; cdr实现</h3>

<p><code>cons</code>的实现原理很简单：就是能够递归调用自己结合成点对<code>pair</code>。在<code>Scheme</code>中示例如下：
<code>
(cons 1 (cons 2 (cons 3 '())))
</code>
其中<code>&lsquo;()</code>表示空的点对<code>pair</code>，在我们的实现里面就是<code>empty</code>。</p>

<p>因此<code>cons</code>用C++元编程实现就是：
<code>
template &lt;typename h, typename t&gt;
struct cons {
    using type = cons&lt;h, t&gt;;
    using head = h;
    using tail = t;
};
</code>
使用示例：
<code>
std::cout &lt;&lt; cons&lt;int_&lt;1&gt;, int_&lt;2&gt;&gt;::head::value &lt;&lt; std::endl;  // 1
</code></p>

<p>同样，我们可以实现用于获取<code>head</code>的<code>car</code>与获取<code>tail</code>的<code>cdr</code>操作：
```
struct car_t {
    template <typename cons>
    struct apply {
        using type = typename cons::type::head;
    };
};</p>

<p>template <typename cons>
struct car : car_t::template apply<cons>::type {};</p>

<p>struct cdr_t {
    template <typename cons>
    struct apply {
        using type = typename cons::type::tail::type;
    };
};</p>

<p>template <typename cons>
struct cdr : cdr_t::template apply<cons>::type {};
<code>
使用示例：
</code>
    using c1 = cons&lt;int<em><1>, cons&lt;int</em><2>, int_<3>>>;
    std::cout &lt;&lt; car<c1>::value &lt;&lt; &ldquo;, &rdquo; &lt;&lt; cdr<c1>::head::value &lt;&lt; std::endl; // 1, 2
    std::cout &lt;&lt; car<c1>::value &lt;&lt; &ldquo;, &rdquo; &lt;&lt; car&lt;cdr<c1>>::value &lt;&lt; std::endl; // 1, 2
```</p>

<p>对于上面的实现，稍微解释一下：<code>car</code>是对<code>car_t</code>的封装，这样使用起来更为方便，对比如下用法就能明了，后面这样的封装手法还会用到：
<code>
car&lt;cons&lt;int_&lt;1&gt;, int_&lt;2&gt;&gt;::value                   // == 1
car_f::template apply&lt;cons&lt;int_&lt;1&gt;, int_&lt;2&gt;&gt;::value // == 1
</code></p>

<h3>list的实现</h3>

<p><code>list</code>其实一种特殊的<code>cons</code>，其实现如下：
```
template <typename first = empty, typename ...rest>
struct list_t : std::conditional &lt;
    sizeof&hellip;(rest) == 0,
    cons&lt;first, empty>,
    cons&lt;first, typename list_t&lt;rest&hellip;>::type>>::type
{};</p>

<p>template &lt;>
struct list_t<empty> : empty {};</p>

<p>template <typename T, T ...elements>
struct list : list_t&lt;type<em>&lt;T, elements>&hellip;> {};
```
这里用到了C++11中的变长模板参数，<code>std::conditional</code>以及对<code>empty</code>的特化处理。
 - 变长模板参数：<code>list</code>接收变长模板参数<code>elements</code>，然后封装类型为成<code>type</em></code>的变长模板参数forward给<code>list_t</code>；
 - <code>std::conditional</code>：相当于<code>if &hellip; else &hellip;</code>，如果第一参数为真，则返回第二参数，否则返回第三参数；
 - &lt;第一参数中的code>sizeof&hellip;(rest)</code>：<code>sizeof</code>是C++11的新用法，用于获取变长参数的个数；
 - 第二参数的作用是终止递归；
 - 第三参数的作用是递归调用<code>list_t</code>构造点对。
 - 因为<code>empty</code>比较特殊，所以需要特化处理</p>

<p>使用示例：
```
    using l1 = list&lt;int, 1, 2, 3>;
    using l2 = list&lt;int, 4, 5, 6, 7>;
    using l3 = list_t&lt;int<em><1>, int</em><2>, int_<3>>;</p>

<pre><code>std::cout &lt;&lt; "\n&gt;list" &lt;&lt; std::endl;
print&lt;l1&gt;();    // 1, 2, 3
print&lt;l3&gt;();    // 1, 2, 3
std::cout &lt;&lt; car&lt;l1&gt;::value &lt;&lt; ", " &lt;&lt; cdr&lt;l1&gt;::head::value &lt;&lt; std::endl;   // 1, 2
</code></pre>

<pre><code>
### length &amp; is_empty的实现
先来看看&lt;code&gt;length&lt;code&gt;的实现，其思路与list的实现一样：递归调用自身，并针对&lt;code&gt;empty&lt;/code&gt;特化处理。
</code></pre>

<p>template <typename list>
struct length_t
{
    static constexpr unsigned int value =
        1 + length_t<typename cdr<list>::type>::value;
};</p>

<p>template &lt;>
struct length_t<empty>
{
    static constexpr unsigned int value = 0;
};</p>

<p>template <typename list>
struct length
{
    static constexpr unsigned int value = length_t<typename list::type>::value;
};
```
<code>is_empty</code>可以简单实现为判断<code>length</code>为0：</p>

<pre><code class="">template &lt;typename list&gt;
struct is_empty
{
    static constexpr bool value = (0 == length&lt;list&gt;::value);
};
</code></pre>

<p>当然这样的实现效率并不高，因此可以通过对<code>list</code>以及<code>empty</code>的特化处理来高效实现：</p>

<pre><code class="">template &lt;typename list&gt;
struct is_empty_t
{
    static constexpr bool value = false;
};

template &lt;&gt;
struct is_empty_t&lt;empty&gt;
{
    static constexpr bool value = true;
};

template &lt;typename list&gt;
struct is_empty
{
    static constexpr bool value = is_empty_t&lt;typename list::type&gt;::value;
};
</code></pre>

<p>使用示例：</p>

<pre><code class="">    std::cout &lt;&lt; "is_empty&lt;empty&gt; : " &lt;&lt; is_empty&lt;empty&gt;::value &lt;&lt; std::endl;            // 1
    std::cout &lt;&lt; "is_empty&lt;list&lt;int&gt;&gt; : " &lt;&lt; is_empty&lt;list&lt;int&gt;&gt;::value &lt;&lt; std::endl;    // 1
    std::cout &lt;&lt; "is_empty&lt;list&lt;int, 1, 2, 3&gt;&gt; : " &lt;&lt; is_empty&lt;l1&gt;::value &lt;&lt; std::endl;  // 0
    std::cout &lt;&lt; "length&lt;empty&gt; : " &lt;&lt; length&lt;empty&gt;::value &lt;&lt; std::endl;                // 0
    std::cout &lt;&lt; "length&lt;list&lt;int&gt;&gt; : " &lt;&lt; length&lt;list&lt;int&gt;&gt;::value &lt;&lt; std::endl;        // 0
    std::cout &lt;&lt; "length&lt;list&lt;int, 1, 2, 3&gt;&gt; : " &lt;&lt; length&lt;l1&gt;::value &lt;&lt; std::endl;      // 3
</code></pre>

<h3>append &amp; reverse的实现</h3>

<p><code>append</code>是将一个列表list2追加到已有列表list1的后面，其实现思路是递归地将car<list1>当做head，然后将cdr<list1>作为新的list1递归调用append。不要忘记特化<code>empty</code>的情况。</p>

<pre><code class="">struct append_t {
    template &lt;typename list1, typename list2&gt;
    struct apply : cons&lt;
        typename car&lt;list1&gt;::type,
        typename append_t::template apply&lt;typename cdr&lt;list1&gt;::type, list2&gt;::type&gt;
    {};

    template&lt;typename list2&gt;
    struct apply &lt;empty, list2&gt;: list2
    {};
};

template &lt;typename list1, typename list2&gt;
struct append : std::conditional &lt;
    is_empty&lt;list1&gt;::value,
    list2,
    append_t::template apply&lt;list1, list2&gt;
    &gt;::type
{};
</code></pre>

<p><code>reverse</code>的实现思路与<code>append</code>类似，只不过是要逆序罢了：</p>

<pre><code class="">struct reverse_t {
    template &lt;typename reset, typename ready&gt;
    struct apply : reverse_t::template apply&lt;
            typename cdr&lt;reset&gt;::type,
            cons&lt;typename car&lt;reset&gt;::type, ready&gt;&gt;
    {};

    template&lt;typename ready&gt;
    struct apply &lt;empty, ready&gt; : ready
    {};
};

template &lt;typename list&gt;
struct reverse : std::conditional &lt;
    is_empty&lt;list&gt;::value,
    list,
    reverse_t::template apply&lt;typename list::type, empty&gt;
    &gt;::type
{};
</code></pre>

<p>使用示例：</p>

<pre><code class="">    // reverse
    using r1 = reverse&lt;l1&gt;;
    using r2 = reverse&lt;list&lt;int&gt;&gt;;
    print&lt;r1&gt;();    // 3, 2, 1
    print&lt;r2&gt;();

    // append
    using a1 = append&lt;l1, l2&gt;;
    using a2 = append&lt;l1, list&lt;int&gt;&gt;;
    using a3 = append&lt;list&lt;int&gt;, l1&gt;;
    print&lt;a1&gt;();    // 1, 2, 3, 4, 5, 6, 7
    print&lt;a2&gt;();    // 1, 2, 3
    print&lt;a3&gt;();    // 1, 2, 3
</code></pre>

<h3>函数式编程</h3>

<p><code>lisp</code>系语言的最大特性就是支持函数式编程，它能够把无差别地对待数据与函数，实现了对数据与代码的同等抽象。下面我们来添加对函数式编程的支持：<code>enumerate</code>, <code>map</code>，<code>apply</code>, <code>lambda</code> 以及 <code>transform</code>。</p>

<h4>map的实现</h4>

<p><code>map</code>的语义是迭代地将某个方法作用于列表中的每个元素，然后得到结果<code>list</code>。先来定义一些辅助的方法：</p>

<pre><code class="">template &lt;typename T, typename N&gt;
struct plus : int_ &lt; T::value + N::value &gt; {};

template &lt;typename T, typename N&gt;
struct minus : int_ &lt; T::value - N::value &gt; {};

struct inc_t {
    template &lt;typename n&gt;
    struct apply : int_ &lt; n::value + 1 &gt; {};
};

template &lt;typename n&gt;
struct inc : int_ &lt; n::value + 1 &gt; {};
</code></pre>

<p>下面来看map的实现
```
struct map_t {
    template <typename fn, typename list>
    struct apply : cons &lt;
        typename fn::template apply<typename car<list>::type>,
        map_t::template apply&lt;fn, typename cdr<list>::type>
    >{};</p>

<pre><code>template &lt;typename fn&gt;
struct apply &lt;fn, empty&gt;: empty{};
</code></pre>

<p>};</p>

<p>template <typename fn, typename list>
struct map : std::conditional &lt;
    is_empty<list>::value,
    list,
    map_t::template apply&lt;fn, list>
    >::type
{};
```
使用示例：</p>

<pre><code class="">    using m1 = map&lt;inc_t, list&lt;int, 1, 2, 3&gt;&gt;;
    using m2 = map&lt;inc_t, list&lt;int&gt;&gt;;
    print&lt;m1&gt;();    // 2, 3, 4
    print&lt;m2&gt;();
</code></pre>

<p>为了让<code>map</code>支持形如<code>inc</code>这样的模板类，而不仅仅是形如<code>inc_t</code>，我们需要定义一个转换器：<code>lambda</code>：</p>

<pre><code class="">struct apply_t {
    template &lt;template &lt;typename...&gt; class F, typename ...args&gt;
    struct apply : F&lt;typename args::type...&gt; {};

    template &lt;template &lt;typename...&gt; class F&gt;
    struct apply &lt;F, empty&gt; : empty {};
};

template &lt;template &lt;typename...&gt; class F, typename ...args&gt;
struct apply : apply_t::template apply&lt;F, args...&gt; {};

template &lt;template &lt;typename...&gt; class F&gt;
struct lambda {
    template &lt;typename ...args&gt;
    struct apply : apply_t::template apply&lt;F, args...&gt; {};
};
</code></pre>

<p>使用示例：</p>

<pre><code class="">    std::cout &lt;&lt; lambda&lt;inc&gt;::template apply&lt;int_&lt;0&gt;&gt;::value &lt;&lt; std::endl;  // 1
    using ml1 = map&lt;lambda&lt;inc&gt;, list&lt;int, 1, 2, 3&gt;&gt;;
    print&lt;ml1&gt;();  // 2, 3, 4
</code></pre>

<h3>transform的实现</h3>

<p><code>transform</code>的语义是对迭代地将某个方法作用于两个列表上的元素，然后得到结果<code>list</code>。</p>

<pre><code class="">struct transform_t {
    template &lt;typename list1, typename list2, typename fn&gt;
    struct apply : cons &lt;
        typename fn::template apply&lt;
            typename car&lt;list1&gt;::type, typename car&lt;list2&gt;::type&gt;::type,
        typename transform_t::template apply &lt;
            typename cdr&lt;list1&gt;::type, typename cdr&lt;list2&gt;::type, fn&gt;::type
    &gt; {};

    template &lt;typename list1, typename fn&gt;
    struct apply&lt;list1, empty, fn&gt; : cons &lt;
        typename fn::template apply&lt;typename car&lt;list1&gt;::type, empty&gt;,
        typename transform_t::template apply &lt;typename cdr&lt;list1&gt;::type, empty, fn&gt;::type
    &gt; {};

    template &lt;typename list2, typename fn&gt;
    struct apply&lt;empty, list2, fn&gt; : cons &lt;
        typename fn::template apply&lt;empty, typename car&lt;list2&gt;::type&gt;::type,
        typename transform_t::template apply &lt;empty, typename cdr&lt;list2&gt;::type, fn&gt;::type
    &gt; {};

    template &lt;typename fn&gt;
    struct apply&lt;empty, empty, fn&gt; : empty {};
};

template &lt;typename list1, typename list2, typename fn&gt;
struct transform : std::conditional &lt;
    is_empty&lt;list1&gt;::value,
    list1,
    transform_t::template apply&lt;list1, list2, fn&gt;
    &gt;::type
{
    static_assert(length&lt;list1&gt;::value == length&lt;list2&gt;::value, "transform: length of lists mismatch!");
};
</code></pre>

<p>其实现是最为复杂的，我们先来看使用示例，再来讲解实现细节。</p>

<pre><code class="">    using t1 = list&lt;int, 1, 2, 3&gt;;
    using t2 = list&lt;int, 3, 2, 1&gt;;
    using ml = transform&lt;t1, t2, lambda&lt;minus&gt;&gt;;
    using pl = transform&lt;t1, t2, lambda&lt;plus&gt;&gt;;
    using te = transform&lt;list&lt;int&gt;, list&lt;int&gt;, lambda&lt;plus&gt;&gt;;
    using el = transform&lt;t1, list&lt;int&gt;, lambda&lt;plus&gt;&gt;;
    print&lt;ml&gt;();    // -2, 0, 2
    print&lt;pl&gt;();    // 4, 4, 4
    print&lt;te&gt;();
    // print&lt;el&gt;(); // assertion: length mismatch!
</code></pre>

<p>实现细节：</p>

<ul>
<li>使用C++11新特性<code>static_assert</code>对两个列表的长度相等做断言；</li>
<li>使用<code>std::conditional</code>处理空列表，如果非空forward给<code>transform_t</code>；</li>
<li>对<code>transform_t</code>特化处理空列表的情况；</li>
<li>如果<code>list1</code>与<code>list2</code>均非空，那么通过<code>car</code>取出两个列表的<code>head</code>作用于方法，然后递归调用<code>transform_t</code>作用于两个列表的<code>tail</code>。</li>
</ul>


<h3>enumerate的实现</h3>

<p><code>enumerate</code>的语义是迭代将某个方法作用于列表元素。</p>

<pre><code class="">template &lt;typename fn, typename list, bool is_empty&gt;
struct enumerate_t;

template &lt;typename fn, typename list&gt;
void enumerate(fn f)
{
    enumerate_t&lt;fn, list, is_empty&lt;list&gt;::value&gt; impl;
    impl(f);
}

template &lt;typename fn, typename list, bool is_empty = false&gt;
struct enumerate_t
{
    void operator()(fn f) {
        f(car&lt;list&gt;::value);
        enumerate&lt;fn, typename cdr&lt;list&gt;::type&gt;(f);
    }
};

template &lt;typename fn, typename list&gt;
struct enumerate_t&lt;fn, list, true&gt;
{
    void operator()(fn f) {
        // nothing for empty
    }
};
</code></pre>

<p><code>enumerate</code>的实现与之前的<code>map</code>的实现很不一样，它是通过模板方法与函数子来实现的。模板方法内部调用函数子来做事情，函数子又是一个模板类，并对空列表做了特化处理。</p>

<p>使用示例：</p>

<pre><code class="">    using value_type = typename car&lt;e1&gt;::value_type;
    auto sqr_print = [](value_type val) { std::cout &lt;&lt; val * val &lt;&lt; " "; };
    enumerate&lt;decltype(sqr_print), e1&gt;(sqr_print);      // 1 4 9
</code></pre>

<h3>equal的实现</h3>

<p><code>equal</code>用于判断两个列表是否等价。</p>

<pre><code class="">struct equal_t {
    // both lists are not empty
    template &lt;typename list1, typename list2, int empty_value = 0,
        typename pred = lambda&lt;std::is_same&gt;&gt;
    struct apply : std::conditional &lt;
        !pred::template apply &lt;
            typename car&lt;list1&gt;::type,
            typename car&lt;list2&gt;::type
            &gt;::type::value,
        bool_&lt;false&gt;,
        typename equal_t::template apply &lt;
            typename cdr&lt;list1&gt;::type,
            typename cdr&lt;list2&gt;::type,
            (is_empty&lt;typename cdr&lt;list1&gt;::type&gt;::value
                + is_empty&lt;typename cdr&lt;list2&gt;::type&gt;::value),
            pred
        &gt;::type
    &gt; {};

    // one of the list is empty.
    template &lt;typename list1, typename list2, typename pred&gt;
    struct apply&lt;list1, list2, 1, pred&gt;: bool_&lt;false&gt;
    {};

    // both lists are empty.
    template &lt;typename list1, typename list2, typename pred&gt;
    struct apply&lt;list1, list2, 2, pred&gt;: bool_&lt;true&gt;
    {};
};

template &lt;typename list1, typename list2, typename pred = lambda&lt;std::is_same&gt;&gt;
struct equal : equal_t::template apply&lt;list1, list2,
    (is_empty&lt;list1&gt;::value + is_empty&lt;list2&gt;::value), pred&gt;::type
{};
</code></pre>

<p><code>equal</code>的实现也有点复杂。</p>

<ul>
<li>pred是等价比较谓词，默认是使用<code>std::is_same</code>来做比较；</li>
<li>关键部分依然是通过<code>std::conditional</code>来实现的；</li>
<li>第一参数是判断两个列表的<code>head</code>是否相等；</li>
<li>如果不等就返回第二参数；</li>
<li>如果相等就递归比较两个列表的剩余元素；</li>
<li>这里使用了一个小小的技巧来简化模板类特化的情况：如果其中一个列表为空，那么<code>empty_value</code>为1；如果两个列表均为空，那么<code>empty_value</code>为2，这两种情况都会调用特化版本。</li>
</ul>


<p>使用示例：</p>

<pre><code class="">    using e1 = list&lt;int, 1, 2, 3&gt;;
    using e2 = list&lt;int, 1, 2, 3&gt;;
    using e3 = list&lt;int, 1, 2, 1&gt;;
    std::cout &lt;&lt; "equal&lt;e1, e2&gt; : " &lt;&lt; equal&lt;e1, e2&gt;::value &lt;&lt; std::endl;   // 1
    std::cout &lt;&lt; "equal&lt;e1, e3&gt; : " &lt;&lt; equal&lt;e1, e3&gt;::value &lt;&lt; std::endl;   // 0
    std::cout &lt;&lt; "equal&lt;e1, list&lt;int&gt;&gt; : " &lt;&lt; equal&lt;e1, list&lt;int&gt;&gt;::value &lt;&lt; std::endl; // 0
    std::cout &lt;&lt; "equal&lt;list&lt;int&gt;, e1&gt; : " &lt;&lt; equal&lt;list&lt;int&gt;, e1&gt;::value &lt;&lt; std::endl; // 0
    std::cout &lt;&lt; "equal&lt;list&lt;int&gt;, list&lt;int&gt;&gt; : " &lt;&lt; equal&lt;list&lt;int&gt;, list&lt;int&gt;&gt;::value &lt;&lt; std::endl;   // 1
</code></pre>

<h3>print的实现</h3>

<p><code>print</code>是依次打印列表元素，也可以使用enumerate来实现：</p>

<pre><code class="">template &lt;typename list, bool is_empty&gt;
struct print_t;

template &lt;typename list&gt;
void print()
{
    print_t&lt;list, is_empty&lt;list&gt;::value&gt; impl;
    impl();
}

template &lt;typename list, bool is_empty = true&gt;
struct print_t
{
    void operator()() {
        std::cout &lt;&lt; std::endl;
    }
};

template &lt;typename list&gt;
struct print_t&lt;list, false&gt;
{
    void operator()() {
        std::cout &lt;&lt; car&lt;list&gt;::value;
        using rest = typename cdr&lt;list&gt;::type;
        if (false == is_empty&lt;rest&gt;::value) {
            std::cout &lt;&lt; ", ";
        }
        print&lt;rest&gt;();
    }
};
</code></pre>

<p><code>print</code>的实现思路与<code>enumerate</code>，是通过模板方法与函数子来实现的。模板方法内部调用函数子来做事情，函数子又是一个模板类，并对空列表做了特化处理。</p>

<h2>总结</h2>

<p><code>C++</code>尤其是<code>C++</code>11，14，17等新特性使得这把实用的瑞士军刀越发锋利与实用，虽然实现的形式上不如<code>Scheme</code>、<code>Python</code>等优雅，但它确实能够，而且无需获得语言层面上的支持。纸上得来终觉浅，绝知此事要躬行。看过本文的读者不妨自己实现一番本文中的提到的相关概念。</p>

<h3>参考阅读</h3>

<p><a href="https://book.douban.com/subject/1148282/">《计算机程序的构造与解释》</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android5 Zygote 与 SystemServer 启动流程分析]]></title>
    <link href="http://luozhaohui.github.io/blog/2016/02/25/android-zygote-server/"/>
    <updated>2016-02-25T22:13:20+08:00</updated>
    <id>http://luozhaohui.github.io/blog/2016/02/25/android-zygote-server</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p><code>Android5.0.1</code> 的启动流程与之前的版本相比变化并不大，OK，变化虽然还是有：<code>SystemServer</code> 启动过程的 <code>init1()</code>, <code>init2()</code>没有了，但主干流程依然不变：<code>Linux</code> 内核加载完毕之后，首先启动 <code>init</code> 进程，然后解析 <code>init.rc</code>，并根据其内容由 <code>init</code> 进程装载 <code>Android</code> 文件系统、创建系统目录、初始化属性系统、启动一些守护进程，其中最重要的守护进程就是 <code>Zygote</code> 进程。<code>Zygote</code> 进程初始化时会创建 <code>Dalvik</code> 虚拟机、预装载系统的资源和 <code>Java</code> 类。所有从 <code>Zygote</code> 进程 <code>fork</code> 出来的用户进程都将继承和共享这些预加载的资源。<code>init</code> 进程是 <code>Android</code> 的第一个进程，而 <code>Zygote</code> 进程则是所有用户进程的根进程。<code>SystemServer</code> 是 <code>Zygote</code> 进程 <code>fork</code> 出的第一个进程，也是整个 <code>Android</code> 系统的核心进程。</p>

<h2>zygote 进程</h2>

<h3>解析 zygote.rc</h3>

<p>在文件中 /system/core/rootdir/init.rc 中包含了 zygote.rc:
<code>
import /init.${ro.zygote}.rc
</code></p>

<p><code>${ro.zygote}</code>是平台相关的参数，实际可对应到 <code>init.zygote32.rc</code>， <code>init.zygote64.rc</code>， <code>init.zygote64_32.rc</code>， <code>init.zygote32_64.rc</code>，前两个只会启动单一<code>app_process(64)</code> 进程，而后两个则会启动两个<code>app_process</code>进程：第二个<code>app_process</code>进程称为 <code>secondary</code>，在后面的代码中可以看到相应 <code>secondary socket</code> 的创建过程。为简化起见，在这里就不考虑这种创建两个<code>app_process</code>进程的情形。</p>

<p>以 <code>/system/core/rootdir/init.zygote32.rc</code> 为例：
<code>
    service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server
    class main
    socket zygote stream 660 root system
    onrestart write /sys/android_power/request_state wake
    onrestart write /sys/power/state on
    onrestart restart media
    onrestart restart netd
</code></p>

<p>第一行创建了名为 <code>zygote</code> 的进程，这个进程是通过 <code>app_process</code> 的 <code>main</code> 启动并以<code>-Xzygote /system/bin &ndash;zygote &ndash;start-system-server</code>作为<code>main</code>的入口参数。</p>

<p><code>app_process</code> 对应代码为 <code>framework/base/cmds/app_process/app_main.cpp</code>。在这个文件的 <code>main</code> 函数中：</p>

<pre><code class="java">AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv));

    if (zygote) {
        runtime.start("com.android.internal.os.ZygoteInit", args);
    } else if (className) {
        runtime.start("com.android.internal.os.RuntimeInit", args);
    }
</code></pre>

<p>根据入口参数，我们知道 <code>zygote</code> 为<code>true</code>，<code>args</code>参数中包含了<code>&ldquo;start-system-server&rdquo;</code>。</p>

<p><code>AppRuntime</code> 继承自 <code>AndroidRuntime</code>，因此下一步就执行到 <code>AndroidRuntime</code> 的 <code>start</code> 函数。</p>

<pre><code class="java">void AndroidRuntime::start(const char* className, const Vector&lt;String8&gt;&amp; options)
{
    /* start the virtual machine */ // 创建虚拟机
    JniInvocation jni_invocation;
    jni_invocation.Init(NULL);
    JNIEnv* env;
    if (startVm(&amp;mJavaVM, &amp;env) != 0) {
        return;
    }
    onVmCreated(env);

    ...
    //调用className对应类的静态main()函数
    char* slashClassName = toSlashClassName(className);
    jclass startClass = env-&gt;FindClass(slashClassName);
    jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, "main",
    env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);
    ...
}
</code></pre>

<p><code>start</code>函数主要做两件事：创建虚拟机和调用传入类名对应类的 <code>main</code> 函数。因此下一步就执行到 <code>com.android.internal.os.ZygoteInit</code> 的 <code>main</code> 函数。
```
    public static void main(String argv[]) {
        try {
            boolean startSystemServer = false;
            String socketName = &ldquo;zygote&rdquo;;
            for (int i = 1; i &lt; argv.length; i++) {
                if (&ldquo;start-system-server&rdquo;.equals(argv[i])) {
                    startSystemServer = true;
                }
                &hellip;
            }</p>

<pre><code>        registerZygoteSocket(socketName);
        ...
        preload();
        ...

        if (startSystemServer) {
            startSystemServer(abiList, socketName);
        }

        Log.i(TAG, "Accepting command socket connections");
        runSelectLoop(abiList);

        closeServerSocket();
    } catch (MethodAndArgsCaller caller) {
        caller.run();
    } catch (RuntimeException ex) {
        Log.e(TAG, "Zygote died with exception", ex);
        closeServerSocket();
        throw ex;
    }
}
</code></pre>

<pre><code>
它主要做了三件事情:
1. 调用 &lt;code&gt;registerZygoteSocket&lt;/code&gt; 函数创建了一个 &lt;code&gt;socket&lt;/code&gt; 接口，用来和 &lt;code&gt;ActivityManagerService&lt;/code&gt; 通讯；
2. 调用 &lt;code&gt;startSystemServer&lt;/code&gt; 函数来启动 &lt;code&gt;SystemServer&lt;/code&gt;;
3. 调用 &lt;code&gt;runSelectLoop&lt;/code&gt; 函数进入一个无限循环在前面创建的 &lt;code&gt;socket&lt;/code&gt; 接口上等待 &lt;code&gt;ActivityManagerService&lt;/code&gt; 请求创建新的应用程序进程。

这里要留意 &lt;code&gt;catch (MethodAndArgsCaller caller)&lt;/code&gt; 这一行，&lt;code&gt;android&lt;/code&gt; 在这里通过抛出一个异常来处理正常的业务逻辑。

### 创建 zygote socket
</code></pre>

<pre><code>static final String ANDROID_SOCKET_PREFIX = "ANDROID_SOCKET_";

private static void registerZygoteSocket(String socketName) {
    if (sServerSocket == null) {
        int fileDesc;
        final String fullSocketName = ANDROID_SOCKET_PREFIX + socketName;
        try {
            String env = System.getenv(fullSocketName);
            fileDesc = Integer.parseInt(env);
        } catch (RuntimeException ex) {
            throw new RuntimeException(fullSocketName + " unset or invalid", ex);
        }

        try {
            sServerSocket = new LocalServerSocket(
                    createFileDescriptor(fileDesc));
        } catch (IOException ex) {
            throw new RuntimeException(
                    "Error binding to local socket '" + fileDesc + "'", ex);
        }
    }
}
</code></pre>

<pre><code>在这里根据传入参数&lt;code&gt;"zygote"&lt;/code&gt;拼成名为 &lt;code&gt;fullSocketName&lt;/code&gt; 的&lt;code&gt;key&lt;/code&gt;，该 &lt;code&gt;key&lt;/code&gt; 的值为：&lt;code&gt;ANDROID_SOCKET_zygote&lt;/code&gt;，然后查找它对应的环境变量值，解析该值得到文件描述符号，再根据该文件描述符创建 &lt;code&gt;socket&lt;/code&gt;。那么这个文件描述符是什么地方创建并写到环境变量里去的呢？还记得前面 &lt;code&gt;init.zygote32.rc&lt;/code&gt; 的第二行么？
</code></pre>

<pre><code>socket zygote stream 660 root system
</code></pre>

<pre><code>
系统启动脚本文件 &lt;code&gt;init.rc&lt;/code&gt; 是由 &lt;code&gt;init&lt;/code&gt; 进程来解释执行的，而 &lt;code&gt;init&lt;/code&gt; 进程的源代码位于 &lt;code&gt;system/core/init&lt;/code&gt; 目录中，在 &lt;code&gt;init.c&lt;/code&gt; 文件中，是由 &lt;code&gt;service_start&lt;/code&gt; 函数来解释 &lt;code&gt;init.zygote32.rc&lt;/code&gt; 文件中的 &lt;code&gt;service&lt;/code&gt; 命令的：
</code></pre>

<pre><code>void service_start(struct service *svc, const char *dynamic_args)
{
    ...
    pid = fork();

    if (pid == 0) {
        struct socketinfo *si;
        ...

        for (si = svc-&gt;sockets; si; si = si-&gt;next) {
            int socket_type = (
                    !strcmp(si-&gt;type, "stream") ? SOCK_STREAM :
                        (!strcmp(si-&gt;type, "dgram") ? SOCK_DGRAM : SOCK_SEQPACKET));
            int s = create_socket(si-&gt;name, socket_type,
                                  si-&gt;perm, si-&gt;uid, si-&gt;gid, si-&gt;socketcon ?: scon);
            if (s &gt;= 0) {
                publish_socket(si-&gt;name, s);
            }
        }
        ...
    }
    ...
}
</code></pre>

<pre><code>
每一个 service 命令都会促使 init 进程调用 fork 函数来创建一个新的进程，在新的进程里面，会分析里面的 socket 选项，对于每一个 socket 选项，都会通过 &lt;code&gt;create_socket&lt;/code&gt; 函数来在 &lt;code&gt;/dev/socket&lt;/code&gt; 目录下创建一个文件，在 zygote 进程中 socket 选项为&lt;code&gt;socket zygote stream 660 root system&lt;/code&gt;，因此这个文件便是 zygote了，然后得到的文件描述符通过 &lt;code&gt;publish_socket&lt;/code&gt; 函数写入到环境变量中去：
</code></pre>

<pre><code>static void publish_socket(const char *name, int fd)
{
    char key[64] = ANDROID_SOCKET_ENV_PREFIX;
    char val[64];

    strlcpy(key + sizeof(ANDROID_SOCKET_ENV_PREFIX) - 1,
            name,
            sizeof(key) - sizeof(ANDROID_SOCKET_ENV_PREFIX));
    snprintf(val, sizeof(val), "%d", fd);
    add_environment(key, val);

    /* make sure we don't close-on-exec */
    fcntl(fd, F_SETFD, 0);
}
</code></pre>

<pre><code>
这里传进来的参数name值为"zygote"，而 &lt;code&gt;ANDROID_SOCKET_ENV_PREFIX&lt;/code&gt; 在 &lt;code&gt;system/core/include/cutils/sockets.h&lt;/code&gt; 定义为：
</code></pre>

<h1>define ANDROID_SOCKET_ENV_PREFIX   &ldquo;ANDROID_SOCKET_&rdquo;</h1>

<h1>define ANDROID_SOCKET_DIR          &ldquo;/dev/socket&rdquo;</h1>

<pre><code>
因此，这里就把上面得到的文件描述符写入到以 &lt;code&gt;ANDROID_SOCKET_zygote&lt;/code&gt; 为 key 值的环境变量中。又因为上面的 &lt;code&gt;ZygoteInit.registerZygoteSocket&lt;/code&gt; 函数与这里创建 socket 文件的 create_socket 函数是运行在同一个进程中，因此，上面的 &lt;code&gt;ZygoteInit.registerZygoteSocket&lt;/code&gt; 函数可以直接使用这个文件描述符来创建一个 Java 层的 LocalServerSocket 对象。如果其它进程也需要打开这个 &lt;code&gt;/dev/socket/zygote&lt;/code&gt; 文件来和 zygote 进程进行通信，那就必须要通过文件名来连接这个 LocalServerSocket了。也就是说创建 zygote socket 之后，ActivityManagerService 就能够通过该 socket 与 zygote 进程通信从而 fork 创建新进程，android 中的所有应用进程都是通过这种方式 fork zygote 进程创建的。在 ActivityManagerService中 的 &lt;code&gt;startProcessLocked&lt;/code&gt; 中调用了 &lt;code&gt;Process.start()&lt;/code&gt; 方法，进而调用 &lt;code&gt;Process.startViaZygote&lt;/code&gt; 和 &lt;code&gt;Process.openZygoteSocketIfNeeded&lt;/code&gt;。

### 启动 SystemServer
socket 创建完成之后，紧接着就通过 &lt;code&gt;startSystemServer&lt;/code&gt; 函数来启动 &lt;code&gt;SystemServer&lt;/code&gt; 进程。
</code></pre>

<pre><code>private static boolean startSystemServer(String abiList, String socketName)
{
    long capabilities = posixCapabilitiesAsBits(
        OsConstants.CAP_BLOCK_SUSPEND,
        OsConstants.CAP_KILL,
        OsConstants.CAP_NET_ADMIN,
        OsConstants.CAP_NET_BIND_SERVICE,
        OsConstants.CAP_NET_BROADCAST,
        OsConstants.CAP_NET_RAW,
        OsConstants.CAP_SYS_MODULE,
        OsConstants.CAP_SYS_NICE,
        OsConstants.CAP_SYS_RESOURCE,
        OsConstants.CAP_SYS_TIME,
        OsConstants.CAP_SYS_TTY_CONFIG
    );
    /* Hardcoded command line to start the system server */
    String args[] = {
        "--setuid=1000",
        "--setgid=1000",
        "--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1032,3001,3002,3003,3006,3007",
        "--capabilities=" + capabilities + "," + capabilities,
        "--runtime-init",
        "--nice-name=system_server",
        "com.android.server.SystemServer",
    };
    ZygoteConnection.Arguments parsedArgs = null;

    int pid;

    try {
        parsedArgs = new ZygoteConnection.Arguments(args);
        ...

        /* Request to fork the system server process */
        pid = Zygote.forkSystemServer(
                parsedArgs.uid, parsedArgs.gid,
                parsedArgs.gids,
                parsedArgs.debugFlags,
                null,
                parsedArgs.permittedCapabilities,
                parsedArgs.effectiveCapabilities);
    } catch (IllegalArgumentException ex) {
        throw new RuntimeException(ex);
    }

    /* For child process */
    if (pid == 0) {
        if (hasSecondZygote(abiList)) {
            waitForSecondaryZygote(socketName);
        }

        handleSystemServerProcess(parsedArgs);
    }

    return true;
}
</code></pre>

<pre><code>
这里我们可以从参数推测出：创建名为&lt;code&gt;“system_server"&lt;/code&gt;的进程，其入口是： &lt;code&gt;com.android.server.SystemServer&lt;/code&gt; 的 &lt;code&gt;main&lt;/code&gt; 函数。&lt;code&gt;zygote&lt;/code&gt; 进程通过 &lt;code&gt;Zygote.forkSystemServer&lt;/code&gt; 函数来创建一个新的进程来启动 &lt;code&gt;SystemServer&lt;/code&gt; 组件，返回值 &lt;code&gt;pid&lt;/code&gt; 等 0 的地方就是新的进程要执行的路径，即新创建的进程会执行 &lt;code&gt;handleSystemServerProcess&lt;/code&gt; 函数。&lt;code&gt;hasSecondZygote&lt;/code&gt; 是针对 &lt;code&gt;init.zygote64_32.rc&lt;/code&gt;， &lt;code&gt;init.zygote32_64.rc&lt;/code&gt; 这两者情况的，在这里跳过不谈。接下来来看 &lt;code&gt;handleSystemServerProcess&lt;/code&gt;：
</code></pre>

<pre><code>/**
 * Finish remaining work for the newly forked system server process.
 */
private static void handleSystemServerProcess(
        ZygoteConnection.Arguments parsedArgs)
        throws ZygoteInit.MethodAndArgsCaller
{
    closeServerSocket();

    // set umask to 0077 so new files and directories will default to owner-only permissions.
    Os.umask(S_IRWXG | S_IRWXO);

    if (parsedArgs.niceName != null) {
        Process.setArgV0(parsedArgs.niceName);
    }

    final String systemServerClasspath = Os.getenv("SYSTEMSERVERCLASSPATH");

    ClassLoader cl = null;
    if (systemServerClasspath != null) {
        cl = new PathClassLoader(systemServerClasspath, ClassLoader.getSystemClassLoader());
        Thread.currentThread().setContextClassLoader(cl);
    }

    /*
     * Pass the remaining arguments to SystemServer.
     */
    RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);

    /* should never reach here */
}
</code></pre>

<pre><code>
&lt;code&gt;handleSystemServerProcess&lt;/code&gt; 会抛出 &lt;code&gt;MethodAndArgsCaller&lt;/code&gt; 异常，前面提到这个异常其实是处理正常业务逻辑的，相当于一个回调。由于由 &lt;code&gt;zygote&lt;/code&gt; 进程创建的子进程会继承 &lt;code&gt;zygote&lt;/code&gt; 进程在前面创建的 &lt;code&gt;socket&lt;/code&gt; 文件描述符，而这里的子进程又不会用到它，因此，这里就调用 &lt;code&gt;closeServerSocket&lt;/code&gt; 函数来关闭它。&lt;code&gt;SYSTEMSERVERCLASSPATH&lt;/code&gt; 是包含 &lt;code&gt;/system/framework/framework.jar&lt;/code&gt; 的环境变量，它定义在 &lt;code&gt;system/core/rootdir/init.environ.rc.in&lt;/code&gt; 中：
</code></pre>

<pre><code>on init
    export PATH /sbin:/vendor/bin:/system/sbin:/system/bin:/system/xbin
    export ANDROID_BOOTLOGO 1
    export ANDROID_ROOT /system
    export SYSTEMSERVERCLASSPATH %SYSTEMSERVERCLASSPATH%
    export LD_PRELOAD libsigchain.so
</code></pre>

<pre><code>
&lt;code&gt;handleSystemServerProcess&lt;/code&gt; 函数接着调用 &lt;code&gt;RuntimeInit.zygoteInit&lt;/code&gt; 函数来进一步执行启动 &lt;code&gt;SystemServer&lt;/code&gt; 组件的操作。
</code></pre>

<pre><code>public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)
        throws ZygoteInit.MethodAndArgsCaller {

    commonInit();
    nativeZygoteInit();

    applicationInit(targetSdkVersion, argv, classLoader);
}
</code></pre>

<pre><code>
&lt;code&gt;commonInit&lt;/code&gt; 设置线程未处理异常 &lt;code&gt;handler&lt;/code&gt;，时区等，&lt;code&gt;JNI&lt;/code&gt; 方法 &lt;code&gt;nativeZygoteInit&lt;/code&gt; 实现在 &lt;code&gt;frameworks/base/core/jni/AndroidRuntime.cpp&lt;/code&gt; 中：
</code></pre>

<p>static AndroidRuntime* gCurRuntime = NULL;</p>

<p>static void com_android_internal_os_RuntimeInit_nativeZygoteInit(JNIEnv* env, jobject clazz)
{
    gCurRuntime->onZygoteInit();
}
```</p>

<p><code>AndroidRuntime</code> 是个带虚函数的基类，真正的实现是在 <code>app_main.cpp</code> 中的 <code>AppRuntime</code>:
```cpp
class AppRuntime : public AndroidRuntime
{
    virtual void onStarted()
    {
        sp<ProcessState> proc = ProcessState::self();
        ALOGV(&ldquo;App process: starting thread pool.\n&rdquo;);
        proc->startThreadPool();</p>

<pre><code>    AndroidRuntime* ar = AndroidRuntime::getRuntime();
    ar-&gt;callMain(mClassName, mClass, mArgs);

    IPCThreadState::self()-&gt;stopProcess();
}

virtual void onZygoteInit()
{
    // Re-enable tracing now that we're no longer in Zygote.
    atrace_set_tracing_enabled(true);

    sp&lt;ProcessState&gt; proc = ProcessState::self();
    ALOGV("App process: starting thread pool.\n");
    proc-&gt;startThreadPool();
}

virtual void onExit(int code)
{
    if (mClassName.isEmpty()) {
        // if zygote
        IPCThreadState::self()-&gt;stopProcess();
    }

    AndroidRuntime::onExit(code);
}
</code></pre>

<p>};
```</p>

<p>通过执行 <code>AppRuntime::onZygoteInit</code> 函数，这个进程的 <code>Binder</code> 进程间通信机制基础设施就准备好了，参考代码 <code>frameworks/native/libs/binder/ProcessState.cpp</code>。</p>

<p>接下来，看 applicationInit ：
```java
    private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)
            throws ZygoteInit.MethodAndArgsCaller {</p>

<pre><code>    final Arguments args;
    try {
        args = new Arguments(argv);
    } catch (IllegalArgumentException ex) {
        Slog.e(TAG, ex.getMessage());
        // let the process exit
        return;
    }

    // Remaining arguments are passed to the start class's static main
    invokeStaticMain(args.startClass, args.startArgs, classLoader);
}
</code></pre>

<pre><code>
&lt;code&gt;applicationInit&lt;/code&gt; 仅仅是转调 &lt;code&gt;invokeStaticMain&lt;/code&gt;：
</code></pre>

<pre><code>private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader)
        throws ZygoteInit.MethodAndArgsCaller
{
    Class cl;
    cl = Class.forName(className, true, classLoader);
    Method m;
    m = cl.getMethod("main", new Class[] { String[].class });


    /*
     * This throw gets caught in ZygoteInit.main(), which responds
     * by invoking the exception's run() method. This arrangement
     * clears up all the stack frames that were required in setting
     * up the process.
     */
    throw new ZygoteInit.MethodAndArgsCaller(m, argv);
}
</code></pre>

<pre><code>
&lt;code&gt;invokeStaticMain&lt;/code&gt; 也很简单，通过反射找到参数 &lt;code&gt;className&lt;/code&gt; 对应的类的静态 &lt;code&gt;main&lt;/code&gt; 方法，然后将该方法与参数生成 &lt;code&gt;ZygoteInit.MethodAndArgsCaller&lt;/code&gt; 对象当做异常抛出，这个异常对象在 &lt;code&gt;ZygoteInit&lt;/code&gt; 的 &lt;code&gt;main&lt;/code&gt; 函数被捕获并执行该对象的 &lt;code&gt;run&lt;/code&gt; 方法。
</code></pre>

<pre><code>/**
 * Helper exception class which holds a method and arguments and
 * can call them. This is used as part of a trampoline to get rid of
 * the initial process setup stack frames.
 */
public static class MethodAndArgsCaller extends Exception
        implements Runnable {

    public void run() {
        ...
        mMethod.invoke(null, new Object[] { mArgs });
        ...
    }
}
</code></pre>

<pre><code>
这么复杂的跳转，其实就做了一件简单的事情：根据 &lt;code&gt;className &lt;/code&gt;反射调用该类的静态 &lt;code&gt;main&lt;/code&gt; 方法。这个类名是 &lt;code&gt;ZygoteInit.startSystemServer&lt;/code&gt; 方法中写死的 &lt;code&gt;com.android.server.SystemServer&lt;/code&gt;。 从而进入 &lt;code&gt;SystemServer&lt;/code&gt; 类的 &lt;code&gt;main()&lt;/code&gt;方法。

### 执行 ZygoteInit.runSelectLoop
在 &lt;code&gt;startSystemServer&lt;/code&gt; 函数中，创建 &lt;code&gt;system_server&lt;/code&gt; 进程之后，&lt;code&gt;pid&lt;/code&gt; 等于 0 时在该新进程中执行 &lt;code&gt;SystemServer.main&lt;/code&gt;，否则回到 &lt;code&gt;zygote&lt;/code&gt; 进程进行执行 &lt;code&gt;ZygoteInit.runSelectLoop&lt;/code&gt;：
</code></pre>

<pre><code>private static void runSelectLoop(String abiList) throws MethodAndArgsCaller {
    ArrayList&lt;FileDescriptor&gt; fds = new ArrayList&lt;FileDescriptor&gt;();
    ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;ZygoteConnection&gt;();
    FileDescriptor[] fdArray = new FileDescriptor[4];

    fds.add(sServerSocket.getFileDescriptor());
    peers.add(null);

    int loopCount = GC_LOOP_COUNT;
    while (true) {
        int index;

        /*
         * Call gc() before we block in select().
         * It's work that has to be done anyway, and it's better
         * to avoid making every child do it.  It will also
         * madvise() any free memory as a side-effect.
         *
         * Don't call it every time, because walking the entire
         * heap is a lot of overhead to free a few hundred bytes.
         */
        if (loopCount &lt;= 0) {
            gc();
            loopCount = GC_LOOP_COUNT;
        } else {
            loopCount--;
        }

        try {
            fdArray = fds.toArray(fdArray);
            index = selectReadable(fdArray);
        } catch (IOException ex) {
            throw new RuntimeException("Error in select()", ex);
        }

        if (index &lt; 0) {
            throw new RuntimeException("Error in select()");
        } else if (index == 0) {
            ZygoteConnection newPeer = acceptCommandPeer(abiList);
            peers.add(newPeer);
            fds.add(newPeer.getFileDescriptor());
        } else {
            boolean done;
            done = peers.get(index).runOnce();

            if (done) {
                peers.remove(index);
                fds.remove(index);
            }
        }
    }
}
</code></pre>

<pre><code>
&lt;code&gt;runSelectLoop&lt;/code&gt; 函数的逻辑比较简单，主要有两点：
1、 处理客户端的连接和请求。前面创建的 &lt;code&gt;LocalServerSocket&lt;/code&gt; 对象保存 &lt;code&gt;sServerSocket&lt;/code&gt;，这个 &lt;code&gt;socket&lt;/code&gt; 通过 &lt;code&gt;selectReadable&lt;/code&gt; 等待 &lt;code&gt;ActivityManagerService&lt;/code&gt;(简写 &lt;code&gt;AMS&lt;/code&gt;) 与之通信。&lt;code&gt;selectReadable&lt;/code&gt;是一个&lt;code&gt;native&lt;/code&gt;函数，内部调用&lt;code&gt;select&lt;/code&gt;等待 &lt;code&gt;AMS&lt;/code&gt; 连接，&lt;code&gt;AMS&lt;/code&gt; 连接上之后就会返回: 返回值 &lt; 0：内部发生错误；返回值 = 0：第一次连接到服务端 ；返回值 &gt; 0：与服务端已经建立连接，并开始发送数据。每一个链接在 &lt;code&gt;zygote&lt;/code&gt; 进程中使用 &lt;code&gt;ZygoteConnection&lt;/code&gt; 对象表示。

2、 客户端的请求由 &lt;code&gt;ZygoteConnection.runOnce&lt;/code&gt; 来处理，这个方法也抛出 &lt;code&gt;MethodAndArgsCaller&lt;/code&gt; 异常，从而进入 &lt;code&gt;MethodAndArgsCaller.run&lt;/code&gt; 中调用根据客户请求数据反射出的类的 &lt;code&gt;main&lt;/code&gt; 方法。
</code></pre>

<pre><code>private String[] readArgumentList()
{
    int argc;

    try {
        String s = mSocketReader.readLine();

        if (s == null) {
            // EOF reached.
            return null;
        }
        argc = Integer.parseInt(s);
    } catch (NumberFormatException ex) {
        Log.e(TAG, "invalid Zygote wire format: non-int at argc");
        throw new IOException("invalid wire format");
    }

    String[] result = new String[argc];
    for (int i = 0; i &lt; argc; i++) {
        result[i] = mSocketReader.readLine();
        if (result[i] == null) {
            // We got an unexpected EOF.
            throw new IOException("truncated request");
        }
    }

    return result;
}

boolean runOnce() throws ZygoteInit.MethodAndArgsCaller {
    String args[];
    Arguments parsedArgs = null;
    args = readArgumentList();
    parsedArgs = new Arguments(args);

    ...
    pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,
            parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,
            parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,
            parsedArgs.appDataDir);
    ...
}
</code></pre>

<pre><code>
## SystemServer 启动过程
在前面启动 SystemServer一节讲到，通过反射调用类 &lt;code&gt;com.android.server.SystemServer&lt;/code&gt; main() 函数，从而开始执行 SystemServer 的初始化流程。

SystemServer.main()
</code></pre>

<pre><code>/**
 * The main entry point from zygote.
 */
public static void main(String[] args) {
    new SystemServer().run();
}
</code></pre>

<pre><code>
main 函数创建一个 SystemServer 对象，调用其 run() 方法。
</code></pre>

<pre><code>private void run() {
    // If a device's clock is before 1970 (before 0), a lot of
    // APIs crash dealing with negative numbers, notably
    // java.io.File#setLastModified, so instead we fake it and
    // hope that time from cell towers or NTP fixes it shortly.
    if (System.currentTimeMillis() &lt; EARLIEST_SUPPORTED_TIME) {
        Slog.w(TAG, "System clock is before 1970; setting to 1970.");
        SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME);
    } // 检测时间设置

    // Here we go!
    Slog.i(TAG, "Entered the Android system server!");
    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN, SystemClock.uptimeMillis());

    // In case the runtime switched since last boot (such as when
    // the old runtime was removed in an OTA), set the system
    // property so that it is in sync. We can't do this in
    // libnativehelper's JniInvocation::Init code where we already
    // had to fallback to a different runtime because it is
    // running as root and we need to be the system user to set
    // the property. http://b/11463182
    SystemProperties.set("persist.sys.dalvik.vm.lib.2", VMRuntime.getRuntime().vmLibrary());

    // Enable the sampling profiler.
    if (SamplingProfilerIntegration.isEnabled()) {
        SamplingProfilerIntegration.start();
        mProfilerSnapshotTimer = new Timer();
        mProfilerSnapshotTimer.schedule(new TimerTask() {
            @Override
            public void run() {
                SamplingProfilerIntegration.writeSnapshot("system_server", null);
            }
        }, SNAPSHOT_INTERVAL, SNAPSHOT_INTERVAL);
    } // 启动性能分析采样

    // Mmmmmm... more memory!
    VMRuntime.getRuntime().clearGrowthLimit();

    // The system server has to run all of the time, so it needs to be
    // as efficient as possible with its memory usage.
    VMRuntime.getRuntime().setTargetHeapUtilization(0.8f);

    // Some devices rely on runtime fingerprint generation, so make sure
    // we've defined it before booting further.
    Build.ensureFingerprintProperty();

    // Within the system server, it is an error to access Environment paths without
    // explicitly specifying a user.
    Environment.setUserRequired(true);

    // Ensure binder calls into the system always run at foreground priority.
    BinderInternal.disableBackgroundScheduling(true);

    // Prepare the main looper thread (this thread).
    android.os.Process.setThreadPriority(
            android.os.Process.THREAD_PRIORITY_FOREGROUND);
    android.os.Process.setCanSelfBackground(false);
    Looper.prepareMainLooper(); // 准备主线程循环

    // Initialize native services.
    System.loadLibrary("android_servers");
    nativeInit();

    // Check whether we failed to shut down last time we tried.
    // This call may not return.
    performPendingShutdown();

    // Initialize the system context.
    createSystemContext();

    // Create the system service manager.
    mSystemServiceManager = new SystemServiceManager(mSystemContext);
    LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);

    // Start services.  // 启动服务
    try {
        startBootstrapServices();
        startCoreServices();
        startOtherServices();
    } catch (Throwable ex) {
        Slog.e("System", "******************************************");
        Slog.e("System", "************ Failure starting system services", ex);
        throw ex;
    }

    // For debug builds, log event loop stalls to dropbox for analysis.
    if (StrictMode.conditionallyEnableDebugLogging()) {
        Slog.i(TAG, "Enabled StrictMode for system server main thread.");
    }

    // Loop forever.
    Looper.loop();  // 启动线程循环，等待消息处理
    throw new RuntimeException("Main thread loop unexpectedly exited");
}
</code></pre>

<pre><code>
在这个 run 方法中，主要完成三件事情，创建 system context 和 system service manager，启动一些系统服务，进入主线程消息循环。

## Zygote 的 fork 本地方法分析
接下来我们仔细分析 &lt;code&gt;Zygote.forkSystemServer&lt;/code&gt; 与 &lt;code&gt;Zygote.forkAndSpecialize&lt;/code&gt; 两个方法。

### forkSystemServer
</code></pre>

<pre><code>private static final ZygoteHooks VM_HOOKS = new ZygoteHooks();

public static int forkSystemServer(int uid, int gid, int[] gids, int debugFlags,
        int[][] rlimits, long permittedCapabilities, long effectiveCapabilities) {
    VM_HOOKS.preFork();
    int pid = nativeForkSystemServer(
            uid, gid, gids, debugFlags, rlimits, permittedCapabilities, effectiveCapabilities);
    VM_HOOKS.postForkCommon();
    return pid;
}
</code></pre>

<pre><code>
在调用 &lt;code&gt;nativeForkSystemServer&lt;/code&gt; 创建 &lt;code&gt;system_server&lt;/code&gt; 进程之前与之后，都会调用 ZygoteHooks 进行一些前置与后置处理。

#### ZygoteHooks.preFork
前置处理 &lt;code&gt;ZygoteHooks.preFork&lt;/code&gt;：
</code></pre>

<pre><code>public void preFork() {
    Daemons.stop();
    waitUntilAllThreadsStopped();
    token = nativePreFork();
}
</code></pre>

<pre><code>
&lt;code&gt;Daemons.stop()&lt;/code&gt;; 停止虚拟机中一些守护线程操作：如引用队列、终接器、GC等
</code></pre>

<pre><code>public static void stop() {
    ReferenceQueueDaemon.INSTANCE.stop();
    FinalizerDaemon.INSTANCE.stop();
    FinalizerWatchdogDaemon.INSTANCE.stop();
    HeapTrimmerDaemon.INSTANCE.stop();
    GCDaemon.INSTANCE.stop();
}
</code></pre>

<pre><code>
&lt;code&gt;waitUntilAllThreadsStopped&lt;/code&gt; 保证被 &lt;code&gt;fork&lt;/code&gt; 的进程是单线程，这样可以确保通过 &lt;code&gt;copyonwrite fork&lt;/code&gt; 出来的进程也是单线程，从而节省资源。与前面提到的在新建 &lt;code&gt;system_server&lt;/code&gt; 进程中调用 &lt;code&gt;closeServerSocket&lt;/code&gt; 关闭 &lt;code&gt;sockect&lt;/code&gt; 有异曲同工之妙。
</code></pre>

<pre><code>/**
 * We must not fork until we're single-threaded again. Wait until /proc shows we're
 * down to just one thread.
 */
private static void waitUntilAllThreadsStopped() {
    File tasks = new File("/proc/self/task");
    while (tasks.list().length &gt; 1) {
        try {
            // Experimentally, booting and playing about with a stingray, I never saw us
            // go round this loop more than once with a 10ms sleep.
            Thread.sleep(10);
        } catch (InterruptedException ignored) {
        }
    }
}
</code></pre>

<pre><code>
本地方法 &lt;code&gt;nativePreFork&lt;/code&gt; 实现在 &lt;code&gt;art/runtime/native/dalvik_system_ZygoteHooks.cc&lt;/code&gt; 中。
</code></pre>

<pre><code>static jlong ZygoteHooks_nativePreFork(JNIEnv* env, jclass) {
  Runtime* runtime = Runtime::Current();
  CHECK(runtime-&gt;IsZygote()) &lt;&lt; "runtime instance not started with -Xzygote";

  runtime-&gt;PreZygoteFork();

  // Grab thread before fork potentially makes Thread::pthread_key_self_ unusable.
  Thread* self = Thread::Current();
  return reinterpret_cast&lt;jlong&gt;(self);
}
</code></pre>

<pre><code>
&lt;code&gt;ZygoteHooks_nativePreFork&lt;/code&gt; 通过调用 &lt;code&gt;Runtime::PreZygoteFork&lt;/code&gt; 来完成 &lt;code&gt;gc&lt;/code&gt; 堆的一些初始化，这部分代码在 &lt;code&gt;art/runtime/runtime.cc&lt;/code&gt; 中：
</code></pre>

<pre><code>heap_ = new gc::Heap(...);
void Runtime::PreZygoteFork() {
    heap_-&gt;PreZygoteFork();
}
</code></pre>

<pre><code>
#### 创建 system_server 进程：
&lt;code&gt;nativeForkSystemServer&lt;/code&gt; 实现在 &lt;code&gt;framework/base/core/jni/com_android_internal_os_Zygote.cpp&lt;/code&gt; 中：
</code></pre>

<pre><code>static jint com_android_internal_os_Zygote_nativeForkSystemServer(
        JNIEnv* env, jclass, uid_t uid, gid_t gid, jintArray gids,
        jint debug_flags, jobjectArray rlimits, jlong permittedCapabilities,
        jlong effectiveCapabilities) {
    pid_t pid = ForkAndSpecializeCommon(env, uid, gid, gids,
                    debug_flags, rlimits,
                    permittedCapabilities, effectiveCapabilities,
                    MOUNT_EXTERNAL_NONE, NULL, NULL, true, NULL,
                    NULL, NULL);
    if (pid &gt; 0) {
        // The zygote process checks whether the child process has died or not.
        ALOGI("System server process %d has been created", pid);
        gSystemServerPid = pid;
        // There is a slight window that the system server process has crashed
        // but it went unnoticed because we haven't published its pid yet. So
        // we recheck here just to make sure that all is well.
        int status;
        if (waitpid(pid, &amp;status, WNOHANG) == pid) {
            ALOGE("System server process %d has died. Restarting Zygote!", pid);
            RuntimeAbort(env);
        }
    }
    return pid;
}
</code></pre>

<pre><code>
它转调 &lt;code&gt;ForkAndSpecializeCommon&lt;/code&gt; 来创建新进程，并确保 &lt;code&gt;system_server&lt;/code&gt; 创建成功，若不成功便成仁：重启 &lt;code&gt;zygote&lt;/code&gt;，因为没有 &lt;code&gt;system_server&lt;/code&gt; 就干不了什么事情。&lt;code&gt;ForkAndSpecializeCommon&lt;/code&gt; 实现如下：
</code></pre>

<pre><code>static const char kZygoteClassName[] = "com/android/internal/os/Zygote";
gZygoteClass = (jclass) env-&gt;NewGlobalRef(env-&gt;FindClass(kZygoteClassName));
gCallPostForkChildHooks = env-&gt;GetStaticMethodID(gZygoteClass, "callPostForkChildHooks",
                                       "(ILjava/lang/String;)V");

// Utility routine to fork zygote and specialize the child process.
static pid_t ForkAndSpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray javaGids,
                 jint debug_flags, jobjectArray javaRlimits,
                 jlong permittedCapabilities, jlong effectiveCapabilities,
                 jint mount_external,
                 jstring java_se_info, jstring java_se_name,
                 bool is_system_server, jintArray fdsToClose,
                 jstring instructionSet, jstring dataDir)
{
    SetSigChldHandler();

    pid_t pid = fork();

    if (pid == 0) {
        // The child process.
        ...
        rc = selinux_android_setcontext(uid, is_system_server, se_info_c_str, se_name_c_str);
        ...
        UnsetSigChldHandler();
        ...
        env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, debug_flags,
                      is_system_server ? NULL : instructionSet);
    }
    else if (pid &gt; 0) {
        // the parent process
    }

    return pid;
}
</code></pre>

<pre><code>
&lt;code&gt;ForkAndSpecializeCommon&lt;/code&gt; 首先设置子进程异常处理&lt;code&gt;handler&lt;/code&gt;，然后 &lt;/ode&gt;fork&lt;/code&gt; 新进程，在新进程中设置 &lt;code&gt;SELinux&lt;/code&gt;，并清除它的子进程异常处理 &lt;code&gt;handler&lt;/code&gt;，然后调用 &lt;code&gt;Zygote.callPostForkChildHooks&lt;/code&gt; 方法。
</code></pre>

<pre><code>private static void callPostForkChildHooks(int debugFlags, String instructionSet) {
    long startTime = SystemClock.elapsedRealtime();
    VM_HOOKS.postForkChild(debugFlags, instructionSet);
    checkTime(startTime, "Zygote.callPostForkChildHooks");
}
</code></pre>

<pre><code>
&lt;code&gt;callPostForkChildHooks&lt;/code&gt; 又转调 &lt;code&gt;ZygoteHooks.postForkChild&lt;/code&gt; :
</code></pre>

<pre><code>public void postForkChild(int debugFlags, String instructionSet) {
    nativePostForkChild(token, debugFlags, instructionSet);
}
</code></pre>

<pre><code>
本地方法 &lt;code&gt;nativePostForkChild&lt;/code&gt; 又进到 &lt;code&gt;dalvik_system_ZygoteHooks.cc&lt;/code&gt; 中：
</code></pre>

<pre><code>static void ZygoteHooks_nativePostForkChild(JNIEnv* env, jclass, jlong token, jint debug_flags,
                                        jstring instruction_set) {
    Thread* thread = reinterpret_cast&lt;Thread*&gt;(token);
    // Our system thread ID, etc, has changed so reset Thread state.
    thread-&gt;InitAfterFork();
    EnableDebugFeatures(debug_flags);

    if (instruction_set != nullptr) {
        ScopedUtfChars isa_string(env, instruction_set);
        InstructionSet isa = GetInstructionSetFromString(isa_string.c_str());
        Runtime::NativeBridgeAction action = Runtime::NativeBridgeAction::kUnload;
        if (isa != kNone &amp;&amp; isa != kRuntimeISA) {
            action = Runtime::NativeBridgeAction::kInitialize;
        }
        Runtime::Current()-&gt;DidForkFromZygote(env, action, isa_string.c_str());
    } else {
        Runtime::Current()-&gt;DidForkFromZygote(env, Runtime::NativeBridgeAction::kUnload, nullptr);
    }
}
</code></pre>

<pre><code>
&lt;code&gt;thread-&gt;InitAfterFork()&lt;/code&gt;; 实现在 &lt;code&gt;art/runtime/thread.cc&lt;/code&gt; 中，设置新进程主线程的线程&lt;code&gt;id&lt;/code&gt;： &lt;code&gt;tid&lt;/code&gt;。&lt;code&gt;DidForkFromZygote&lt;/code&gt; 实现在 &lt;code&gt;Runtime.cc&lt;/code&gt; 中：
</code></pre>

<pre><code>void Runtime::DidForkFromZygote(JNIEnv* env, NativeBridgeAction action, const char* isa) {
    is_zygote_ = false;

    switch (action) {
    case NativeBridgeAction::kUnload:
        UnloadNativeBridge();
        break;

    case NativeBridgeAction::kInitialize:
        InitializeNativeBridge(env, isa);
        break;
    }

    // Create the thread pool.
    heap_-&gt;CreateThreadPool();

    StartSignalCatcher();

    // Start the JDWP thread. If the command-line debugger flags specified "suspend=y",
    // this will pause the runtime, so we probably want this to come last.
    Dbg::StartJdwp();
}
</code></pre>

<pre><code>
首先根据 &lt;code&gt;action&lt;/code&gt; 参数来卸载或转载用于跨平台桥接用的库。然后启动 &lt;code&gt;gc&lt;/code&gt; 堆的线程池。&lt;code&gt;StartSignalCatcher&lt;/code&gt; 设置信号处理 &lt;code&gt;handler&lt;/code&gt;，其代码在 &lt;code&gt;signal_catcher.cc&lt;/code&gt; 中。

#### ZygoteHooks.postForkCommon
后置处理 &lt;code&gt;ZygoteHooks.postForkCommon&lt;/code&gt;：
</code></pre>

<pre><code>public void postForkCommon() {
    Daemons.start();
}
</code></pre>

<pre><code>
&lt;code&gt;postForkCommon&lt;/code&gt; 转调 &lt;code&gt;Daemons.start&lt;/code&gt;，以初始化虚拟机中引用队列、终接器以及 &lt;code&gt;gc&lt;/code&gt; 的守护线程。
</code></pre>

<pre><code>public static void start() {
    ReferenceQueueDaemon.INSTANCE.start();
    FinalizerDaemon.INSTANCE.start();
    FinalizerWatchdogDaemon.INSTANCE.start();
    HeapTrimmerDaemon.INSTANCE.start();
    GCDaemon.INSTANCE.start();
}
</code></pre>

<pre><code>
### forkAndSpecialize
&lt;code&gt;Zygote.forkAndSpecialize&lt;/code&gt; 方法
</code></pre>

<pre><code>public static int forkAndSpecialize(int uid, int gid, int[] gids, int debugFlags,
      int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose,
      String instructionSet, String appDataDir) {
    long startTime = SystemClock.elapsedRealtime();
    VM_HOOKS.preFork();
    checkTime(startTime, "Zygote.preFork");
    int pid = nativeForkAndSpecialize(
              uid, gid, gids, debugFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,
              instructionSet, appDataDir);
    checkTime(startTime, "Zygote.nativeForkAndSpecialize");
    VM_HOOKS.postForkCommon();
    checkTime(startTime, "Zygote.postForkCommon");
    return pid;
}
</code></pre>

<pre><code>
前置处理与后置处理与 &lt;code&gt;forkSystemServer&lt;/code&gt; 中一样的，这里就跳过不讲了。本地方法 &lt;code&gt;nativeForkAndSpecialize&lt;/code&gt; 实现在 &lt;code&gt;framework/base/core/jni/com_android_internal_os_Zygote.cpp&lt;/code&gt; 中：
</code></pre>

<p>static jint com_android_internal_os_Zygote_nativeForkAndSpecialize(
        JNIEnv* env, jclass, jint uid, jint gid, jintArray gids,
        jint debug_flags, jobjectArray rlimits,
        jint mount_external, jstring se_info, jstring se_name,
        jintArray fdsToClose, jstring instructionSet, jstring appDataDir) {
    // Grant CAP_WAKE_ALARM to the Bluetooth process.
    jlong capabilities = 0;
    if (uid == AID_BLUETOOTH) {
        capabilities |= (1LL &lt;&lt; CAP_WAKE_ALARM);
    }</p>

<pre><code>return ForkAndSpecializeCommon(env, uid, gid, gids, debug_flags,
        rlimits, capabilities, capabilities, mount_external, se_info,
        se_name, false, fdsToClose, instructionSet, appDataDir);
</code></pre>

<p>}
```</p>

<p>这个函数与 <code>com_android_internal_os_Zygote_nativeForkSystemServer</code> 非常类似，只不过少了一个确保子进程创建成功的步骤。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android框架学习资料]]></title>
    <link href="http://luozhaohui.github.io/blog/2015/04/02/study-android-fw/"/>
    <updated>2015-04-02T19:00:34+08:00</updated>
    <id>http://luozhaohui.github.io/blog/2015/04/02/study-android-fw</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>这两年在做一个与 Android 类似的系统（参考：<a href="http://blog.csdn.net/kesalin/article/details/10474007">招聘：有兴趣做一个与Android对等的操作系统么？</a>），因此有机会对 Android framework 进行系统地学习与研究。期间也阅读了一些不错的书籍与资料，特此分享在这里，或许对其他有兴趣研究 Android framework 的朋友有所帮助。</p>

<!--more-->


<h2>推荐资料</h2>

<h3><a href="http://book.douban.com/subject/11530748/">Android开发精要</a></h3>

<p>这一本是作为入门本，主要是从 app 开发者的角度来介绍 framework 中的各要素，从这个角度来理解框架中哪些部分直接和 App 开发相关，又起什么作用。要仔细研究 framework 内部机制，首先从外部特性入手，这样在横向层面对 framework 有一个整体的认识与把握。第3章至第6章是这本书的精华所在，重点介绍了 Android 的组件思想以及组件之间的交互媒介 Intent。</p>

<h3><a href="http://book.douban.com/subject/10570841/">Android框架揭秘</a></h3>

<p>对比过《深入理解Android》等书籍，还是觉得这本书讲得有体系，透彻，著者非常用心。尤其是对 C++/Java 两个层面的 framework，以及对 Client/Server 的交互过程讲得比较详细。</p>

<h3><a href="http://blog.csdn.net/universus/article/details/6211589/">Android Bander设计与实现 - 设计篇</a></h3>

<p>引用原文内容：</p>

<blockquote><p>这篇文章首先通过介绍 Binder 通信模型和 Binder 通信协议了解 Binder 的设计需求；然后分别阐述 Binder 在系统不同部分的表述方式和起的作用；最后还会解释 Binder 在数据接收端的设计考虑，包括线程池管理，内存映射和等待队列管理等。通过本文对 Binder 的详细介绍以及与其它 IPC 通信方式的对比，读者将对 Binder 的优势和使用 Binder 作为 Android 主要 IPC 方式的原因有深入了解。</p></blockquote>

<h3><a href="http://book.douban.com/subject/19986441/">Android系统源代码情景分析</a></h3>

<p>这是讲解 Android Binder 以及匿名共享内存最详细的书，没有之一。作者花了进200页的篇幅来透彻讲解 Binder，此外对各种组件的启动过程也介绍得相当详细，如 Activity、Service、Content Provider 等。</p>

<h3><a href="http://book.douban.com/subject/25921329/">深入理解Android内核设计思想</a></h3>

<p>从操作系统的基础知识入手，讲解进程线程、内存管理、Binder 机制、Surface、SurfaceFlinger、WindowManagerService、View 体系、音频系统、输入系统等在 Android framework 中的实现原理。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用Python编写博客导出工具]]></title>
    <link href="http://luozhaohui.github.io/blog/2014/10/12/export-blog-using-python-on-windows/"/>
    <updated>2014-10-12T08:35:02+08:00</updated>
    <id>http://luozhaohui.github.io/blog/2014/10/12/export-blog-using-python-on-windows</id>
    <content type="html"><![CDATA[<h3>写在前面的话</h3>

<p>我在 github 上用 octopress 搭建了<a href="http://kesalin.github.io/">个人博客</a>，octopress 使用Markdown语法编写博文。之前我在CSDN博客上也写过不少的技术博文，都说自己的孩子再丑也是个宝，所以就起了把CSDN博客里面的文章导出到个人博客上的念头。刚开始想找个工具把CSDN博客导出为xml或文本，然后再把xml或文本转换为Markdown博文。可惜搜了一下现有博客导出工具，大部分要收费才能将全部博文导出为xml格式，所以就只好发明轮子了：写个工具将全部博文导出为Markdown博文（也是txt格式的）。</p>

<p>我将详细介绍这个工具的编写过程，希望没有学习过编程的人也能够学会一些简单的Python语法来修改这个脚本工具，以满足他们将其他类型的博客导出为文本格式。这也是我第一次学习和使用Python，所以相信我，你一定也可以将自己的博客导出为想要的文本格式。</p>

<p>本文源代码在这里：<a href="https://github.com/luozhaohui/python/blob/master/exportCSDNBlogAsMarkdown.py">ExportCSDNBlog.py</a></p>

<!--more-->


<p>考虑到大部分非程序员使用Windows系统，下面将介绍在Windows下如何编写这个工具。</p>

<h3>下载工具</h3>

<p>在 Windows 下安装Python开发环境（Linux/Mac下用pip安装相应包即可，程序员自己解决咯）：</p>

<p><strong>Python 2.7.3</strong><br/>
请安装这个版本，更高版本的Python与一些库不兼容。<br/>
<a href="https://www.python.org/download/releases/2.7.3/">下载页面</a><br/>
下载完毕双击可执行文件进行安装，默认安装在C:\Python2.7。</p>

<p><strong>six</strong><br/>
<a href="https://pypi.python.org/pypi/six">下载页面</a>
下载完毕，解压到Python安装目录下，如C:\Python2.7\six-1.8.0目录下。</p>

<p><strong>BeautifulSoup 4.3.2</strong><br/>
<a href="http://www.crummy.com/software/BeautifulSoup/bs4/download/">下载页面</a>，
下载完毕，解压到Python安装目录下，如C:\Python2.7\BeautifulSoup目录下。</p>

<p><strong>html5lib</strong><br/>
<a href="https://pypi.python.org/pypi/html5lib">下载页面</a>
下载完毕，解压到Python安装目录下，如C:\Python2.7\html5lib-0.999目录下。</p>

<h3>安装工具</h3>

<p>Windows下启动命令行，依次进入如下目录，执行setup.py install进行安装：</p>

<pre><code>C:\Python2.7\six-1.8.0&gt;setup.py install  
C:\Python2.7\html5lib-0.999&gt;setup.py install  
C:\Python2.7\BeautifulSoup&gt;setup.py install  
</code></pre>

<h3>参考文档</h3>

<p><a href="https://docs.python.org/2/">Python 2.X文档</a><br/>
<a href="http://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html">BeautifulSoup文档</a><br/>
<a href="http://www.regexlab.com/zh/regref.htm">正则表达式文档</a><br/>
<a href="http://tool.oschina.net/regex">正则表达式在线测试</a></p>

<h3>用到的Python语法</h3>

<p>这个工具只用到了一些基本的Python语法，如果你没有Python基础，稍微了解一下如下博文是很有好处的。</p>

<ul>
<li>string: 字符串操作，参考<a href="http://www.cnblogs.com/sevenyuan/archive/2010/12/10/1902145.html">python: string的操作函数</a></li>
<li>list: 列表操作，参考<a href="http://www.cnblogs.com/zhengyuxin/articles/1938300.html">Python list 操作</a></li>
<li>dictionary: 字典操作，参考<a href="http://www.cnblogs.com/yangyongzhi/archive/2012/09/17/2688326.html">Python中dict详解</a></li>
<li>datetime: 日期时间，参考<a href="http://www.cnblogs.com/lhj588/archive/2012/04/23/2466653.html">python datetime处理时间</a></li>
</ul>


<p><br/></p>

<h3>编写博客导出工具</h3>

<h4>分析</h4>

<p>首先来分析这样一个工具的需求：</p>

<pre><code>导出所有CSDN博客文章为Markdown文本。
</code></pre>

<p>这个总需求其实可以分两步来做：</p>

<pre><code>* 获得CSDN博客文章
* 将文章转换为Markdown文本
</code></pre>

<p>针对第一步：如何获取博客文章呢？</p>

<p>打开任何一个CSDN博客，我们都可以看到下方的页面导航显示“XXX条数据 共XXX页 1 2 3 &hellip; 尾页”，我们从这个地方入手考虑。每个页面上都会显示属于该页的文章标题及文章链接，如果我们依次访问这些页面链接，就能从每个页面链接中找出属于该页面的文章标题及文章链接。这样所有的文章标题以及文章链接就都获取到了，有了这些文章链接，我们就能获取对应文章的html内容，然后通过解析这些html页面来生成相应Markdown文本了。</p>

<h4>实现</h4>

<p>从上面的分析可以看出，首先我们需要根据首页获取所有的页面链接，然后遍历每一个页面链接来获取文章链接。</p>

<ul>
<li>获取页面链接的代码：</li>
</ul>


<pre><code class="python 获取所有的页面的 url https://github.com/luozhaohui/python/blob/master/exportCSDNBlogAsMarkdown.py View Source">
def getHtml(url):
    try :
        if gUseCookie:
            opener = urllib2.build_opener()
            for k, v in gHeaders.items():
                opener.addheaders.append((k, v))
            response = opener.open(url)
            data = response.read().decode('utf-8')
        else:
            request = urllib2.Request(url, None, gHeaders)
            response = urllib2.urlopen(request)
            data = response.read().decode('utf-8')
    except urllib2.URLError, e :
        if hasattr(e, "code"):
            print "The server couldn't fulfill the request: " + url
            print "Error code: %s" % e.code
        elif hasattr(e, "reason"):
            print "We failed to reach a server. Please check your url: " + url + ", and read the Reason."
            print "Reason: %s" % e.reason
    return data

def getPageUrlList(url):
    page = getHtml(url)
    soup = BeautifulSoup(page)

    lastArticleHref = None
    pageListDocs = soup.find_all(id="papelist")
    for pageList in pageListDocs:
        hrefDocs = pageList.find_all("a")
        if len(hrefDocs) &gt; 0:
            lastArticleHrefDoc = hrefDocs[len(hrefDocs) - 1]
            lastArticleHref = lastArticleHrefDoc["href"].encode('UTF-8')

    if lastArticleHref == None:
        return []

    print " &gt; last page href:" + lastArticleHref
    lastPageIndex = lastArticleHref.rfind("/")
    lastPageNum = int(lastArticleHref[lastPageIndex+1:])
    urlInfo = "http://blog.csdn.net" + lastArticleHref[0:lastPageIndex]

    pageUrlList = []
    for x in xrange(1, lastPageNum + 1):
        pageUrl = urlInfo + "/" + str(x)
        pageUrlList.append(pageUrl)
        log(" &gt; page " + str(x) + ": " + pageUrl)

    log("total pages: " + str(len(pageUrlList)) + "\n")
    return pageUrlList
</code></pre>

<p>参数 url = &ldquo;<a href="http://blog.csdn.net/">http://blog.csdn.net/</a>&rdquo; + username，即你首页的网址。通过urllib2库打开这个url发起一个web请求，从response中获取返回的html页面内容保存到data中。你可以被注释的 print data 来查看到底返回了什么内容。</p>

<p>有了html页面内容，接下来就用BeautifulSoup来解析它。BeautifulSoup极大地减少了我们的工作量。我会详细在这里介绍它的使用，后面再次出现类似的解析就会从略了。soup.find_all(id=&ldquo;papelist&rdquo;) 将会查找html页面中所有id=&ldquo;papelist"的tag，然后返回包含这些tag的list。对应 CSDN 博文页面来说，只有一处地方：</p>

<p>``` html papelist html内容示例</p>

<div id="papelist" class="pagelist">
    <span> 236条数据  共12页</span>
    <strong>1</strong> 
    <a href="http://luozhaohui.github.io/kesalin/article/list/2">2</a>
    <a href="http://luozhaohui.github.io/kesalin/article/list/3">3</a>
    <a href="http://luozhaohui.github.io/kesalin/article/list/4">4</a> 
    <a href="http://luozhaohui.github.io/kesalin/article/list/5">5</a> 
    <a href="http://luozhaohui.github.io/kesalin/article/list/6">...</a> 
    <a href="http://luozhaohui.github.io/kesalin/article/list/2">下一页</a> 
    <a href="http://luozhaohui.github.io/kesalin/article/list/12">尾页</a>
</div>


<pre><code class="">
好，我们获得了papelist 的tag对象，通过这个tag对象我们能够找出尾页tag a对象，从这个tag a解析出对应的href属性，获得尾页的编号12，然后自己拼出所有page页面的访问url来，并保存在pageUrlList中返回。page页面的访问url形式示例如下：

    &gt; page 1: http://blog.csdn.net/kesalin/article/list/1

* 根据page来获取文章链接的代码：
</code></pre>

<p>def getArticleList(url):
    # 获取所有的文章的 url/title
    pageUrlList = getPageUrlList(url)</p>

<pre><code>articleListDocs = []

strPage = " &gt; parsing page {0}"
for pageUrl in pageUrlList:
    retryCount = 0
    print " &gt; parsing page {0}".format(pageUrl)

    slow_down() #访问太快会不响应
    page = getHtml(pageUrl);
    soup = BeautifulSoup(page)

    # 获取置顶文章
    topArticleDocs = soup.find_all(id="article_toplist")
    if topArticleDocs != None:
        articleListDocs = articleListDocs + topArticleDocs

    # 获取文章
    articleDocs = soup.find_all(id="article_list")
    if articleDocs != None:
        articleListDocs = articleListDocs + articleDocs

    break

artices = []
topTile = "[置顶]"
for articleListDoc in articleListDocs:
    linkDocs = articleListDoc.find_all("span", "link_title")
    for linkDoc in linkDocs:
        #print linkDoc.prettify().encode('UTF-8')
        link = linkDoc.a
        url = link["href"].encode('UTF-8')
        title = link.get_text().encode('UTF-8')
        title = title.replace(topTile, '').strip()
        oneHref = "http://blog.csdn.net" + url
        #log("   &gt; title:" + title + ", url:" + oneHref)
        artices.append([oneHref, title])

log("total articles: " + str(len(artices)) + "\n")
return artices
</code></pre>

<pre><code class="">
从第一步获得所有的page链接保存在pageUrlList中，接下来就根据这些page 页面来获取对应page的article链接和标题。关键代码如下面：
</code></pre>

<pre><code>    # 获取置顶文章
    topArticleDocs = soup.find_all(id="article_toplist")
    if topArticleDocs != None:
        articleListDocs = articleListDocs + topArticleDocs

    # 获取文章
    articleDocs = soup.find_all(id="article_list")
    if articleDocs != None:
        articleListDocs = articleListDocs + articleDocs
</code></pre>

<pre><code class="">
从page的html内容中查找置顶的文章（article_toplist）以及普通的文章（article_list）的tag对象，然后将这些tag保存到articleListDocs中。

article_toplist示例：(article_list的格式是类似的)
</code></pre>

<div id="article_toplist" class="list">
    <div class="list_item article_item">
        <div class="article_title">   
            <span class="ico ico_type_Original"></span>
            <h1>
                <span class="link_title">
                <a href="http://luozhaohui.github.io/kesalin/article/details/10474007">
                <font color="red">[置顶]</font>
                招聘：有兴趣做一个与Android对等的操作系统么？
                </a>
                </span>
            </h1>
        </div>
        ... ...
    </div>
    ... ...
</div>


<pre><code class="">
然后遍历所有的保存到articleListDocs里的tag对象，从中解析出link_title的span tag对象保存到linkDocs中；然后从中解析出链接的url和标题，这里去掉了置顶文章标题中的“置顶”两字；最后将url和标题保存到artices列表中返回。artices列表中的每一项内容示例：

       title:招聘：有兴趣做一个与Android对等的操作系统么？  
       url:http://blog.csdn.net/kesalin/article/details/10474007

* 根据文章链接获取文章html内容并解析转换为Markdown文本
</code></pre>

<p>def download(title, url, output):
    # 下载文章，并保存为 markdown 格式
    log(&ldquo; >> download: &rdquo; + url)</p>

<pre><code>categories = ""
content = ""
postDate = datetime.datetime.now()

slow_down();
page = getHtml(url)
soup = BeautifulSoup(page)

manageDocs = soup.find_all("div", "article_manage")
for managerDoc in manageDocs:
    categoryDoc = managerDoc.find_all("span", "link_categories")
    if len(categoryDoc) &gt; 0:
        categories = categoryDoc[0].a.get_text().encode('UTF-8').strip()

    postDateDoc = managerDoc.find_all("span", "link_postdate")
    if len(postDateDoc) &gt; 0:
        postDateStr = postDateDoc[0].string.encode('UTF-8').strip()
        postDate = datetime.datetime.strptime(postDateStr, '%Y-%m-%d %H:%M')

contentDocs = soup.find_all(id="article_content")
for contentDoc in contentDocs:
    htmlContent = contentDoc.prettify().encode('UTF-8')
    content = htmlContent2String(htmlContent)

exportToMarkdown(output, postDate, categories, title, content)
</code></pre>

<pre><code class="">
同前面的分析类似，在这里通过访问具体文章页面获得html内容，从中解析出文章标题，分类，发表时间，文章内容信息。然后把这些内容传递给函数exportToMarkdown，在其中生成相应的Markdown文本文件。值得一提的是，在解析文章内容信息时，由于html文档内容有一些特殊的标签或转义符号，需要作特殊处理，这些特殊处理在函数htmlContent2String中进行。目前只导出了所有的文本内容，图片，url链接以及表格都没有处理，后续我会尽量完善这些转换。
</code></pre>

<p>def htmlContent2String(contentStr):
    patternImg = re.compile(r'(&lt;img.+?src=&ldquo;)(.+?)(&rdquo;.+ />)&lsquo;)
    patternHref = re.compile(r&rsquo;(&lt;a.+?href=&ldquo;)(.+?)(&rdquo;.+?>)(.+?)(</a>)&lsquo;)
    patternRemoveHtml = re.compile(r&rsquo;&lt;/?[^>]+>&lsquo;)</p>

<pre><code>resultContent = patternImg.sub(r'![image_mark](\2)', contentStr)
resultContent = patternHref.sub(r'[\4](\2)', resultContent)
resultContent = re.sub(patternRemoveHtml, r'', resultContent)
resultContent = decodeHtmlSpecialCharacter(resultContent)
return resultContent
</code></pre>

<pre><code class="">
目前仅仅是删除所有的html标签，并在函数decodeHtmlSpecialCharacter中转换转义字符。

* 生成Markdown文本文件
</code></pre>

<p>def exportToMarkdown(exportDir, postdate, categories, title, content):
    titleDate = postdate.strftime(&lsquo;%Y-%m-%d&rsquo;)
    contentDate = postdate.strftime(&lsquo;%Y-%m-%d %H:%M:%S %z&rsquo;)
    filename = titleDate + &lsquo;-&rsquo; + title
    filename = repalceInvalidCharInFilename(filename)
    filepath = exportDir + &lsquo;/&rsquo; + filename + &lsquo;.markdown&rsquo;
    log(&ldquo; >> save as &rdquo; + filename)</p>

<pre><code>newFile = open(unicode(filepath, "utf8"), 'w')
newFile.write('---' + '\n')
newFile.write('layout: post' + '\n')
newFile.write('title: \"' + title + '\"\n')
newFile.write('date: ' + contentDate + '\n')
newFile.write('comments: true' + '\n')
newFile.write('categories: [' + categories + ']' + '\n')
newFile.write('tags: [' + categories + ']' + '\n')
newFile.write('description: \"' + title + '\"\n')
newFile.write('keywords: ' + categories + '\n') 
newFile.write('---' + '\n\n')
newFile.write(content)
newFile.write('\n')
newFile.close()
</code></pre>

<p>```</p>

<p>生成Markdown文本文件就很简单了，在这里我需要生成github page用的Markdown博文形式，所以内容如此，你可以根据你的需要修改为其他形式的文本内容。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android多线程分析之五：使用AsyncTask异步下载图像]]></title>
    <link href="http://luozhaohui.github.io/blog/2014/07/19/android-thread-tutoria05/"/>
    <updated>2014-07-19T21:12:40+08:00</updated>
    <id>http://luozhaohui.github.io/blog/2014/07/19/android-thread-tutoria05</id>
    <content type="html"><![CDATA[<h2>引言</h2>

<p>在本系列文章的第一篇<a href="https://luozhaohui.github.io/blog/2014/07/08/android-thread-tutoria01/">Android多线程分析之一：使用Thread异步下载图像</a>中，曾演示了如何使用 <code>Thread</code> 来完成异步任务。<code>Android</code> 为了简化在 <code>UI</code> 线程中完成异步任务（毕竟 <code>UI</code> 线程是 <code>app</code> 最重要的线程），实现了一个名为 <code>AysncTask</code> 的模板类。使用 <code>AysncTask</code> 能够在异步任务进行的同时，将任务进度状态反馈给 <code>UI</code> 线程（如让 <code>UI</code> 线程更新进度条）。正是由于它与 <code>UI</code> 线程紧密相关，使用的时候要就有一些限制，<code>AysncTask</code> 必须在 <code>UI</code> 线程中创建，并在 <code>UI</code> 线程中启动（通过调用其 <code>execute()</code> 方法）；此外，<code>AysncTask</code> 设计的目的是用于一些耗时较短的任务，如果是耗时较长的任务不推荐使用 <code>AysncTask</code>。</p>

<p>可以用简化记忆 “三参数，四步骤” 来学习 <code>AysncTask</code>。 即带有三个模板参数 <code>Params</code>, <code>Progress</code>, <code>Result</code>，四个处理步骤：<code>onPreExecute</code>，<code>doInBackground</code>，<code>onProgressUpdate</code>，<code>onPostExecute</code>。</p>

<!--more-->


<h2>简介</h2>

<h2>三参数</h2>

<blockquote><p><code>Params</code> 是异步任务所需的参数类型，也即 <code>doInBackground(Params&hellip; params)</code> 方法的参数类型；<br/>
<code>Progress</code> 是指进度的参数类型，也即 <code>onProgressUpdate(Progress&hellip; values)</code> 方法的参数类型；<br/>
<code>Result</code> 是指任务完成返回的参数类型，也即 <code>onPostExecute(Result result)</code> 或 <code>onCancelled(Result result)</code> 方法的参数类型。</p></blockquote>

<p>如果某一个参数类型没有意义或没有被用到，传递 <code>void</code> 即可。</p>

<h3>四步骤</h3>

<blockquote><p><code>protected void onPreExecute()</code>：在 <code>UI</code> 线程中运行，在异步任务开始之前被执行，以便 <code>UI</code> 线程完成一些初始化动作，如将进度条清零；<br/>
<code>protected abstract Result doInBackground(Params&hellip; params)</code>：在后台线程中运行，这是完成异步任务的地方，它是抽象接口，子类必须提供实现；<br/>
<code>protected void onProgressUpdate(Progress&hellip; values)</code>：在 <code>UI</code> 线程中运行，在异步任务执行的过程中可以通过调用 <code>void publishProgress(Progress&hellip; values)</code> 方法通知 <code>UI</code> 线程在 <code>onProgressUpdate</code> 方法内更新进度状态；<br/>
<code>protected void onPostExecute(Result result)</code>：在 <code>UI</code> 线程中运行，当异步任务完成之后被执行，以便 <code>UI</code> 线程更新任务完成状态。</p></blockquote>

<p><code>AysncTask</code> 支持取消异步任务，当异步任务被取消之后，上面的步骤四就不会被执行了，取而代之将执行 <code>onCancelled(Result result)</code>，以便 <code>UI</code> 线程更新任务被取消之后的状态。谨记：上面提到的这些方法都是回调函数，不需要用户手动去调用。</p>

<p>以前的 <code>AysncTask</code> 是基于单一后台线程实现的，而从 <code>Android 3.0</code> 起 <code>AysncTask</code> 是基于 <code>Android</code> 的并发库（<code>java.util.concurrent</code>）实现的，本文中不会展开讨论其具体实现，只是演示如何使用 <code>AysncTask。</p>

<h2>使用示例</h2>

<p>有了前面的轮廓介绍，再来使用 <code>AysncTask</code> 是非常容易的，下面的例子与<a href="https://luozhaohui.github.io/blog/2014/07/08/android-thread-tutoria01/">Android多线程分析之一：使用Thread异步下载图像</a>中的例子非常相似，只不过是使用 <code>AysncTask</code> 来完成异步任务罢了。</p>

<h2>权限</h2>

<p>这是一个使用 <code>AysncTask</code> 从网络上异步下载图片并在 <code>ImageView</code> 中显示的的简单示例。因为需要访问网络，所以要在 <code>manifest.xml</code> 中添加网络访问权限：
<code>xml
    &lt;uses-permission android:name="android.permission.INTERNET"&gt;
    &lt;/uses-permission&gt;
</code></p>

<h3>布局</h3>

<p>布局文件很简单，一个 <code>Button</code>，一个 <code>ImageView</code>：</p>

<pre><code class="xml">&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:padding="10dip" &gt;

    &lt;Button
        android:id="@+id/LoadButton"
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:text="Load"&gt;
    &lt;/Button&gt;

    &lt;ImageView
        android:id="@+id/ImageVivew" 
        android:layout_width="match_parent" 
        android:layout_height="400dip" 
        android:scaleType="centerInside" 
        android:padding="2dp"&gt;
    &lt;/ImageView&gt; 

&lt;/LinearLayout&gt;
</code></pre>

<h3>代码：</h3>

<p>首先来看定义：图片的 <code>url</code> 路径，两个消息值以及一些控件：</p>

<pre><code class="java">    private static final String sImageUrl = "http://fashion.qqread.com/ArtImage/20110225/0083_13.jpg";
    private Button mLoadButton;
    private ImageView mImageView;
</code></pre>

<p>然后来看控件的设置：</p>

<pre><code class="java">    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        Log.i("UI thread", " &gt;&gt; onCreate()");

        mImageView = (ImageView)this.findViewById(R.id.ImageVivew);

        mLoadButton = (Button)this.findViewById(R.id.LoadButton);
        mLoadButton.setOnClickListener(new View.OnClickListener() {
            @Override 
            public void onClick(View v) {
                LoadImageTask task = new LoadImageTask(v.getContext());
                task.execute(sImageUrl);
            }
        });
    }
</code></pre>

<p><code>LoadImageTask</code> 继承自 <code>AysncTask</code>，由这个类去完成异步图片下载任务，并相应地更新 <code>UI</code> 状态。</p>

<pre><code class="java">    class LoadImageTask extends AsyncTask&lt;String, Integer, Bitmap&gt; 
    {
        private ProgressDialog mProgressBar;

        LoadImageTask(Context context)
        {
            mProgressBar = new ProgressDialog(context);
            mProgressBar.setCancelable(true);
            mProgressBar.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
            mProgressBar.setMax(100);
        }

        @Override
        protected Bitmap doInBackground(String... params) {
            Log.i("Load thread", " &gt;&gt; doInBackground()");

            Bitmap bitmap = null;

            try{
                publishProgress(10);
                Thread.sleep(1000);

                InputStream in = new java.net.URL(sImageUrl).openStream();
                publishProgress(60);
                Thread.sleep(1000);

                bitmap = BitmapFactory.decodeStream(in);
                in.close();
            } catch (Exception e) {
                e.printStackTrace();
            }

            publishProgress(100);
            return bitmap;
        }

        @Override
        protected void onCancelled() {
            super.onCancelled();
        }

        @Override
        protected void onPreExecute() {

            mProgressBar.setProgress(0);
            mProgressBar.setMessage("Image downloading ... %0");
            mProgressBar.show();

            Log.i("UI thread", " &gt;&gt; onPreExecute()");
        }

        @Override
        protected void onPostExecute(Bitmap result) {
            Log.i("UI thread", " &gt;&gt; onPostExecute()");
            if (result != null) {
                mProgressBar.setMessage("Image downloading success!");
                mImageView.setImageBitmap(result);
            }
            else {
                mProgressBar.setMessage("Image downloading failure!");
            }

            mProgressBar.dismiss(); 
        }

       @Override
        protected void onProgressUpdate(Integer... values) {
           Log.i("UI thread", " &gt;&gt; onProgressUpdate() %" + values[0]);
           mProgressBar.setMessage("Image downloading ... %" + values[0]);
           mProgressBar.setProgress(values[0]);
        }
    };
</code></pre>

<p>在 <code>LoadImageTask 中，前面提到的四个步骤都涉及到了：</p>

<p>首先在任务开始之前在 <code>onPreExecute()</code> 方法中设置进度条的初始状态（<code>UI</code>线程）；然后在下载线程中执行 <code>doInBackground()</code> 以完成下载任务，并在其中调用 <code>publishProgress()</code> 来通知 <code>UI</code> 线程更新进度状态；<code>UI</code> 线程在 <code>onProgressUpdate()</code> 中得知进度，并更新进度条（<code>UI线程</code>）；最后下载任务完成，<code>UI</code> 线程在 <code>onPostExecute()</code>中得知下载好的图像，并更新<code>UI</code>显示该图像（<code>UI</code>线程）。</p>
]]></content>
  </entry>
  
</feed>
