
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>C++ 11模板元编程实现Scheme中的list及相关函数式编程接口 - 飘飘白云</title>
  <meta name="author" content="飘飘白云">

  
  <meta name="description" content="C++ 11模板元编程实现Scheme中的list及相关函数式编程接口">
  <meta name="keywords" content="C++, Scheme">

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://luozhaohui.github.io/blog/2017/03/15/cpp-scheme/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="飘飘白云" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <!-- <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script> -->
  <script src="//libs.baidu.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">飘飘白云</a></h1>
  
    <h2>所读，所看，所思</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.bing.com/search/" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="luozhaohui.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="搜索..."/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">所有文章</a></li>
  <!-- <li><a href="/blog/archives/tags.html">标签</a></li> -->
  <li><a href="/books">读书如抽丝</a></li>
  <li><a href="/about">关于我</a></li>
</ul>
</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">C++ 11模板元编程实现Scheme中的list及相关函数式编程接口</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2017-03-15T09:03:20+08:00'><span class='date'>2017-03-15</span> <span class='time'>9:03 am</span></time>
        
           | <a href="#disqus_thread"
             data-disqus-identifier="http://luozhaohui.github.io">评论</a>
        
      </p>
    
  </header>


<div class="entry-content"><h2>前言</h2>

<p>本文将介绍如何使用<code>C++11</code>模板元编程实现<code>Scheme</code>中的<code>list</code>及相关函数式编程接口，如<code>list</code>，<code>cons</code>，<code>car</code>，<code>cdr</code>，<code>length</code>，<code>is_empty</code>，<code>reverse</code>，<code>append</code>,<code>map</code>，<code>transform</code>，<code>enumerate</code>，<code>lambda</code>等。</p>

<h2>预备知识</h2>

<h3>Scheme简介</h3>

<p><a href="http://schemers.org/">Scheme</a>语言是<code>lisp</code>语言的一个方言(或说成变种)，它诞生于1975年的<code>MIT</code>，对于这个有近三十年历史的编程语言来说，它并没有象 C++，java，C#那样受到商业领域的青睐，在国内更是鲜为人知。但它在国外的计算机教育领域内却是有着广泛应用的，有很多人学的第一门计算机语言就 是<code>Scheme</code>语言（<a href="https://book.douban.com/subject/1148282/">SICP</a>曾经就是以<code>Scheme</code>为教学语言）。</p>

<p>它是一个小巧而又强大的语言，作为一个多用途的编程语言，它可以作为脚本语言使用，也可以作为应用软件的扩展语言来使用，它具有元语言特性，还有很多独到的特色,以致于它被称为编程语言中的"皇后"。</p>

<p>如果你对<code>Scheme</code>感兴趣，推荐使用<a href="http://racket-lang.org/">drracket</a>这个</ode>GUI</code>解释器，入门教程有：<a href="http://www.htdp.org/">How to Design Programs</a>，高级教程有：<a href="https://book.douban.com/subject/1148282/">SICP</a>。</p>

<!--more-->


<h3>Scheme中的list及相关操作</h3>

<p><code>list</code>可以说是<code>Lisp</code>系语言的根基，其名就得自于<code><strong>LIS</strong>t <strong>P</strong>rocessor</code>，其重要性就像文件概念之于<code>unix</code>。</p>

<p><code>list</code>示例：</p>

<blockquote><p>(list &ldquo;red&rdquo; &ldquo;green&rdquo; &ldquo;blue&rdquo;)<br/>
&lsquo;(&ldquo;red&rdquo; &ldquo;green&rdquo; &ldquo;blue&rdquo;)<br/>
(list 1 2 3)<br/>
&rsquo;(1 2 3)</p></blockquote>

<p>上面的语法糖<code>list</code>其实是通过递归调用点对<code>cons</code>实现的，因此上面的语法等价于：</p>

<blockquote><p>(cons &ldquo;red&rdquo; (cons &ldquo;green&rdquo; (cons &ldquo;blue&rdquo; empty)))<br/>
&lsquo;(&ldquo;red&rdquo; &ldquo;green&rdquo; &ldquo;blue&rdquo;)<br/>
(cons 1 (cons 2 (cons 3 empty)))<br/>
&rsquo;(1 2 3)</p></blockquote>

<p>另外两个重要的点对操作是<code>car</code>和<code>cdr</code>，名字有点奇怪但是是有<a href="https://en.wikipedia.org/wiki/CAR_and_CDR">历史的</a>：<strong>C</strong>urrent <strong>A</strong>ddress <strong>R</strong>egister and <strong>C</strong>urrent <strong>D</strong>ecrement <strong>R</strong>egister，其实就相当于<code>first</code>和<code>second</code>的意思。</p>

<blockquote><p>(car (cons 1 2))  ==> 1<br/>
(cdr (cons 1 2))  ==> 2</p></blockquote>

<h3>模板元编程</h3>

<p>C++中的Meta Programming，即模板元编程，是图灵完备的，而且是编译期间完成的。模板元编程通常用于编写工具库，如STL、Boost等。</p>

<p>比如通常我们使用递归来实现实现阶乘：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;iostream&gt;
</span><span class='line'> 
</span><span class='line'>unsigned int factorial(unsigned int n) {
</span><span class='line'>    return n == 0 ? 1 : n * factorial(n - 1);
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>int main() {
</span><span class='line'>    std::cout &lt;&lt; factorial(5) &lt;&lt; std::endl;
</span><span class='line'>    return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>我们也可以通过模板元编程来实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;iostream&gt;
</span><span class='line'>
</span><span class='line'>template &lt;unsigned int n&gt;
</span><span class='line'>struct factorial {
</span><span class='line'>    static constexpr unsigned int value = n * factorial&lt;n - 1&gt;::value;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>template &lt;&gt;
</span><span class='line'>struct factorial&lt;0&gt; {
</span><span class='line'>    static constexpr unsigned int value = 1;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>int main() {
</span><span class='line'>    std::cout &lt;&lt; factorial&lt;5&gt;::value &lt;&lt; std::endl; // 120
</span><span class='line'>    return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>实现</h2>

<p>本文完整代码可以在这里查看：<a href="https://github.com/luozhaohui/cpp/blob/master/cons.cpp">点击查看代码</a></p>

<h3>基本数据结构</h3>

<p>为了用模板元编程来模拟Scheme中<code>list</code>即相关操作，我们需要先定义一些模板数据结构。这些数据结构非常简单，即重新定义基本数据类型，为了简化，在这里我只特化了必须的<code>int</code>、<code>uint</code>、<code>bool</code>以及<code>empty</code>的实现。<code>empty</code>是递归实现<code>list</code>的最后一个元素，其作用相当于<code>&lsquo;\0&rsquo;</code>之于字符串。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// type_
</span><span class='line'>//
</span><span class='line'>template &lt;typename T, T N&gt;
</span><span class='line'>struct type_ {
</span><span class='line'>    using type = type_&lt;T, N&gt;;
</span><span class='line'>    using value_type = T;
</span><span class='line'>    static constexpr T value = N;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>// int_
</span><span class='line'>//
</span><span class='line'>template &lt;int N&gt;
</span><span class='line'>struct int_ {
</span><span class='line'>    using type = int_&lt;N&gt;;
</span><span class='line'>    using value_type = int;
</span><span class='line'>    static constexpr int value = N;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>// uint_
</span><span class='line'>//
</span><span class='line'>template &lt;unsigned int N&gt;
</span><span class='line'>struct uint_ {
</span><span class='line'>    using type = uint_&lt;N&gt;;
</span><span class='line'>    using value_type = unsigned int;
</span><span class='line'>    static constexpr unsigned int value = N;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>template &lt;&gt;
</span><span class='line'>struct uint_&lt;0&gt; {
</span><span class='line'>    using type = uint_&lt;0&gt;;
</span><span class='line'>    using value_type = unsigned int;
</span><span class='line'>    static constexpr unsigned int value = 0;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>// bool_
</span><span class='line'>template &lt;bool N&gt;
</span><span class='line'>struct bool_ {
</span><span class='line'>    using type = bool_&lt;N&gt;;
</span><span class='line'>    using value_type = bool;
</span><span class='line'>    static constexpr bool value = N;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>// empty
</span><span class='line'>//
</span><span class='line'>struct empty {
</span><span class='line'>    using type = empty;
</span><span class='line'>    using value = empty;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>下面我们先来个小示例，看看怎么使用这些模板数据结构。这个示例的作用是将仅仅用0和1表示的十进制数字当成二进制看，转换为十进制数值。如：101 转换为十进制数值为 5.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;unsigned int N&gt;
</span><span class='line'>struct binary : uint_ &lt; binary &lt; N / 10 &gt;::type::value * 2 + (N % 10) &gt; {};
</span><span class='line'>
</span><span class='line'>template &lt;&gt;
</span><span class='line'>struct binary&lt;0&gt; : uint_&lt;0&gt; {};</span></code></pre></td></tr></table></div></figure>


<p>测试示例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>std::cout &lt;&lt; binary&lt;101&gt;::value &lt;&lt; std::endl;               // 5</span></code></pre></td></tr></table></div></figure>


<h3>cons &amp; car &amp; cdr实现</h3>

<p><code>cons</code>的实现原理很简单：就是能够递归调用自己结合成点对<code>pair</code>。在<code>Scheme</code>中示例如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(cons 1 (cons 2 (cons 3 '())))</span></code></pre></td></tr></table></div></figure>


<p>其中<code>&lsquo;()</code>表示空的点对<code>pair</code>，在我们的实现里面就是<code>empty</code>。</p>

<p>因此<code>cons</code>用C++元编程实现就是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;typename h, typename t&gt;
</span><span class='line'>struct cons {
</span><span class='line'>    using type = cons&lt;h, t&gt;;
</span><span class='line'>    using head = h;
</span><span class='line'>    using tail = t;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>使用示例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>std::cout &lt;&lt; cons&lt;int_&lt;1&gt;, int_&lt;2&gt;&gt;::head::value &lt;&lt; std::endl;  // 1</span></code></pre></td></tr></table></div></figure>


<p>同样，我们可以实现用于获取<code>head</code>的<code>car</code>与获取<code>tail</code>的<code>cdr</code>操作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct car_t {
</span><span class='line'>    template &lt;typename cons&gt;
</span><span class='line'>    struct apply {
</span><span class='line'>        using type = typename cons::type::head;
</span><span class='line'>    };
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>template &lt;typename cons&gt;
</span><span class='line'>struct car : car_t::template apply&lt;cons&gt;::type {};
</span><span class='line'>
</span><span class='line'>struct cdr_t {
</span><span class='line'>    template &lt;typename cons&gt;
</span><span class='line'>    struct apply {
</span><span class='line'>        using type = typename cons::type::tail::type;
</span><span class='line'>    };
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>template &lt;typename cons&gt;
</span><span class='line'>struct cdr : cdr_t::template apply&lt;cons&gt;::type {};</span></code></pre></td></tr></table></div></figure>


<p>使用示例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>using c1 = cons&lt;int_&lt;1&gt;, cons&lt;int_&lt;2&gt;, int_&lt;3&gt;&gt;&gt;;
</span><span class='line'>std::cout &lt;&lt; car&lt;c1&gt;::value &lt;&lt; ", " &lt;&lt; cdr&lt;c1&gt;::head::value &lt;&lt; std::endl; // 1, 2
</span><span class='line'>std::cout &lt;&lt; car&lt;c1&gt;::value &lt;&lt; ", " &lt;&lt; car&lt;cdr&lt;c1&gt;&gt;::value &lt;&lt; std::endl; // 1, 2</span></code></pre></td></tr></table></div></figure>


<p>对于上面的实现，稍微解释一下：<code>car</code>是对<code>car_t</code>的封装，这样使用起来更为方便，对比如下用法就能明了，后面这样的封装手法还会用到：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>car&lt;cons&lt;int_&lt;1&gt;, int_&lt;2&gt;&gt;::value                   // == 1
</span><span class='line'>car_f::template apply&lt;cons&lt;int_&lt;1&gt;, int_&lt;2&gt;&gt;::value // == 1</span></code></pre></td></tr></table></div></figure>


<h3>list的实现</h3>

<p><code>list</code>其实一种特殊的<code>cons</code>，其实现如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;typename first = empty, typename ...rest&gt;
</span><span class='line'>struct list_t : std::conditional &lt;
</span><span class='line'>    sizeof...(rest) == 0,
</span><span class='line'>    cons&lt;first, empty&gt;,
</span><span class='line'>    cons&lt;first, typename list_t&lt;rest...&gt;::type&gt;&gt;::type
</span><span class='line'>{};
</span><span class='line'>
</span><span class='line'>template &lt;&gt;
</span><span class='line'>struct list_t&lt;empty&gt; : empty {};
</span><span class='line'>
</span><span class='line'>template &lt;typename T, T ...elements&gt;
</span><span class='line'>struct list : list_t&lt;type_&lt;T, elements&gt;...&gt; {};</span></code></pre></td></tr></table></div></figure>


<p>这里用到了C++11中的变长模板参数，<code>std::conditional</code>以及对<code>empty</code>的特化处理。
 - 变长模板参数：<code>list</code>接收变长模板参数<code>elements</code>，然后封装类型为成<code>type_</code>的变长模板参数forward给<code>list_t</code>；
 - <code>std::conditional</code>：相当于<code>if &hellip; else &hellip;</code>，如果第一参数为真，则返回第二参数，否则返回第三参数；
 - &lt;第一参数中的code>sizeof&hellip;(rest)</code>：<code>sizeof</code>是C++11的新用法，用于获取变长参数的个数；
 - 第二参数的作用是终止递归；
 - 第三参数的作用是递归调用<code>list_t</code>构造点对。
 - 因为<code>empty</code>比较特殊，所以需要特化处理</p>

<p>使用示例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>using l1 = list&lt;int, 1, 2, 3&gt;;
</span><span class='line'>using l2 = list&lt;int, 4, 5, 6, 7&gt;;
</span><span class='line'>using l3 = list_t&lt;int_&lt;1&gt;, int_&lt;2&gt;, int_&lt;3&gt;&gt;;
</span><span class='line'>
</span><span class='line'>std::cout &lt;&lt; "\n&gt;list" &lt;&lt; std::endl;
</span><span class='line'>print&lt;l1&gt;();    // 1, 2, 3
</span><span class='line'>print&lt;l3&gt;();    // 1, 2, 3
</span><span class='line'>std::cout &lt;&lt; car&lt;l1&gt;::value &lt;&lt; ", " &lt;&lt; cdr&lt;l1&gt;::head::value &lt;&lt; std::endl;   // 1, 2</span></code></pre></td></tr></table></div></figure>


<h3>length &amp; is_empty的实现</h3>

<p>先来看看<code>length<code>的实现，其思路与list的实现一样：递归调用自身，并针对<code>empty</code>特化处理。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;typename list&gt;
</span><span class='line'>struct length_t
</span><span class='line'>{
</span><span class='line'>    static constexpr unsigned int value =
</span><span class='line'>        1 + length_t&lt;typename cdr&lt;list&gt;::type&gt;::value;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>template &lt;&gt;
</span><span class='line'>struct length_t&lt;empty&gt;
</span><span class='line'>{
</span><span class='line'>    static constexpr unsigned int value = 0;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>template &lt;typename list&gt;
</span><span class='line'>struct length
</span><span class='line'>{
</span><span class='line'>    static constexpr unsigned int value = length_t&lt;typename list::type&gt;::value;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p><code>is_empty</code>可以简单实现为判断<code>length</code>为0：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;typename list&gt;
</span><span class='line'>struct is_empty
</span><span class='line'>{
</span><span class='line'>    static constexpr bool value = (0 == length&lt;list&gt;::value);
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>当然这样的实现效率并不高，因此可以通过对<code>list</code>以及<code>empty</code>的特化处理来高效实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;typename list&gt;
</span><span class='line'>struct is_empty_t
</span><span class='line'>{
</span><span class='line'>    static constexpr bool value = false;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>template &lt;&gt;
</span><span class='line'>struct is_empty_t&lt;empty&gt;
</span><span class='line'>{
</span><span class='line'>    static constexpr bool value = true;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>template &lt;typename list&gt;
</span><span class='line'>struct is_empty
</span><span class='line'>{
</span><span class='line'>    static constexpr bool value = is_empty_t&lt;typename list::type&gt;::value;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>使用示例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>std::cout &lt;&lt; "is_empty&lt;empty&gt; : " &lt;&lt; is_empty&lt;empty&gt;::value &lt;&lt; std::endl;            // 1
</span><span class='line'>std::cout &lt;&lt; "is_empty&lt;list&lt;int&gt;&gt; : " &lt;&lt; is_empty&lt;list&lt;int&gt;&gt;::value &lt;&lt; std::endl;    // 1
</span><span class='line'>std::cout &lt;&lt; "is_empty&lt;list&lt;int, 1, 2, 3&gt;&gt; : " &lt;&lt; is_empty&lt;l1&gt;::value &lt;&lt; std::endl;  // 0
</span><span class='line'>std::cout &lt;&lt; "length&lt;empty&gt; : " &lt;&lt; length&lt;empty&gt;::value &lt;&lt; std::endl;                // 0
</span><span class='line'>std::cout &lt;&lt; "length&lt;list&lt;int&gt;&gt; : " &lt;&lt; length&lt;list&lt;int&gt;&gt;::value &lt;&lt; std::endl;        // 0
</span><span class='line'>std::cout &lt;&lt; "length&lt;list&lt;int, 1, 2, 3&gt;&gt; : " &lt;&lt; length&lt;l1&gt;::value &lt;&lt; std::endl;      // 3</span></code></pre></td></tr></table></div></figure>


<h3>append &amp; reverse的实现</h3>

<p><code>append</code>是将一个列表list2追加到已有列表list1的后面，其实现思路是递归地将car<list1>当做head，然后将cdr<list1>作为新的list1递归调用append。不要忘记特化<code>empty</code>的情况。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct append_t {
</span><span class='line'>    template &lt;typename list1, typename list2&gt;
</span><span class='line'>    struct apply : cons&lt;
</span><span class='line'>        typename car&lt;list1&gt;::type,
</span><span class='line'>        typename append_t::template apply&lt;typename cdr&lt;list1&gt;::type, list2&gt;::type&gt;
</span><span class='line'>    {};
</span><span class='line'>
</span><span class='line'>    template&lt;typename list2&gt;
</span><span class='line'>    struct apply &lt;empty, list2&gt;: list2
</span><span class='line'>    {};
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>template &lt;typename list1, typename list2&gt;
</span><span class='line'>struct append : std::conditional &lt;
</span><span class='line'>    is_empty&lt;list1&gt;::value,
</span><span class='line'>    list2,
</span><span class='line'>    append_t::template apply&lt;list1, list2&gt;
</span><span class='line'>    &gt;::type
</span><span class='line'>{};</span></code></pre></td></tr></table></div></figure>


<p><code>reverse</code>的实现思路与<code>append</code>类似，只不过是要逆序罢了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct reverse_t {
</span><span class='line'>    template &lt;typename reset, typename ready&gt;
</span><span class='line'>    struct apply : reverse_t::template apply&lt;
</span><span class='line'>            typename cdr&lt;reset&gt;::type,
</span><span class='line'>            cons&lt;typename car&lt;reset&gt;::type, ready&gt;&gt;
</span><span class='line'>    {};
</span><span class='line'>
</span><span class='line'>    template&lt;typename ready&gt;
</span><span class='line'>    struct apply &lt;empty, ready&gt; : ready
</span><span class='line'>    {};
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>template &lt;typename list&gt;
</span><span class='line'>struct reverse : std::conditional &lt;
</span><span class='line'>    is_empty&lt;list&gt;::value,
</span><span class='line'>    list,
</span><span class='line'>    reverse_t::template apply&lt;typename list::type, empty&gt;
</span><span class='line'>    &gt;::type
</span><span class='line'>{};</span></code></pre></td></tr></table></div></figure>


<p>使用示例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// reverse
</span><span class='line'>using r1 = reverse&lt;l1&gt;;
</span><span class='line'>using r2 = reverse&lt;list&lt;int&gt;&gt;;
</span><span class='line'>print&lt;r1&gt;();    // 3, 2, 1
</span><span class='line'>print&lt;r2&gt;();
</span><span class='line'>
</span><span class='line'>// append
</span><span class='line'>using a1 = append&lt;l1, l2&gt;;
</span><span class='line'>using a2 = append&lt;l1, list&lt;int&gt;&gt;;
</span><span class='line'>using a3 = append&lt;list&lt;int&gt;, l1&gt;;
</span><span class='line'>print&lt;a1&gt;();    // 1, 2, 3, 4, 5, 6, 7
</span><span class='line'>print&lt;a2&gt;();    // 1, 2, 3
</span><span class='line'>print&lt;a3&gt;();    // 1, 2, 3</span></code></pre></td></tr></table></div></figure>


<h3>函数式编程</h3>

<p><code>lisp</code>系语言的最大特性就是支持函数式编程，它能够把无差别地对待数据与函数，实现了对数据与代码的同等抽象。下面我们来添加对函数式编程的支持：<code>enumerate</code>, <code>map</code>，<code>apply</code>, <code>lambda</code> 以及 <code>transform</code>。</p>

<h4>map的实现</h4>

<p><code>map</code>的语义是迭代地将某个方法作用于列表中的每个元素，然后得到结果<code>list</code>。先来定义一些辅助的方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;typename T, typename N&gt;
</span><span class='line'>struct plus : int_ &lt; T::value + N::value &gt; {};
</span><span class='line'>
</span><span class='line'>template &lt;typename T, typename N&gt;
</span><span class='line'>struct minus : int_ &lt; T::value - N::value &gt; {};
</span><span class='line'>
</span><span class='line'>struct inc_t {
</span><span class='line'>    template &lt;typename n&gt;
</span><span class='line'>    struct apply : int_ &lt; n::value + 1 &gt; {};
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>template &lt;typename n&gt;
</span><span class='line'>struct inc : int_ &lt; n::value + 1 &gt; {};</span></code></pre></td></tr></table></div></figure>


<p>下面来看map的实现</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct map_t {
</span><span class='line'>    template &lt;typename fn, typename list&gt;
</span><span class='line'>    struct apply : cons &lt;
</span><span class='line'>        typename fn::template apply&lt;typename car&lt;list&gt;::type&gt;,
</span><span class='line'>        map_t::template apply&lt;fn, typename cdr&lt;list&gt;::type&gt;
</span><span class='line'>    &gt;{};
</span><span class='line'>
</span><span class='line'>    template &lt;typename fn&gt;
</span><span class='line'>    struct apply &lt;fn, empty&gt;: empty{};
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>template &lt;typename fn, typename list&gt;
</span><span class='line'>struct map : std::conditional &lt;
</span><span class='line'>    is_empty&lt;list&gt;::value,
</span><span class='line'>    list,
</span><span class='line'>    map_t::template apply&lt;fn, list&gt;
</span><span class='line'>    &gt;::type
</span><span class='line'>{};</span></code></pre></td></tr></table></div></figure>


<p>使用示例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>using m1 = map&lt;inc_t, list&lt;int, 1, 2, 3&gt;&gt;;
</span><span class='line'>using m2 = map&lt;inc_t, list&lt;int&gt;&gt;;
</span><span class='line'>print&lt;m1&gt;();    // 2, 3, 4
</span><span class='line'>print&lt;m2&gt;();</span></code></pre></td></tr></table></div></figure>


<p>为了让<code>map</code>支持形如<code>inc</code>这样的模板类，而不仅仅是形如<code>inc_t</code>，我们需要定义一个转换器：<code>lambda</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct apply_t {
</span><span class='line'>    template &lt;template &lt;typename...&gt; class F, typename ...args&gt;
</span><span class='line'>    struct apply : F&lt;typename args::type...&gt; {};
</span><span class='line'>
</span><span class='line'>    template &lt;template &lt;typename...&gt; class F&gt;
</span><span class='line'>    struct apply &lt;F, empty&gt; : empty {};
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>template &lt;template &lt;typename...&gt; class F, typename ...args&gt;
</span><span class='line'>struct apply : apply_t::template apply&lt;F, args...&gt; {};
</span><span class='line'>
</span><span class='line'>template &lt;template &lt;typename...&gt; class F&gt;
</span><span class='line'>struct lambda {
</span><span class='line'>    template &lt;typename ...args&gt;
</span><span class='line'>    struct apply : apply_t::template apply&lt;F, args...&gt; {};
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>使用示例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>std::cout &lt;&lt; lambda&lt;inc&gt;::template apply&lt;int_&lt;0&gt;&gt;::value &lt;&lt; std::endl;  // 1
</span><span class='line'>using ml1 = map&lt;lambda&lt;inc&gt;, list&lt;int, 1, 2, 3&gt;&gt;;
</span><span class='line'>print&lt;ml1&gt;();  // 2, 3, 4</span></code></pre></td></tr></table></div></figure>


<h3>transform的实现</h3>

<p><code>transform</code>的语义是对迭代地将某个方法作用于两个列表上的元素，然后得到结果<code>list</code>。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct transform_t {
</span><span class='line'>    template &lt;typename list1, typename list2, typename fn&gt;
</span><span class='line'>    struct apply : cons &lt;
</span><span class='line'>        typename fn::template apply&lt;
</span><span class='line'>            typename car&lt;list1&gt;::type, typename car&lt;list2&gt;::type&gt;::type,
</span><span class='line'>        typename transform_t::template apply &lt;
</span><span class='line'>            typename cdr&lt;list1&gt;::type, typename cdr&lt;list2&gt;::type, fn&gt;::type
</span><span class='line'>    &gt; {};
</span><span class='line'>
</span><span class='line'>    template &lt;typename list1, typename fn&gt;
</span><span class='line'>    struct apply&lt;list1, empty, fn&gt; : cons &lt;
</span><span class='line'>        typename fn::template apply&lt;typename car&lt;list1&gt;::type, empty&gt;,
</span><span class='line'>        typename transform_t::template apply &lt;typename cdr&lt;list1&gt;::type, empty, fn&gt;::type
</span><span class='line'>    &gt; {};
</span><span class='line'>
</span><span class='line'>    template &lt;typename list2, typename fn&gt;
</span><span class='line'>    struct apply&lt;empty, list2, fn&gt; : cons &lt;
</span><span class='line'>        typename fn::template apply&lt;empty, typename car&lt;list2&gt;::type&gt;::type,
</span><span class='line'>        typename transform_t::template apply &lt;empty, typename cdr&lt;list2&gt;::type, fn&gt;::type
</span><span class='line'>    &gt; {};
</span><span class='line'>
</span><span class='line'>    template &lt;typename fn&gt;
</span><span class='line'>    struct apply&lt;empty, empty, fn&gt; : empty {};
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>template &lt;typename list1, typename list2, typename fn&gt;
</span><span class='line'>struct transform : std::conditional &lt;
</span><span class='line'>    is_empty&lt;list1&gt;::value,
</span><span class='line'>    list1,
</span><span class='line'>    transform_t::template apply&lt;list1, list2, fn&gt;
</span><span class='line'>    &gt;::type
</span><span class='line'>{
</span><span class='line'>    static_assert(length&lt;list1&gt;::value == length&lt;list2&gt;::value, "transform: length of lists mismatch!");
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>其实现是最为复杂的，我们先来看使用示例，再来讲解实现细节。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>using t1 = list&lt;int, 1, 2, 3&gt;;
</span><span class='line'>using t2 = list&lt;int, 3, 2, 1&gt;;
</span><span class='line'>using ml = transform&lt;t1, t2, lambda&lt;minus&gt;&gt;;
</span><span class='line'>using pl = transform&lt;t1, t2, lambda&lt;plus&gt;&gt;;
</span><span class='line'>using te = transform&lt;list&lt;int&gt;, list&lt;int&gt;, lambda&lt;plus&gt;&gt;;
</span><span class='line'>using el = transform&lt;t1, list&lt;int&gt;, lambda&lt;plus&gt;&gt;;
</span><span class='line'>print&lt;ml&gt;();    // -2, 0, 2
</span><span class='line'>print&lt;pl&gt;();    // 4, 4, 4
</span><span class='line'>print&lt;te&gt;();
</span><span class='line'>// print&lt;el&gt;(); // assertion: length mismatch!</span></code></pre></td></tr></table></div></figure>


<p>实现细节：</p>

<ul>
<li>使用<code>C++11</code>新特性<code>static_assert</code>对两个列表的长度相等做断言；</li>
<li>使用<code>std::conditional</code>处理空列表，如果非空<code>forward</code>给<code>transform_t</code>；</li>
<li>对<code>transform_t</code>特化处理空列表的情况；</li>
<li>如果<code>list1</code>与<code>list2</code>均非空，那么通过<code>car</code>取出两个列表的<code>head</code>作用于方法，然后递归调用<code>transform_t</code>作用于两个列表的<code>tail</code>。</li>
</ul>


<h3>enumerate的实现</h3>

<p><code>enumerate</code>的语义是迭代将某个方法作用于列表元素。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;typename fn, typename list, bool is_empty&gt;
</span><span class='line'>struct enumerate_t;
</span><span class='line'>
</span><span class='line'>template &lt;typename fn, typename list&gt;
</span><span class='line'>void enumerate(fn f)
</span><span class='line'>{
</span><span class='line'>    enumerate_t&lt;fn, list, is_empty&lt;list&gt;::value&gt; impl;
</span><span class='line'>    impl(f);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>template &lt;typename fn, typename list, bool is_empty = false&gt;
</span><span class='line'>struct enumerate_t
</span><span class='line'>{
</span><span class='line'>    void operator()(fn f) {
</span><span class='line'>        f(car&lt;list&gt;::value);
</span><span class='line'>        enumerate&lt;fn, typename cdr&lt;list&gt;::type&gt;(f);
</span><span class='line'>    }
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>template &lt;typename fn, typename list&gt;
</span><span class='line'>struct enumerate_t&lt;fn, list, true&gt;
</span><span class='line'>{
</span><span class='line'>    void operator()(fn f) {
</span><span class='line'>        // nothing for empty
</span><span class='line'>    }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p><code>enumerate</code>的实现与之前的<code>map</code>的实现很不一样，它是通过模板方法与函数子来实现的。模板方法内部调用函数子来做事情，函数子又是一个模板类，并对空列表做了特化处理。</p>

<p>使用示例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>using value_type = typename car&lt;e1&gt;::value_type;
</span><span class='line'>auto sqr_print = [](value_type val) { std::cout &lt;&lt; val * val &lt;&lt; " "; };
</span><span class='line'>enumerate&lt;decltype(sqr_print), e1&gt;(sqr_print);      // 1 4 9</span></code></pre></td></tr></table></div></figure>


<h3>equal的实现</h3>

<p><code>equal</code>用于判断两个列表是否等价。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct equal_t {
</span><span class='line'>    // both lists are not empty
</span><span class='line'>    template &lt;typename list1, typename list2, int empty_value = 0,
</span><span class='line'>        typename pred = lambda&lt;std::is_same&gt;&gt;
</span><span class='line'>    struct apply : std::conditional &lt;
</span><span class='line'>        !pred::template apply &lt;
</span><span class='line'>            typename car&lt;list1&gt;::type,
</span><span class='line'>            typename car&lt;list2&gt;::type
</span><span class='line'>            &gt;::type::value,
</span><span class='line'>        bool_&lt;false&gt;,
</span><span class='line'>        typename equal_t::template apply &lt;
</span><span class='line'>            typename cdr&lt;list1&gt;::type,
</span><span class='line'>            typename cdr&lt;list2&gt;::type,
</span><span class='line'>            (is_empty&lt;typename cdr&lt;list1&gt;::type&gt;::value
</span><span class='line'>                + is_empty&lt;typename cdr&lt;list2&gt;::type&gt;::value),
</span><span class='line'>            pred
</span><span class='line'>        &gt;::type
</span><span class='line'>    &gt; {};
</span><span class='line'>
</span><span class='line'>    // one of the list is empty.
</span><span class='line'>    template &lt;typename list1, typename list2, typename pred&gt;
</span><span class='line'>    struct apply&lt;list1, list2, 1, pred&gt;: bool_&lt;false&gt;
</span><span class='line'>    {};
</span><span class='line'>
</span><span class='line'>    // both lists are empty.
</span><span class='line'>    template &lt;typename list1, typename list2, typename pred&gt;
</span><span class='line'>    struct apply&lt;list1, list2, 2, pred&gt;: bool_&lt;true&gt;
</span><span class='line'>    {};
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>template &lt;typename list1, typename list2, typename pred = lambda&lt;std::is_same&gt;&gt;
</span><span class='line'>struct equal : equal_t::template apply&lt;list1, list2,
</span><span class='line'>    (is_empty&lt;list1&gt;::value + is_empty&lt;list2&gt;::value), pred&gt;::type
</span><span class='line'>{};</span></code></pre></td></tr></table></div></figure>


<p><code>equal</code>的实现也有点复杂。</p>

<ul>
<li><code>pred</code>是等价比较谓词，默认是使用<code>std::is_same</code>来做比较；</li>
<li>关键部分依然是通过<code>std::conditional</code>来实现的；</li>
<li>第一参数是判断两个列表的<code>head</code>是否相等；</li>
<li>如果不等就返回第二参数；</li>
<li>如果相等就递归比较两个列表的剩余元素；</li>
<li>这里使用了一个小小的技巧来简化模板类特化的情况：如果其中一个列表为空，那么<code>empty_value</code>为1；如果两个列表均为空，那么<code>empty_value</code>为2，这两种情况都会调用特化版本。</li>
</ul>


<p>使用示例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>using e1 = list&lt;int, 1, 2, 3&gt;;
</span><span class='line'>using e2 = list&lt;int, 1, 2, 3&gt;;
</span><span class='line'>using e3 = list&lt;int, 1, 2, 1&gt;;
</span><span class='line'>std::cout &lt;&lt; "equal&lt;e1, e2&gt; : " &lt;&lt; equal&lt;e1, e2&gt;::value &lt;&lt; std::endl;   // 1
</span><span class='line'>std::cout &lt;&lt; "equal&lt;e1, e3&gt; : " &lt;&lt; equal&lt;e1, e3&gt;::value &lt;&lt; std::endl;   // 0
</span><span class='line'>std::cout &lt;&lt; "equal&lt;e1, list&lt;int&gt;&gt; : " &lt;&lt; equal&lt;e1, list&lt;int&gt;&gt;::value &lt;&lt; std::endl; // 0
</span><span class='line'>std::cout &lt;&lt; "equal&lt;list&lt;int&gt;, e1&gt; : " &lt;&lt; equal&lt;list&lt;int&gt;, e1&gt;::value &lt;&lt; std::endl; // 0
</span><span class='line'>std::cout &lt;&lt; "equal&lt;list&lt;int&gt;, list&lt;int&gt;&gt; : " &lt;&lt; equal&lt;list&lt;int&gt;, list&lt;int&gt;&gt;::value &lt;&lt; std::endl;   // 1</span></code></pre></td></tr></table></div></figure>


<h3>print的实现</h3>

<p><code>print</code>是依次打印列表元素，也可以使用<code>enumerate</code>来实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;typename list, bool is_empty&gt;
</span><span class='line'>struct print_t;
</span><span class='line'>
</span><span class='line'>template &lt;typename list&gt;
</span><span class='line'>void print()
</span><span class='line'>{
</span><span class='line'>    print_t&lt;list, is_empty&lt;list&gt;::value&gt; impl;
</span><span class='line'>    impl();
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>template &lt;typename list, bool is_empty = true&gt;
</span><span class='line'>struct print_t
</span><span class='line'>{
</span><span class='line'>    void operator()() {
</span><span class='line'>        std::cout &lt;&lt; std::endl;
</span><span class='line'>    }
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>template &lt;typename list&gt;
</span><span class='line'>struct print_t&lt;list, false&gt;
</span><span class='line'>{
</span><span class='line'>    void operator()() {
</span><span class='line'>        std::cout &lt;&lt; car&lt;list&gt;::value;
</span><span class='line'>        using rest = typename cdr&lt;list&gt;::type;
</span><span class='line'>        if (false == is_empty&lt;rest&gt;::value) {
</span><span class='line'>            std::cout &lt;&lt; ", ";
</span><span class='line'>        }
</span><span class='line'>        print&lt;rest&gt;();
</span><span class='line'>    }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p><code>print</code>的实现思路与<code>enumerate</code>，是通过模板方法与函数子来实现的。模板方法内部调用函数子来做事情，函数子又是一个模板类，并对空列表做了特化处理。</p>

<h2>总结</h2>

<p><code>C++</code>尤其是<code>C++</code>11，14，17等新特性使得这把实用的瑞士军刀越发锋利与实用，虽然实现的形式上不如<code>Scheme</code>、<code>Python</code>等优雅，但它确实能够，而且无需获得语言层面上的支持。纸上得来终觉浅，绝知此事要躬行。看过本文的读者不妨自己实现一番本文中的提到的相关概念。</p>

<h3>参考阅读</h3>

<p><a href="https://book.douban.com/subject/1148282/">《计算机程序的构造与解释》</a></p>
</div>


  
  <footer>

    <p>
      
  

<span class="byline author vcard"><span class="fn">飘飘白云</span>  发表于</span>

      




<time class='entry-date' datetime='2017-03-15T09:03:20+08:00'><span class='date'>2017-03-15</span> <span class='time'>9:03 am</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/ruan-jian-kai-fa/'>软件开发</a>
  
</span>


      

<span class="tags">
  
    <a class='tag' href='/tags/c-plus-plus/'>C++</a>, <a class='tag' href='/tags/scheme/'>Scheme</a>
  
</span>


      <DIV class="sharing">

  

  
  
  

  
	<!-- JiaThis Button BEGIN -->
<script type="text/javascript">
var jiathis_config = {data_track_clickback:'true'};
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jiathis_r.js?type=left&amp;move=0&amp;uid=1362230537412331" charset="utf-8"></script>
<!-- JiaThis Button END -->
  

</DIV>

    </p>

    <p>
      

<DIV style="BORDER-BOTTOM: #bbbbbb 1px solid; BORDER-LEFT: #bbbbbb 1px solid; BACKGROUND: #f6f6f6; HEIGHT: 186px; BORDER-TOP: #bbbbbb 1px solid; BORDER-RIGHT: #bbbbbb 1px solid" class=kesalinlicense>
	<DIV style="font-size:14px; LINE-HEIGHT: 100%; MARGIN-TOP: 10px; FLOAT: top; text-align: center; COLOR: #000000"> 
	如果您觉得我的文章还不错，不妨小额打赏一下。
	</DIV>

	<DIV style="MARGIN-TOP: 10px; FLOAT: left; text-align: center; MARGIN-LEFT: 20%"> 
		<IMG alt="支付宝扫码支付" src="/images/pay/alipay.png" width=118 height=120>
		<DIV style="font-size:12px; LINE-HEIGHT: 100%; MARGIN-TOP: 4px; FLOAT: top; text-align: center; COLOR: #000000">
		支付宝扫一扫
		</DIV>
	</DIV> 

	<DIV style="MARGIN-TOP: 10px; FLOAT: right; text-align: center; MARGIN-RIGHT: 20%"> 
		<IMG alt="微信扫码支付" src="/images/pay/weixinpay.png" width=118 height=120>
		<DIV style="font-size:12px; LINE-HEIGHT: 100%; MARGIN-TOP: 4px; FLOAT: top; text-align: center; COLOR: #000000">
		微信扫一扫
		</DIV>
	</DIV> 

</DIV> 

    </p>

    <p>
      

<DIV style="MARGIN-TOP: 10px; font-size:12px;BORDER-BOTTOM: #bbbbbb 1px solid; BORDER-LEFT: #bbbbbb 1px solid; BACKGROUND: #f6f6f6; HEIGHT: 120px; BORDER-TOP: #bbbbbb 1px solid; BORDER-RIGHT: #bbbbbb 1px solid" class=kesalinlicense> 
	<DIV style="MARGIN-TOP: 14px; FLOAT: left; MARGIN-LEFT: 10px; MARGIN-RIGHT: 10px"> 
		<IMG alt="" src="http://pic.cnitblog.com/avatar/81194/20130411221004.png" width=90 height=100>
	</DIV> 
	<DIV style="MARGIN-TOP: 14px; LINE-HEIGHT: 200%; COLOR: #000000"> 
		作者： <A href="http://luozhaohui.github.io/">飘飘白云/罗朝辉</A> <BR> 
		出处： <A href="http://luozhaohui.github.io/">http://luozhaohui.github.io/</A> 
		<BR>本文基于<a target="_blank" title="Creative Commons Attribution 2.5 China Mainland License" href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/">署名-非商业性使用-相同方式共享 2.5 中国大陆</a>许可协议发布
		<BR>欢迎非商业目的转载，须保持文章完整，并保留署名与出处</a> 
	</DIV>
</DIV> 

    </p>
    
    <p>
      

<DIV class="related-posts" style="MARGIN-TOP: 10px; font-size:12px;BORDER-BOTTOM: #bbbbbb 1px solid; BORDER-LEFT: #bbbbbb 1px solid; BACKGROUND: #f6f6f6; BORDER-TOP: #bbbbbb 1px solid; BORDER-RIGHT: #bbbbbb 1px solid; padding-left: 8px;">
<h3 style="margin-bottom: 0px"> 您也许会喜欢：</h3>
<ol style="margin-left: 8px">

  	<ul>
      	<li>
	      	<article class="post type-post status-publish format-standard hentry">
				
				<a href="/blog/2021/12/24/reading/">2021年阅读统计</a>
				<span></span><span></span>
				<time datetime="2021-12-24T19:32:38+00:00" pubdate><span class='month'>Dec</span> <span class='day'>24</span> <span class='year'>2021</span></time>
			</article>
		</li>
	</ul>

  	<ul>
      	<li>
	      	<article class="post type-post status-publish format-standard hentry">
				
				<a href="/blog/2020/12/31/reading/">2020年阅读统计</a>
				<span></span><span></span>
				<time datetime="2020-12-31T07:32:38+00:00" pubdate><span class='month'>Dec</span> <span class='day'>31</span> <span class='year'>2020</span></time>
			</article>
		</li>
	</ul>

  	<ul>
      	<li>
	      	<article class="post type-post status-publish format-standard hentry">
				
				<a href="/blog/2019/12/31/reading/">2019年阅读统计</a>
				<span></span><span></span>
				<time datetime="2019-12-31T10:32:38+00:00" pubdate><span class='month'>Dec</span> <span class='day'>31</span> <span class='year'>2019</span></time>
			</article>
		</li>
	</ul>

<ol>
</DIV>


    </p>

    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2017/08/07/the-strunggle-for-law/" title="上一篇: 法律的斗争（萨孟武节录意译本）">&laquo; 法律的斗争（萨孟武节录意译本）</a>
      

      
        <a class="basic-alignment right" href="/blog/2016/12/31/reading/" title="下一篇: 2016年阅读统计">2016年阅读统计 &raquo;</a>
      
    </p>

    <p>
    
      <section>
        <h1>评论</h1>
        <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
      </section>
    

<!--     
    
      目前还没有评论。
     -->
    </p>

  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>文章分类</h1>
  <ul id="categories">
    <li class='category'><a href='/blog/categories/shu-ping-ying-ping/'>书评影评 (43)</a></li>
<li class='category'><a href='/blog/categories/gong-ju-ruan-jian/'>工具软件 (2)</a></li>
<li class='category'><a href='/blog/categories/xin-zhi-si-wei/'>心智思维 (6)</a></li>
<li class='category'><a href='/blog/categories/sui-sui-nian/'>碎碎念 (24)</a></li>
<li class='category'><a href='/blog/categories/she-hui-za-tan/'>社会杂谈 (9)</a></li>
<li class='category'><a href='/blog/categories/du-shu-bi-ji/'>读书笔记 (2)</a></li>
<li class='category'><a href='/blog/categories/ruan-jian-kai-fa/'>软件开发 (9)</a></li>
<li class='category'><a href='/blog/categories/bian-zou-bian-kan/'>边走边看 (2)</a></li>

  </ul>
</section><section>
  <h1>最新文章</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2021/12/24/reading/">2021年阅读统计</a>
      </li>
    
      <li class="post">
        <a href="/blog/2020/12/31/reading/">2020年阅读统计</a>
      </li>
    
      <li class="post">
        <a href="/blog/2019/12/31/reading/">2019年阅读统计</a>
      </li>
    
      <li class="post">
        <a href="/blog/2018/12/31/reading/">2018年阅读统计</a>
      </li>
    
      <li class="post">
        <a href="/blog/2018/10/10/kids-english-with-phonics/">幼儿英语启蒙路线图</a>
      </li>
    
  </ul>
</section>
<section>
  <h1>标签云</h1>
  <ul class="tag-cloud">
    <a style="font-size: 110%" href="/tags/shu-ping/">书评</a>
<a style="font-size: 107%" href="/tags/sui-sui-nian/">碎碎念</a>
<a style="font-size: 106%" href="/tags/ying-ping/">影评</a>
<a style="font-size: 103%" href="/tags/si-wei/">思维</a>
<a style="font-size: 101%" href="/tags/za-tan/">杂谈</a>
<a style="font-size: 100%" href="/tags/android/">android</a>
<a style="font-size: 99%" href="/tags/xin-qing/">心情</a>
<a style="font-size: 99%" href="/tags/thread/">thread</a>
<a style="font-size: 98%" href="/tags/hui-yi/">回忆</a>
<a style="font-size: 96%" href="/tags/ri-ben/">日本</a>
<a style="font-size: 96%" href="/tags/li-shi/">历史</a>
<a style="font-size: 96%" href="/tags/gong-ju/">工具</a>
<a style="font-size: 96%" href="/tags/zheng-zhi/">政治</a>
<a style="font-size: 94%" href="/tags/lu-you/">旅游</a>
<a style="font-size: 94%" href="/tags/bi-ji/">笔记</a>
<a style="font-size: 94%" href="/tags/jiao-yu/">教育</a>
<a style="font-size: 94%" href="/tags/fang-fa-lun/">方法论</a>
<a style="font-size: 90%" href="/tags/wen-hua/">文化</a>
<a style="font-size: 90%" href="/tags/fang-yan/">方言</a>
<a style="font-size: 90%" href="/tags/ri-ju/">日剧</a>

  </ul>
</section>
  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2021 - 飘飘白云 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>

<!-- 友盟站点统计：http://www.umeng.com/ -->
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1261636993'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1261636993%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>

</p>
</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'https-luozhaohui-github-io';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://luozhaohui.github.io/blog/2017/03/15/cpp-scheme/';
        var disqus_url = 'http://luozhaohui.github.io/blog/2017/03/15/cpp-scheme/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>


<!-- <noscript>Please enable JavaScript to view the comment form powered by <a href="https://commentit.io/">Comm(ent|it)</a></noscript>
<div id="commentit"></div>
<script type="text/javascript">
  /** CONFIGURATION VARIABLES **/
  var commentitUsername = 'luozhaohui';
  var commentitRepo = 'luozhaohui/luozhaohui.github.io';
  var commentitPath = '_posts/2017-03-15-cpp-scheme.markdown';

  /** DON'T EDIT FOLLOWING LINES **/
  (function() {
      var commentit = document.createElement('script');
      commentit.type = 'text/javascript';
      commentit.async = true;
      commentit.src = 'https://commentit.io/static/embed/dist/commentit.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(commentit);
  })();
</script> -->









</body>
</html>
