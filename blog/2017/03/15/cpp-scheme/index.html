<h1>前言</h1>

<p>本文将介绍如何使用C++11模板元编程实现Scheme中的list及相关函数式编程接口，如<code>list</code>，<code>cons</code>，<code>car</code>，<code>cdr</code>，<code>length</code>，<code>is_empty</code>，<code>reverse</code>，<code>append</code>,<code>map</code>，<code>transform</code>，<code>enumerate</code>，<code>lambda</code>等。</p>

<h1>预备知识</h1>

<h2>Scheme简介</h2>

<p><a href="http://schemers.org/">Scheme</a>语言是<code>lisp>语言的一个方言(或说成变种)，它诞生于1975年的MIT，对于这个有近三十年历史的编程语言来说，它并没有象 C++，java，C#那样受到商业领域的青睐，在国内更是鲜为人知。但它在国外的计算机教育领域内却是有着广泛应用的，有很多人学的第一门计算机语言就 是Scheme语言（<a href="https://book.douban.com/subject/1148282/">SICP</a>就是以Scheme为教学语言）。</p>

<p>它是一个小巧而又强大的语言，作为一个多用途的编程语言，它可以作为脚本语言使用，也可以作为应用软件的扩展语言来使用，它具有元语言特性，还有很多独到的特色,以致于它被称为编程语言中的"皇后"。</p>

<p>如果你对Scheme感兴趣，推荐使用<a href="http://racket-lang.org/">drracket</a>这个GUI解释器，入门教程有：<a href="http://www.htdp.org/">How to Design Programs</a>，高级教程有：<a href="https://book.douban.com/subject/1148282/">SICP</a>。</p>

<h2>Scheme中的list及相关操作</h2>

<p><code>list</code>可以说是Lisp系语言的根基，其名就得自于<code><strong>LIS</strong>t <strong>P</strong>rocessor</code>，其重要性就像文件概念之于unix。</p>

<p><code>list</code>示例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; (list "red" "green" "blue")
</span><span class='line'>'("red" "green" "blue")
</span><span class='line'>&gt; (list 1 2 3)
</span><span class='line'>'(1 2 3)</span></code></pre></td></tr></table></div></figure>


<p>上面的语法糖<code>list</code>其实是通过递归调用点对<code>cons</code>实现的，因此上面的语法等价于：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; (cons "red" (cons "green" (cons "blue" empty)))
</span><span class='line'>'("red" "green" "blue")
</span><span class='line'>&gt; (cons 1 (cons 2 (cons 3 empty)))
</span><span class='line'>'(1 2 3)</span></code></pre></td></tr></table></div></figure>


<p>另外两个重要的点对操作是<code>car</code>和<code>cdr</code>，名字有点奇怪但是是有<a href="https://en.wikipedia.org/wiki/CAR_and_CDR">历史的</a>：<strong>C</strong>urrent <strong>A</strong>ddress <strong>R</strong>egister and <strong>C</strong>urrent <strong>D</strong>ecrement <strong>R</strong>egister，其实就相当于<code>first</code>和<code>second</code>的意思。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(car (cons 1 2))  ==&gt; 1
</span><span class='line'>(cdr (cons 1 2))  ==&gt; 2</span></code></pre></td></tr></table></div></figure>


<h2>模板元编程</h2>

<p>C++中的Meta Programming，即模板元编程，是图灵完备的，而且是编译期间完成的。模板元编程通常用于编写工具库，如STL、Boost等。</p>

<p>比如通常我们使用递归来实现实现阶乘：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;iostream&gt;
</span><span class='line'> 
</span><span class='line'>unsigned int factorial(unsigned int n) {
</span><span class='line'>    return n == 0 ? 1 : n * factorial(n - 1);
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>int main() {
</span><span class='line'>    std::cout &lt;&lt; factorial(5) &lt;&lt; std::endl;
</span><span class='line'>    return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>
我们也可以通过模板元编程来实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;iostream&gt;
</span><span class='line'>
</span><span class='line'>template &lt;unsigned int n&gt;
</span><span class='line'>struct factorial {
</span><span class='line'>    static constexpr unsigned int value = n * factorial&lt;n - 1&gt;::value;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>template &lt;&gt;
</span><span class='line'>struct factorial&lt;0&gt; {
</span><span class='line'>    static constexpr unsigned int value = 1;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>int main() {
</span><span class='line'>    std::cout &lt;&lt; factorial&lt;5&gt;::value &lt;&lt; std::endl; // 120
</span><span class='line'>    return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h1>实现</h1>

<p>本文完整代码可以在这里查看：<a href="https://github.com/luozhaohui/cpp/blob/master/cons.cpp">点击查看代码</a></p>

<h2>基本数据结构</h2>

<p>为了用模板元编程来模拟Scheme中<code>list</code>即相关操作，我们需要先定义一些模板数据结构。这些数据结构非常简单，即重新定义基本数据类型，为了简化，在这里我只特化了必须的<code>int</code>、<code>uint</code>、<code>bool</code>以及<code>empty</code>的实现。<code>empty</code>是递归实现<code>list</code>的最后一个元素，其作用相当于<code>&lsquo;\0&rsquo;</code>之于字符串。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// type_
</span><span class='line'>//
</span><span class='line'>template &lt;typename T, T N&gt;
</span><span class='line'>struct type_ {
</span><span class='line'>    using type = type_&lt;T, N&gt;;
</span><span class='line'>    using value_type = T;
</span><span class='line'>    static constexpr T value = N;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>// int_
</span><span class='line'>//
</span><span class='line'>template &lt;int N&gt;
</span><span class='line'>struct int_ {
</span><span class='line'>    using type = int_&lt;N&gt;;
</span><span class='line'>    using value_type = int;
</span><span class='line'>    static constexpr int value = N;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>// uint_
</span><span class='line'>//
</span><span class='line'>template &lt;unsigned int N&gt;
</span><span class='line'>struct uint_ {
</span><span class='line'>    using type = uint_&lt;N&gt;;
</span><span class='line'>    using value_type = unsigned int;
</span><span class='line'>    static constexpr unsigned int value = N;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>template &lt;&gt;
</span><span class='line'>struct uint_&lt;0&gt; {
</span><span class='line'>    using type = uint_&lt;0&gt;;
</span><span class='line'>    using value_type = unsigned int;
</span><span class='line'>    static constexpr unsigned int value = 0;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>// bool_
</span><span class='line'>template &lt;bool N&gt;
</span><span class='line'>struct bool_ {
</span><span class='line'>    using type = bool_&lt;N&gt;;
</span><span class='line'>    using value_type = bool;
</span><span class='line'>    static constexpr bool value = N;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>// empty
</span><span class='line'>//
</span><span class='line'>struct empty {
</span><span class='line'>    using type = empty;
</span><span class='line'>    using value = empty;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>下面我们先来个小示例，看看怎么使用这些模板数据结构。这个示例的作用是将仅仅用0和1表示的十进制数字当成二进制看，转换为十进制数值。如：101 转换为十进制数值为 5.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;unsigned int N&gt;
</span><span class='line'>struct binary : uint_ &lt; binary &lt; N / 10 &gt;::type::value * 2 + (N % 10) &gt; {};
</span><span class='line'>
</span><span class='line'>template &lt;&gt;
</span><span class='line'>struct binary&lt;0&gt; : uint_&lt;0&gt; {};</span></code></pre></td></tr></table></div></figure>


<p>测试示例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>std::cout &lt;&lt; binary&lt;101&gt;::value &lt;&lt; std::endl;               // 5</span></code></pre></td></tr></table></div></figure>


<h2>cons &amp; car &amp; cdr实现</h2>

<p><code>cons</code>的实现原理很简单：就是能够递归调用自己结合成点对<code>pair</code>。在<code>Scheme</code>中示例如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(cons 1 (cons 2 (cons 3 '())))</span></code></pre></td></tr></table></div></figure>


<p>其中<code>&lsquo;()</code>表示空的点对<code>pair</code>，在我们的实现里面就是<code>empty</code>。</p>

<p>因此<code>cons</code>用C++元编程实现就是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;typename h, typename t&gt;
</span><span class='line'>struct cons {
</span><span class='line'>    using type = cons&lt;h, t&gt;;
</span><span class='line'>    using head = h;
</span><span class='line'>    using tail = t;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>使用示例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>std::cout &lt;&lt; cons&lt;int_&lt;1&gt;, int_&lt;2&gt;&gt;::head::value &lt;&lt; std::endl;  // 1</span></code></pre></td></tr></table></div></figure>


<p>同样，我们可以实现用于获取<code>head</code>的<code>car</code>与获取<code>tail</code>的<code>cdr</code>操作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct car_t {
</span><span class='line'>    template &lt;typename cons&gt;
</span><span class='line'>    struct apply {
</span><span class='line'>        using type = typename cons::type::head;
</span><span class='line'>    };
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>template &lt;typename cons&gt;
</span><span class='line'>struct car : car_t::template apply&lt;cons&gt;::type {};
</span><span class='line'>
</span><span class='line'>struct cdr_t {
</span><span class='line'>    template &lt;typename cons&gt;
</span><span class='line'>    struct apply {
</span><span class='line'>        using type = typename cons::type::tail::type;
</span><span class='line'>    };
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>template &lt;typename cons&gt;
</span><span class='line'>struct cdr : cdr_t::template apply&lt;cons&gt;::type {};</span></code></pre></td></tr></table></div></figure>


<p>使用示例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>using c1 = cons&lt;int_&lt;1&gt;, cons&lt;int_&lt;2&gt;, int_&lt;3&gt;&gt;&gt;;
</span><span class='line'>std::cout &lt;&lt; car&lt;c1&gt;::value &lt;&lt; ", " &lt;&lt; cdr&lt;c1&gt;::head::value &lt;&lt; std::endl; // 1, 2
</span><span class='line'>std::cout &lt;&lt; car&lt;c1&gt;::value &lt;&lt; ", " &lt;&lt; car&lt;cdr&lt;c1&gt;&gt;::value &lt;&lt; std::endl; // 1, 2</span></code></pre></td></tr></table></div></figure>


<p>对于上面的实现，稍微解释一下：<code>car</code>是对<code>car_t</code>的封装，这样使用起来更为方便，对比如下用法就能明了，后面这样的封装手法还会用到：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>car&lt;cons&lt;int_&lt;1&gt;, int_&lt;2&gt;&gt;::value                   // == 1
</span><span class='line'>car_f::template apply&lt;cons&lt;int_&lt;1&gt;, int_&lt;2&gt;&gt;::value // == 1</span></code></pre></td></tr></table></div></figure>


<h2>list的实现</h2>

<p><code>list</code>其实一种特殊的<code>cons</code>，其实现如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;typename first = empty, typename ...rest&gt;
</span><span class='line'>struct list_t : std::conditional &lt;
</span><span class='line'>    sizeof...(rest) == 0,
</span><span class='line'>    cons&lt;first, empty&gt;,
</span><span class='line'>    cons&lt;first, typename list_t&lt;rest...&gt;::type&gt;&gt;::type
</span><span class='line'>{};
</span><span class='line'>
</span><span class='line'>template &lt;&gt;
</span><span class='line'>struct list_t&lt;empty&gt; : empty {};
</span><span class='line'>
</span><span class='line'>template &lt;typename T, T ...elements&gt;
</span><span class='line'>struct list : list_t&lt;type_&lt;T, elements&gt;...&gt; {};</span></code></pre></td></tr></table></div></figure>


<p>这里用到了C++11中的变长模板参数，<code>std::conditional</code>以及对<code>empty</code>的特化处理。
 - 变长模板参数：<code>list</code>接收变长模板参数<code>elements</code>，然后封装类型为成<code>type_</code>的变长模板参数forward给<code>list_t</code>；
 - <code>std::conditional</code>：相当于<code>if &hellip; else &hellip;</code>，如果第一参数为真，则返回第二参数，否则返回第三参数；
 - &lt;第一参数中的code>sizeof&hellip;(rest)</code>：<code>sizeof</code>是C++11的新用法，用于获取变长参数的个数；
 - 第二参数的作用是终止递归；
 - 第三参数的作用是递归调用<code>list_t</code>构造点对。
 - 因为<code>empty</code>比较特殊，所以需要特化处理</p>

<p>使用示例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>using l1 = list&lt;int, 1, 2, 3&gt;;
</span><span class='line'>using l2 = list&lt;int, 4, 5, 6, 7&gt;;
</span><span class='line'>using l3 = list_t&lt;int_&lt;1&gt;, int_&lt;2&gt;, int_&lt;3&gt;&gt;;
</span><span class='line'>
</span><span class='line'>std::cout &lt;&lt; "\n&gt;list" &lt;&lt; std::endl;
</span><span class='line'>print&lt;l1&gt;();    // 1, 2, 3
</span><span class='line'>print&lt;l3&gt;();    // 1, 2, 3
</span><span class='line'>std::cout &lt;&lt; car&lt;l1&gt;::value &lt;&lt; ", " &lt;&lt; cdr&lt;l1&gt;::head::value &lt;&lt; std::endl;   // 1, 2</span></code></pre></td></tr></table></div></figure>


<h2>length &amp; is_empty的实现</h2>

<p>先来看看<code>length<code>的实现，其思路与list的实现一样：递归调用自身，并针对<code>empty</code>特化处理。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;typename list&gt;
</span><span class='line'>struct length_t
</span><span class='line'>{
</span><span class='line'>    static constexpr unsigned int value =
</span><span class='line'>        1 + length_t&lt;typename cdr&lt;list&gt;::type&gt;::value;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>template &lt;&gt;
</span><span class='line'>struct length_t&lt;empty&gt;
</span><span class='line'>{
</span><span class='line'>    static constexpr unsigned int value = 0;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>template &lt;typename list&gt;
</span><span class='line'>struct length
</span><span class='line'>{
</span><span class='line'>    static constexpr unsigned int value = length_t&lt;typename list::type&gt;::value;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p><code>is_empty</code>可以简单实现为判断<code>length</code>为0：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;typename list&gt;
</span><span class='line'>struct is_empty
</span><span class='line'>{
</span><span class='line'>    static constexpr bool value = (0 == length&lt;list&gt;::value);
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>当然这样的实现效率并不高，因此可以通过对<code>list</code>以及<code>empty</code>的特化处理来高效实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;typename list&gt;
</span><span class='line'>struct is_empty_t
</span><span class='line'>{
</span><span class='line'>    static constexpr bool value = false;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>template &lt;&gt;
</span><span class='line'>struct is_empty_t&lt;empty&gt;
</span><span class='line'>{
</span><span class='line'>    static constexpr bool value = true;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>template &lt;typename list&gt;
</span><span class='line'>struct is_empty
</span><span class='line'>{
</span><span class='line'>    static constexpr bool value = is_empty_t&lt;typename list::type&gt;::value;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>使用示例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>std::cout &lt;&lt; "is_empty&lt;empty&gt; : " &lt;&lt; is_empty&lt;empty&gt;::value &lt;&lt; std::endl;            // 1
</span><span class='line'>std::cout &lt;&lt; "is_empty&lt;list&lt;int&gt;&gt; : " &lt;&lt; is_empty&lt;list&lt;int&gt;&gt;::value &lt;&lt; std::endl;    // 1
</span><span class='line'>std::cout &lt;&lt; "is_empty&lt;list&lt;int, 1, 2, 3&gt;&gt; : " &lt;&lt; is_empty&lt;l1&gt;::value &lt;&lt; std::endl;  // 0
</span><span class='line'>std::cout &lt;&lt; "length&lt;empty&gt; : " &lt;&lt; length&lt;empty&gt;::value &lt;&lt; std::endl;                // 0
</span><span class='line'>std::cout &lt;&lt; "length&lt;list&lt;int&gt;&gt; : " &lt;&lt; length&lt;list&lt;int&gt;&gt;::value &lt;&lt; std::endl;        // 0
</span><span class='line'>std::cout &lt;&lt; "length&lt;list&lt;int, 1, 2, 3&gt;&gt; : " &lt;&lt; length&lt;l1&gt;::value &lt;&lt; std::endl;      // 3</span></code></pre></td></tr></table></div></figure>


<h2>append &amp; reverse的实现</h2>

<p><code>append</code>是将一个列表list2追加到已有列表list1的后面，其实现思路是递归地将car<list1>当做head，然后将cdr<list1>作为新的list1递归调用append。不要忘记特化<code>empty</code>的情况。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct append_t {
</span><span class='line'>    template &lt;typename list1, typename list2&gt;
</span><span class='line'>    struct apply : cons&lt;
</span><span class='line'>        typename car&lt;list1&gt;::type,
</span><span class='line'>        typename append_t::template apply&lt;typename cdr&lt;list1&gt;::type, list2&gt;::type&gt;
</span><span class='line'>    {};
</span><span class='line'>
</span><span class='line'>    template&lt;typename list2&gt;
</span><span class='line'>    struct apply &lt;empty, list2&gt;: list2
</span><span class='line'>    {};
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>template &lt;typename list1, typename list2&gt;
</span><span class='line'>struct append : std::conditional &lt;
</span><span class='line'>    is_empty&lt;list1&gt;::value,
</span><span class='line'>    list2,
</span><span class='line'>    append_t::template apply&lt;list1, list2&gt;
</span><span class='line'>    &gt;::type
</span><span class='line'>{};</span></code></pre></td></tr></table></div></figure>


<p><code>reverse</code>的实现思路与<code>append</code>类似，只不过是要逆序罢了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct reverse_t {
</span><span class='line'>    template &lt;typename reset, typename ready&gt;
</span><span class='line'>    struct apply : reverse_t::template apply&lt;
</span><span class='line'>            typename cdr&lt;reset&gt;::type,
</span><span class='line'>            cons&lt;typename car&lt;reset&gt;::type, ready&gt;&gt;
</span><span class='line'>    {};
</span><span class='line'>
</span><span class='line'>    template&lt;typename ready&gt;
</span><span class='line'>    struct apply &lt;empty, ready&gt; : ready
</span><span class='line'>    {};
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>template &lt;typename list&gt;
</span><span class='line'>struct reverse : std::conditional &lt;
</span><span class='line'>    is_empty&lt;list&gt;::value,
</span><span class='line'>    list,
</span><span class='line'>    reverse_t::template apply&lt;typename list::type, empty&gt;
</span><span class='line'>    &gt;::type
</span><span class='line'>{};</span></code></pre></td></tr></table></div></figure>


<p>使用示例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// reverse
</span><span class='line'>using r1 = reverse&lt;l1&gt;;
</span><span class='line'>using r2 = reverse&lt;list&lt;int&gt;&gt;;
</span><span class='line'>print&lt;r1&gt;();    // 3, 2, 1
</span><span class='line'>print&lt;r2&gt;();
</span><span class='line'>
</span><span class='line'>// append
</span><span class='line'>using a1 = append&lt;l1, l2&gt;;
</span><span class='line'>using a2 = append&lt;l1, list&lt;int&gt;&gt;;
</span><span class='line'>using a3 = append&lt;list&lt;int&gt;, l1&gt;;
</span><span class='line'>print&lt;a1&gt;();    // 1, 2, 3, 4, 5, 6, 7
</span><span class='line'>print&lt;a2&gt;();    // 1, 2, 3
</span><span class='line'>print&lt;a3&gt;();    // 1, 2, 3</span></code></pre></td></tr></table></div></figure>


<h2>函数式编程</h2>

<p><code>lisp</code>系语言的最大特性就是支持函数式编程，它能够把无差别地对待数据与函数，实现了对数据与代码的同等抽象。下面我们来添加对函数式编程的支持：<code>enumerate</code>, <code>map</code>，<code>apply</code>, <code>lambda</code> 以及 <code>transform</code>。</p>

<h3>map的实现</h3>

<p><code>map</code>的语义是迭代地将某个方法作用于列表中的每个元素，然后得到结果<code>list</code>。先来定义一些辅助的方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;typename T, typename N&gt;
</span><span class='line'>struct plus : int_ &lt; T::value + N::value &gt; {};
</span><span class='line'>
</span><span class='line'>template &lt;typename T, typename N&gt;
</span><span class='line'>struct minus : int_ &lt; T::value - N::value &gt; {};
</span><span class='line'>
</span><span class='line'>struct inc_t {
</span><span class='line'>    template &lt;typename n&gt;
</span><span class='line'>    struct apply : int_ &lt; n::value + 1 &gt; {};
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>template &lt;typename n&gt;
</span><span class='line'>struct inc : int_ &lt; n::value + 1 &gt; {};</span></code></pre></td></tr></table></div></figure>


<p>下面来看map的实现</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct map_t {
</span><span class='line'>    template &lt;typename fn, typename list&gt;
</span><span class='line'>    struct apply : cons &lt;
</span><span class='line'>        typename fn::template apply&lt;typename car&lt;list&gt;::type&gt;,
</span><span class='line'>        map_t::template apply&lt;fn, typename cdr&lt;list&gt;::type&gt;
</span><span class='line'>    &gt;{};
</span><span class='line'>
</span><span class='line'>    template &lt;typename fn&gt;
</span><span class='line'>    struct apply &lt;fn, empty&gt;: empty{};
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>template &lt;typename fn, typename list&gt;
</span><span class='line'>struct map : std::conditional &lt;
</span><span class='line'>    is_empty&lt;list&gt;::value,
</span><span class='line'>    list,
</span><span class='line'>    map_t::template apply&lt;fn, list&gt;
</span><span class='line'>    &gt;::type
</span><span class='line'>{};</span></code></pre></td></tr></table></div></figure>


<p>使用示例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>using m1 = map&lt;inc_t, list&lt;int, 1, 2, 3&gt;&gt;;
</span><span class='line'>using m2 = map&lt;inc_t, list&lt;int&gt;&gt;;
</span><span class='line'>print&lt;m1&gt;();    // 2, 3, 4
</span><span class='line'>print&lt;m2&gt;();</span></code></pre></td></tr></table></div></figure>


<p>为了让<code>map</code>支持形如<code>inc</code>这样的模板类，而不仅仅是形如<code>inc_t</code>，我们需要定义一个转换器：<code>lambda</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct apply_t {
</span><span class='line'>    template &lt;template &lt;typename...&gt; class F, typename ...args&gt;
</span><span class='line'>    struct apply : F&lt;typename args::type...&gt; {};
</span><span class='line'>
</span><span class='line'>    template &lt;template &lt;typename...&gt; class F&gt;
</span><span class='line'>    struct apply &lt;F, empty&gt; : empty {};
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>template &lt;template &lt;typename...&gt; class F, typename ...args&gt;
</span><span class='line'>struct apply : apply_t::template apply&lt;F, args...&gt; {};
</span><span class='line'>
</span><span class='line'>template &lt;template &lt;typename...&gt; class F&gt;
</span><span class='line'>struct lambda {
</span><span class='line'>    template &lt;typename ...args&gt;
</span><span class='line'>    struct apply : apply_t::template apply&lt;F, args...&gt; {};
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>使用示例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>std::cout &lt;&lt; lambda&lt;inc&gt;::template apply&lt;int_&lt;0&gt;&gt;::value &lt;&lt; std::endl;  // 1
</span><span class='line'>using ml1 = map&lt;lambda&lt;inc&gt;, list&lt;int, 1, 2, 3&gt;&gt;;
</span><span class='line'>print&lt;ml1&gt;();  // 2, 3, 4</span></code></pre></td></tr></table></div></figure>


<h2>transform的实现</h2>

<p><code>transform</code>的语义是对迭代地将某个方法作用于两个列表上的元素，然后得到结果<code>list</code>。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct transform_t {
</span><span class='line'>    template &lt;typename list1, typename list2, typename fn&gt;
</span><span class='line'>    struct apply : cons &lt;
</span><span class='line'>        typename fn::template apply&lt;
</span><span class='line'>            typename car&lt;list1&gt;::type, typename car&lt;list2&gt;::type&gt;::type,
</span><span class='line'>        typename transform_t::template apply &lt;
</span><span class='line'>            typename cdr&lt;list1&gt;::type, typename cdr&lt;list2&gt;::type, fn&gt;::type
</span><span class='line'>    &gt; {};
</span><span class='line'>
</span><span class='line'>    template &lt;typename list1, typename fn&gt;
</span><span class='line'>    struct apply&lt;list1, empty, fn&gt; : cons &lt;
</span><span class='line'>        typename fn::template apply&lt;typename car&lt;list1&gt;::type, empty&gt;,
</span><span class='line'>        typename transform_t::template apply &lt;typename cdr&lt;list1&gt;::type, empty, fn&gt;::type
</span><span class='line'>    &gt; {};
</span><span class='line'>
</span><span class='line'>    template &lt;typename list2, typename fn&gt;
</span><span class='line'>    struct apply&lt;empty, list2, fn&gt; : cons &lt;
</span><span class='line'>        typename fn::template apply&lt;empty, typename car&lt;list2&gt;::type&gt;::type,
</span><span class='line'>        typename transform_t::template apply &lt;empty, typename cdr&lt;list2&gt;::type, fn&gt;::type
</span><span class='line'>    &gt; {};
</span><span class='line'>
</span><span class='line'>    template &lt;typename fn&gt;
</span><span class='line'>    struct apply&lt;empty, empty, fn&gt; : empty {};
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>template &lt;typename list1, typename list2, typename fn&gt;
</span><span class='line'>struct transform : std::conditional &lt;
</span><span class='line'>    is_empty&lt;list1&gt;::value,
</span><span class='line'>    list1,
</span><span class='line'>    transform_t::template apply&lt;list1, list2, fn&gt;
</span><span class='line'>    &gt;::type
</span><span class='line'>{
</span><span class='line'>    static_assert(length&lt;list1&gt;::value == length&lt;list2&gt;::value, "transform: length of lists mismatch!");
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>其实现是最为复杂的，我们先来看使用示例，再来讲解实现细节。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>using t1 = list&lt;int, 1, 2, 3&gt;;
</span><span class='line'>using t2 = list&lt;int, 3, 2, 1&gt;;
</span><span class='line'>using ml = transform&lt;t1, t2, lambda&lt;minus&gt;&gt;;
</span><span class='line'>using pl = transform&lt;t1, t2, lambda&lt;plus&gt;&gt;;
</span><span class='line'>using te = transform&lt;list&lt;int&gt;, list&lt;int&gt;, lambda&lt;plus&gt;&gt;;
</span><span class='line'>using el = transform&lt;t1, list&lt;int&gt;, lambda&lt;plus&gt;&gt;;
</span><span class='line'>print&lt;ml&gt;();    // -2, 0, 2
</span><span class='line'>print&lt;pl&gt;();    // 4, 4, 4
</span><span class='line'>print&lt;te&gt;();
</span><span class='line'>// print&lt;el&gt;(); // assertion: length mismatch!</span></code></pre></td></tr></table></div></figure>


<p>实现细节：</p>

<ul>
<li>使用C++11新特性<code>static_assert</code>对两个列表的长度相等做断言；</li>
<li>使用<code>std::conditional</code>处理空列表，如果非空forward给<code>transform_t</code>；</li>
<li>对<code>transform_t</code>特化处理空列表的情况；</li>
<li>如果<code>list1</code>与<code>list2</code>均非空，那么通过<code>car</code>取出两个列表的<code>head</code>作用于方法，然后递归调用<code>transform_t</code>作用于两个列表的<code>tail</code>。</li>
</ul>


<h2>enumerate的实现</h2>

<p><code>enumerate</code>的语义是迭代将某个方法作用于列表元素。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;typename fn, typename list, bool is_empty&gt;
</span><span class='line'>struct enumerate_t;
</span><span class='line'>
</span><span class='line'>template &lt;typename fn, typename list&gt;
</span><span class='line'>void enumerate(fn f)
</span><span class='line'>{
</span><span class='line'>    enumerate_t&lt;fn, list, is_empty&lt;list&gt;::value&gt; impl;
</span><span class='line'>    impl(f);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>template &lt;typename fn, typename list, bool is_empty = false&gt;
</span><span class='line'>struct enumerate_t
</span><span class='line'>{
</span><span class='line'>    void operator()(fn f) {
</span><span class='line'>        f(car&lt;list&gt;::value);
</span><span class='line'>        enumerate&lt;fn, typename cdr&lt;list&gt;::type&gt;(f);
</span><span class='line'>    }
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>template &lt;typename fn, typename list&gt;
</span><span class='line'>struct enumerate_t&lt;fn, list, true&gt;
</span><span class='line'>{
</span><span class='line'>    void operator()(fn f) {
</span><span class='line'>        // nothing for empty
</span><span class='line'>    }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p><code>enumerate</code>的实现与之前的<code>map</code>的实现很不一样，它是通过模板方法与函数子来实现的。模板方法内部调用函数子来做事情，函数子又是一个模板类，并对空列表做了特化处理。</p>

<p>使用示例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>using value_type = typename car&lt;e1&gt;::value_type;
</span><span class='line'>auto sqr_print = [](value_type val) { std::cout &lt;&lt; val * val &lt;&lt; " "; };
</span><span class='line'>enumerate&lt;decltype(sqr_print), e1&gt;(sqr_print);      // 1 4 9</span></code></pre></td></tr></table></div></figure>


<h2>equal的实现</h2>

<p><code>equal</code>用于判断两个列表是否等价。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct equal_t {
</span><span class='line'>    // both lists are not empty
</span><span class='line'>    template &lt;typename list1, typename list2, int empty_value = 0,
</span><span class='line'>        typename pred = lambda&lt;std::is_same&gt;&gt;
</span><span class='line'>    struct apply : std::conditional &lt;
</span><span class='line'>        !pred::template apply &lt;
</span><span class='line'>            typename car&lt;list1&gt;::type,
</span><span class='line'>            typename car&lt;list2&gt;::type
</span><span class='line'>            &gt;::type::value,
</span><span class='line'>        bool_&lt;false&gt;,
</span><span class='line'>        typename equal_t::template apply &lt;
</span><span class='line'>            typename cdr&lt;list1&gt;::type,
</span><span class='line'>            typename cdr&lt;list2&gt;::type,
</span><span class='line'>            (is_empty&lt;typename cdr&lt;list1&gt;::type&gt;::value
</span><span class='line'>                + is_empty&lt;typename cdr&lt;list2&gt;::type&gt;::value),
</span><span class='line'>            pred
</span><span class='line'>        &gt;::type
</span><span class='line'>    &gt; {};
</span><span class='line'>
</span><span class='line'>    // one of the list is empty.
</span><span class='line'>    template &lt;typename list1, typename list2, typename pred&gt;
</span><span class='line'>    struct apply&lt;list1, list2, 1, pred&gt;: bool_&lt;false&gt;
</span><span class='line'>    {};
</span><span class='line'>
</span><span class='line'>    // both lists are empty.
</span><span class='line'>    template &lt;typename list1, typename list2, typename pred&gt;
</span><span class='line'>    struct apply&lt;list1, list2, 2, pred&gt;: bool_&lt;true&gt;
</span><span class='line'>    {};
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>template &lt;typename list1, typename list2, typename pred = lambda&lt;std::is_same&gt;&gt;
</span><span class='line'>struct equal : equal_t::template apply&lt;list1, list2,
</span><span class='line'>    (is_empty&lt;list1&gt;::value + is_empty&lt;list2&gt;::value), pred&gt;::type
</span><span class='line'>{};</span></code></pre></td></tr></table></div></figure>


<p><code>equal</code>的实现也有点复杂。</p>

<ul>
<li>pred是等价比较谓词，默认是使用<code>std::is_same</code>来做比较；</li>
<li>关键部分依然是通过<code>std::conditional</code>来实现的；</li>
<li>第一参数是判断两个列表的<code>head</code>是否相等；</li>
<li>如果不等就返回第二参数；</li>
<li>如果相等就递归比较两个列表的剩余元素；</li>
<li>这里使用了一个小小的技巧来简化模板类特化的情况：如果其中一个列表为空，那么<code>empty_value</code>为1；如果两个列表均为空，那么<code>empty_value</code>为2，这两种情况都会调用特化版本。</li>
</ul>


<p>使用示例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>using e1 = list&lt;int, 1, 2, 3&gt;;
</span><span class='line'>using e2 = list&lt;int, 1, 2, 3&gt;;
</span><span class='line'>using e3 = list&lt;int, 1, 2, 1&gt;;
</span><span class='line'>std::cout &lt;&lt; "equal&lt;e1, e2&gt; : " &lt;&lt; equal&lt;e1, e2&gt;::value &lt;&lt; std::endl;   // 1
</span><span class='line'>std::cout &lt;&lt; "equal&lt;e1, e3&gt; : " &lt;&lt; equal&lt;e1, e3&gt;::value &lt;&lt; std::endl;   // 0
</span><span class='line'>std::cout &lt;&lt; "equal&lt;e1, list&lt;int&gt;&gt; : " &lt;&lt; equal&lt;e1, list&lt;int&gt;&gt;::value &lt;&lt; std::endl; // 0
</span><span class='line'>std::cout &lt;&lt; "equal&lt;list&lt;int&gt;, e1&gt; : " &lt;&lt; equal&lt;list&lt;int&gt;, e1&gt;::value &lt;&lt; std::endl; // 0
</span><span class='line'>std::cout &lt;&lt; "equal&lt;list&lt;int&gt;, list&lt;int&gt;&gt; : " &lt;&lt; equal&lt;list&lt;int&gt;, list&lt;int&gt;&gt;::value &lt;&lt; std::endl;   // 1</span></code></pre></td></tr></table></div></figure>


<h2>print的实现</h2>

<p><code>print</code>是依次打印列表元素，也可以使用enumerate来实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;typename list, bool is_empty&gt;
</span><span class='line'>struct print_t;
</span><span class='line'>
</span><span class='line'>template &lt;typename list&gt;
</span><span class='line'>void print()
</span><span class='line'>{
</span><span class='line'>    print_t&lt;list, is_empty&lt;list&gt;::value&gt; impl;
</span><span class='line'>    impl();
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>template &lt;typename list, bool is_empty = true&gt;
</span><span class='line'>struct print_t
</span><span class='line'>{
</span><span class='line'>    void operator()() {
</span><span class='line'>        std::cout &lt;&lt; std::endl;
</span><span class='line'>    }
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>template &lt;typename list&gt;
</span><span class='line'>struct print_t&lt;list, false&gt;
</span><span class='line'>{
</span><span class='line'>    void operator()() {
</span><span class='line'>        std::cout &lt;&lt; car&lt;list&gt;::value;
</span><span class='line'>        using rest = typename cdr&lt;list&gt;::type;
</span><span class='line'>        if (false == is_empty&lt;rest&gt;::value) {
</span><span class='line'>            std::cout &lt;&lt; ", ";
</span><span class='line'>        }
</span><span class='line'>        print&lt;rest&gt;();
</span><span class='line'>    }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p><code>print</code>的实现思路与<code>enumerate</code>，是通过模板方法与函数子来实现的。模板方法内部调用函数子来做事情，函数子又是一个模板类，并对空列表做了特化处理。</p>

<h1>总结</h1>

<p>C++尤其是C++11，14，17等新特性使得这把实用的瑞士军刀越发锋利与实用，虽然实现的形式上不如<code>Scheme</code>、<code>Python</code>等优雅，但它确实能够，而且无需获得语言层面上的支持。纸上得来终觉浅，绝知此事要躬行。看过本文的读者不妨自己实现一番本文中的提到的相关概念。</p>

<h2>参考阅读</h2>

<p><a href="https://book.douban.com/subject/1148282/">《计算机程序的构造与解释》</a></p>
