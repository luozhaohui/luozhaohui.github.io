<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[标签：thread | 飘飘白云]]></title>
  <link href="http://luozhaohui.github.io/tags/thread/atom.xml" rel="self"/>
  <link href="http://luozhaohui.github.io/"/>
  <updated>2020-12-28T18:48:49+08:00</updated>
  <id>http://luozhaohui.github.io/</id>
  <author>
    <name><![CDATA[飘飘白云]]></name>
    <email><![CDATA[kesalin@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android多线程分析之五：使用AsyncTask异步下载图像]]></title>
    <link href="http://luozhaohui.github.io/blog/2014/07/19/android-thread-tutoria05/"/>
    <updated>2014-07-19T21:12:40+08:00</updated>
    <id>http://luozhaohui.github.io/blog/2014/07/19/android-thread-tutoria05</id>
    <content type="html"><![CDATA[<h2>引言</h2>

<p>在本系列文章的第一篇<a href="https://luozhaohui.github.io/blog/2014/07/08/android-thread-tutoria01/">Android多线程分析之一：使用Thread异步下载图像</a>中，曾演示了如何使用 <code>Thread</code> 来完成异步任务。<code>Android</code> 为了简化在 <code>UI</code> 线程中完成异步任务（毕竟 <code>UI</code> 线程是 <code>app</code> 最重要的线程），实现了一个名为 <code>AysncTask</code> 的模板类。使用 <code>AysncTask</code> 能够在异步任务进行的同时，将任务进度状态反馈给 <code>UI</code> 线程（如让 <code>UI</code> 线程更新进度条）。正是由于它与 <code>UI</code> 线程紧密相关，使用的时候要就有一些限制，<code>AysncTask</code> 必须在 <code>UI</code> 线程中创建，并在 <code>UI</code> 线程中启动（通过调用其 <code>execute()</code> 方法）；此外，<code>AysncTask</code> 设计的目的是用于一些耗时较短的任务，如果是耗时较长的任务不推荐使用 <code>AysncTask</code>。</p>

<p>可以用简化记忆 “三参数，四步骤” 来学习 <code>AysncTask</code>。 即带有三个模板参数 <code>Params</code>, <code>Progress</code>, <code>Result</code>，四个处理步骤：<code>onPreExecute</code>，<code>doInBackground</code>，<code>onProgressUpdate</code>，<code>onPostExecute</code>。</p>

<!--more-->


<h2>简介</h2>

<h2>三参数</h2>

<blockquote><p><code>Params</code> 是异步任务所需的参数类型，也即 <code>doInBackground(Params&hellip; params)</code> 方法的参数类型；<br/>
<code>Progress</code> 是指进度的参数类型，也即 <code>onProgressUpdate(Progress&hellip; values)</code> 方法的参数类型；<br/>
<code>Result</code> 是指任务完成返回的参数类型，也即 <code>onPostExecute(Result result)</code> 或 <code>onCancelled(Result result)</code> 方法的参数类型。</p></blockquote>

<p>如果某一个参数类型没有意义或没有被用到，传递 <code>void</code> 即可。</p>

<h3>四步骤</h3>

<blockquote><p><code>protected void onPreExecute()</code>：在 <code>UI</code> 线程中运行，在异步任务开始之前被执行，以便 <code>UI</code> 线程完成一些初始化动作，如将进度条清零；<br/>
<code>protected abstract Result doInBackground(Params&hellip; params)</code>：在后台线程中运行，这是完成异步任务的地方，它是抽象接口，子类必须提供实现；<br/>
<code>protected void onProgressUpdate(Progress&hellip; values)</code>：在 <code>UI</code> 线程中运行，在异步任务执行的过程中可以通过调用 <code>void publishProgress(Progress&hellip; values)</code> 方法通知 <code>UI</code> 线程在 <code>onProgressUpdate</code> 方法内更新进度状态；<br/>
<code>protected void onPostExecute(Result result)</code>：在 <code>UI</code> 线程中运行，当异步任务完成之后被执行，以便 <code>UI</code> 线程更新任务完成状态。</p></blockquote>

<p><code>AysncTask</code> 支持取消异步任务，当异步任务被取消之后，上面的步骤四就不会被执行了，取而代之将执行 <code>onCancelled(Result result)</code>，以便 <code>UI</code> 线程更新任务被取消之后的状态。谨记：上面提到的这些方法都是回调函数，不需要用户手动去调用。</p>

<p>以前的 <code>AysncTask</code> 是基于单一后台线程实现的，而从 <code>Android 3.0</code> 起 <code>AysncTask</code> 是基于 <code>Android</code> 的并发库（<code>java.util.concurrent</code>）实现的，本文中不会展开讨论其具体实现，只是演示如何使用 <code>AysncTask。</p>

<h2>使用示例</h2>

<p>有了前面的轮廓介绍，再来使用 <code>AysncTask</code> 是非常容易的，下面的例子与<a href="https://luozhaohui.github.io/blog/2014/07/08/android-thread-tutoria01/">Android多线程分析之一：使用Thread异步下载图像</a>中的例子非常相似，只不过是使用 <code>AysncTask</code> 来完成异步任务罢了。</p>

<h2>权限</h2>

<p>这是一个使用 <code>AysncTask</code> 从网络上异步下载图片并在 <code>ImageView</code> 中显示的的简单示例。因为需要访问网络，所以要在 <code>manifest.xml</code> 中添加网络访问权限：
<code>xml
    &lt;uses-permission android:name="android.permission.INTERNET"&gt;
    &lt;/uses-permission&gt;
</code></p>

<h3>布局</h3>

<p>布局文件很简单，一个 <code>Button</code>，一个 <code>ImageView</code>：</p>

<pre><code class="xml">&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:padding="10dip" &gt;

    &lt;Button
        android:id="@+id/LoadButton"
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:text="Load"&gt;
    &lt;/Button&gt;

    &lt;ImageView
        android:id="@+id/ImageVivew" 
        android:layout_width="match_parent" 
        android:layout_height="400dip" 
        android:scaleType="centerInside" 
        android:padding="2dp"&gt;
    &lt;/ImageView&gt; 

&lt;/LinearLayout&gt;
</code></pre>

<h3>代码：</h3>

<p>首先来看定义：图片的 <code>url</code> 路径，两个消息值以及一些控件：</p>

<pre><code class="java">    private static final String sImageUrl = "http://fashion.qqread.com/ArtImage/20110225/0083_13.jpg";
    private Button mLoadButton;
    private ImageView mImageView;
</code></pre>

<p>然后来看控件的设置：</p>

<pre><code class="java">    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        Log.i("UI thread", " &gt;&gt; onCreate()");

        mImageView = (ImageView)this.findViewById(R.id.ImageVivew);

        mLoadButton = (Button)this.findViewById(R.id.LoadButton);
        mLoadButton.setOnClickListener(new View.OnClickListener() {
            @Override 
            public void onClick(View v) {
                LoadImageTask task = new LoadImageTask(v.getContext());
                task.execute(sImageUrl);
            }
        });
    }
</code></pre>

<p><code>LoadImageTask</code> 继承自 <code>AysncTask</code>，由这个类去完成异步图片下载任务，并相应地更新 <code>UI</code> 状态。</p>

<pre><code class="java">    class LoadImageTask extends AsyncTask&lt;String, Integer, Bitmap&gt; 
    {
        private ProgressDialog mProgressBar;

        LoadImageTask(Context context)
        {
            mProgressBar = new ProgressDialog(context);
            mProgressBar.setCancelable(true);
            mProgressBar.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
            mProgressBar.setMax(100);
        }

        @Override
        protected Bitmap doInBackground(String... params) {
            Log.i("Load thread", " &gt;&gt; doInBackground()");

            Bitmap bitmap = null;

            try{
                publishProgress(10);
                Thread.sleep(1000);

                InputStream in = new java.net.URL(sImageUrl).openStream();
                publishProgress(60);
                Thread.sleep(1000);

                bitmap = BitmapFactory.decodeStream(in);
                in.close();
            } catch (Exception e) {
                e.printStackTrace();
            }

            publishProgress(100);
            return bitmap;
        }

        @Override
        protected void onCancelled() {
            super.onCancelled();
        }

        @Override
        protected void onPreExecute() {

            mProgressBar.setProgress(0);
            mProgressBar.setMessage("Image downloading ... %0");
            mProgressBar.show();

            Log.i("UI thread", " &gt;&gt; onPreExecute()");
        }

        @Override
        protected void onPostExecute(Bitmap result) {
            Log.i("UI thread", " &gt;&gt; onPostExecute()");
            if (result != null) {
                mProgressBar.setMessage("Image downloading success!");
                mImageView.setImageBitmap(result);
            }
            else {
                mProgressBar.setMessage("Image downloading failure!");
            }

            mProgressBar.dismiss(); 
        }

       @Override
        protected void onProgressUpdate(Integer... values) {
           Log.i("UI thread", " &gt;&gt; onProgressUpdate() %" + values[0]);
           mProgressBar.setMessage("Image downloading ... %" + values[0]);
           mProgressBar.setProgress(values[0]);
        }
    };
</code></pre>

<p>在 <code>LoadImageTask 中，前面提到的四个步骤都涉及到了：</p>

<p>首先在任务开始之前在 <code>onPreExecute()</code> 方法中设置进度条的初始状态（<code>UI</code>线程）；然后在下载线程中执行 <code>doInBackground()</code> 以完成下载任务，并在其中调用 <code>publishProgress()</code> 来通知 <code>UI</code> 线程更新进度状态；<code>UI</code> 线程在 <code>onProgressUpdate()</code> 中得知进度，并更新进度条（<code>UI线程</code>）；最后下载任务完成，<code>UI</code> 线程在 <code>onPostExecute()</code>中得知下载好的图像，并更新<code>UI</code>显示该图像（<code>UI</code>线程）。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android多线程分析之四：MessageQueue的实现]]></title>
    <link href="http://luozhaohui.github.io/blog/2014/07/12/android-thread-tutoria04/"/>
    <updated>2014-07-12T20:53:20+08:00</updated>
    <id>http://luozhaohui.github.io/blog/2014/07/12/android-thread-tutoria04</id>
    <content type="html"><![CDATA[<h2>引言</h2>

<p>在前面两篇文章<a href="https://luozhaohui.github.io/blog/2014/07/10/android-thread-tutoria02/">Android多线程分析之二：Thread的实现</a>，<a href="https://luozhaohui.github.io/blog/2014/07/12/android-thread-tutoria03/">Android多线程分析之三：Handler，Looper的实现</a>中分别介绍了 <code>Thread</code> 的创建，运行，销毁的过程以及 <code>Thread</code>与 <code>Handler</code>，<code>Looper</code> 之间的关联：<code>Thread</code> 在其 <code>run()</code> 方法中创建和运行消息处理循环 <code>Looper</code>，而 <code>Looper::loop()</code> 方法不断地从 <code>MessageQueue</code> 中获取消息，并由 <code>Handler</code> 分发处理该消息。接下来就来介绍 <code>MessageQueue</code> 的运作机制。</p>

<h2>参考源码：</h2>

<pre><code>android/framework/base/core/java/android/os/MessageQueue.java
android/framework/base/core/java/android/os/Message.java
android/frameworks/base/core/jni/android_os_MessageQueue.h
android/frameworks/base/core/jni/android_os_MessageQueue.cpp
</code></pre>

<!--more-->


<h2>构造函数及成员变量</h2>

<p>先来看 <code>MessageQueue</code> 的构造函数以及重要的成员变量：</p>

<pre><code class="java">    // True if the message queue can be quit.
    private final boolean mQuitAllowed;
    private int mPtr; // used by native code
    Message mMessages;
    private boolean mQuiting;
    // Indicates whether next() is blocked waiting in pollOnce() with a non-zero timeout.
    private boolean mBlocked;
</code></pre>

<p><code>mQuitAllowed</code>: 其含义与 <code>Looper.prepare(boolean quitAllowed)</code> 中参数含义一直，是否允许中止；
<code>mPtr</code>：<code>Android MessageQueue</code> 是通过调用 <code>C++ native MessageQueue</code> 实现的，这个 <code>mPtr</code> 就是指向 <code>native MessageQueue</code>；
<code>mMessages</code>：<code>Message</code> 是链表结构的，因此这个变量就代表 <code>Message</code> 链表；
<code>mQuiting</code>：是否终止了；
<code>mBlocked</code>：是否正在等待被激活以获取消息；</p>

<p><code>MessageQueue</code> 的构造函数很简单：</p>

<pre><code class="java">    MessageQueue(boolean quitAllowed) {
        mQuitAllowed = quitAllowed;
        nativeInit();
    }
</code></pre>

<p>它通过转调 <code>native</code> 方法 <code>nativeInit()</code> 实现的，后者是定义在 <code>android_os_MessageQueue.cpp</code>中：</p>

<pre><code class="cpp">static void android_os_MessageQueue_nativeInit(JNIEnv* env, jobject obj) {
    NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();
    if (!nativeMessageQueue) {
        jniThrowRuntimeException(env, "Unable to allocate native queue");
        return;
    }

    nativeMessageQueue-&gt;incStrong(env);
    android_os_MessageQueue_setNativeMessageQueue(env, obj, nativeMessageQueue);
}
static void android_os_MessageQueue_setNativeMessageQueue(JNIEnv* env, jobject messageQueueObj,
        NativeMessageQueue* nativeMessageQueue) {
    env-&gt;SetIntField(messageQueueObj, gMessageQueueClassInfo.mPtr,
             reinterpret_cast&lt;jint&gt;(nativeMessageQueue));
}
</code></pre>

<p><code>nativeInit()</code> 方法创建 <code>NativeMessageQueue</code> 对象，并将这个对象的指针复制给 <code>Android MessageQueue</code> 的 <code>mPtr</code>。<code>NativeMessageQueue</code> 的定义如下：</p>

<pre><code class="java">class MessageQueue : public RefBase {
public:
    /* Gets the message queue's looper. */
    inline sp&lt;Looper&gt; getLooper() const {
        return mLooper;
    }

    bool raiseAndClearException(JNIEnv* env, const char* msg);
    virtual void raiseException(JNIEnv* env, const char* msg, jthrowable exceptionObj) = 0;
protected:
    MessageQueue();
    virtual ~MessageQueue();
protected:
    sp&lt;Looper&gt; mLooper;
};

class NativeMessageQueue : public MessageQueue {
public:
    NativeMessageQueue();
    virtual ~NativeMessageQueue();
    virtual void raiseException(JNIEnv* env, const char* msg, jthrowable exceptionObj);
    void pollOnce(JNIEnv* env, int timeoutMillis);
    void wake();

private:
    bool mInCallback;
    jthrowable mExceptionObj;
};
</code></pre>

<h2>消息同步</h2>

<p>其中值得关注的是 <code>NativeMessageQueue</code> 的构造以及<code>pollOnce</code>，<code>wake</code> 两个方法，它们是<code>Java MessageQueue</code> 中 <code>nativePollOnce</code> 和 <code>nativeWake</code> 的 <code>native</code> 方法：</p>

<pre><code class="cpp">NativeMessageQueue::NativeMessageQueue() : mInCallback(false), mExceptionObj(NULL) {
    mLooper = Looper::getForThread();
    if (mLooper == NULL) {
        mLooper = new Looper(false);
        Looper::setForThread(mLooper);
    }
}

void NativeMessageQueue::pollOnce(JNIEnv* env, int timeoutMillis) {
    mInCallback = true;
    mLooper-&gt;pollOnce(timeoutMillis);
    mInCallback = false;
}

void NativeMessageQueue::wake() {
    mLooper-&gt;wake();
}
</code></pre>

<p>在 <code>NativeMessageQueue</code> 的构造函数中，会获取当前线程的 <code>Looper</code>(注意这是 <code>C++ Looper</code>,定义在<code>frameworks/native/libs/utils/Looper.h</code> 中)，如果当前线程还没有 <code>Looper</code>，就创建一个，并保存在线程的 <code>TLS</code> 中。<code>pollOnce</code> 和 <code>wake</code> 最终都是通过 <code>Linux</code> 的 <code>epoll</code> 模型来实现的。<code>pollOnce()</code> 通过等待被激活，然后从消息队列中获取消息；<code>wake()</code> 则是激活处于等待状态的消息队列，通知它有消息到达了。这是典型的生产者-消费者模型。</p>

<p>对于<code>Android MessageQueue</code> 来说，其主要的工作就是：接收投递进来的消息，获取下一个需要处理的消息。这两个功能是通过 <code>enqueueMessage()</code> 和 <code>next()</code> 方法实现的。<code>next()</code> 在前一篇文章介绍 <code>Looper.loop()</code> 时提到过。</p>

<h2>Message</h2>

<p>在分析这两个函数之前，先来介绍一下 <code>Message</code>：前面说过 <code>Message</code> 是完备的，即它同时带有消息内容和处理消息的 <code>Handler</code> 或 <code>callback</code>。下面列出它的主要成员变量：</p>

<pre><code class="cpp">public int what;     // 消息 id
public int arg1;     // 消息参数
public int arg2;     // 消息参数
public Object obj;   // 消息参数
long when;           // 处理延迟时间，由 Handler 的 sendMessageDelayed/postDelayed 设置
Handler target;    // 处理消息的 Handler
Runnable callback;   // 处理消息的回调
Message next;    // 链表结构，指向下一个消息
</code></pre>

<p><code>Message</code> 有一些名为 <code>obtain</code> 的静态方法用于创建 <code>Message</code>，通常我们都是通过 <code>Handler</code> 的 <code>obtain</code> 静态方法转调 <code>Message</code> 的静态方法来创建新的 <code>Message</code>。</p>

<p>接下来分析 <code>enqueueMessage()</code>enqueueMessage：
``` java
    final boolean enqueueMessage(Message msg, long when) {
        if (msg.isInUse()) {
            throw new AndroidRuntimeException(msg + &ldquo; This message is already in use.&rdquo;);
        }
        if (msg.target == null) {
            throw new AndroidRuntimeException(&ldquo;Message must have a target.&rdquo;);
        }</p>

<pre><code>    boolean needWake;
    synchronized (this) {
        if (mQuiting) {
            return false;
        }

        msg.when = when;
        Message p = mMessages;
        if (p == null || when == 0 || when &lt; p.when) {
            // New head, wake up the event queue if blocked.
            msg.next = p;
            mMessages = msg;
            needWake = mBlocked;
        } else {
            // Inserted within the middle of the queue.  Usually we don't have to wake
            // up the event queue unless there is a barrier at the head of the queue
            // and the message is the earliest asynchronous message in the queue.
            needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();
            Message prev;
            for (;;) {
                prev = p;
                p = p.next;
                if (p == null || when &lt; p.when) {
                    break;
                }
                if (needWake &amp;&amp; p.isAsynchronous()) {
                    needWake = false;
                }
            }
            msg.next = p; // invariant: p == prev.next
            prev.next = msg;
        }
    }
    if (needWake) {
        nativeWake(mPtr);
    }
    return true;
}
</code></pre>

<pre><code>
首先检测消息的合法性：是否已经在处理中和是否有处理它的 &lt;code&gt;Handler&lt;/code&gt;，然后判断 &lt;code&gt;mQuiting&lt;/code&gt; 是否中止了，如果没有则根据消息处理时间排序将消息插入链表中的合适位置。在这其中作了一些减少同步操作的优化，即使当前消息队列已经处于 &lt;code&gt;Blocked&lt;/code&gt; 状态，且队首是一个消息屏障(和内存屏障的理念一样，这里是通过 &lt;code&gt;p.target == null&lt;/code&gt; 来判断队首是否是消息屏障)，并且要插入的消息是所有异步消息中最早要处理的才会 &lt;code&gt;needwake&lt;/code&gt; 激活消息队列去获取下一个消息。&lt;code&gt;Handler&lt;/code&gt; 的 &lt;code&gt;post/sendMessage&lt;/code&gt; 系列方法最后都是通过转调 &lt;code&gt;MessageQueue&lt;/code&gt; 的 &lt;code&gt;enqueueMessage&lt;/code&gt; 来实现的，比如：
</code></pre>

<pre><code>public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
    MessageQueue queue = mQueue;
    if (queue == null) {
        RuntimeException e = new RuntimeException(
                this + " sendMessageAtTime() called with no mQueue");
        Log.w("Looper", e.getMessage(), e);
        return false;
    }
    return enqueueMessage(queue, msg, uptimeMillis);
}

private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
    msg.target = this;
    if (mAsynchronous) {
        msg.setAsynchronous(true);
    }
    return queue.enqueueMessage(msg, uptimeMillis);
}
</code></pre>

<pre><code>
其实 &lt;code&gt;Handler&lt;/code&gt; 中与 &lt;code&gt;Message&lt;/code&gt; 相关的静态方法都是通过 &lt;code&gt;MessageQueue&lt;/code&gt; 的对应的静态方法实现的，比如 &lt;code&gt;removeMessages&lt;/code&gt;, &lt;code&gt;hasMessages&lt;/code&gt;, &lt;code&gt;hasCallbacks&lt;/code&gt; 等等，这里就不一一详述了。至此，已经完整地分析了如何通过 &lt;code&gt;Handler&lt;/code&gt; 提交消息到 &lt;code&gt;MessageQueue&lt;/code&gt; 中了。

## 获取消息
下面来分析如何从 &lt;code&gt;MessageQueue&lt;/code&gt; 中获取合适的消息, 这是 &lt;code&gt;next()&lt;/code&gt; 要做的最主要的事情，&lt;code&gt;next()&lt;/code&gt; 方法还做了其他一些事情，这些其它事情是为了提高系统效果，利用消息队列在空闲时通过 &lt;code&gt;idle handler&lt;/code&gt; 做一些事情，比如 &lt;code&gt;gc&lt;/code&gt; 等等。但它们和获取消息关系不大，所以这部分将从略介绍。
</code></pre>

<p>   final Message next() {
        int pendingIdleHandlerCount = -1; // -1 only during first iteration
        int nextPollTimeoutMillis = 0;</p>

<pre><code>    for (;;) {
        if (nextPollTimeoutMillis != 0) {
            Binder.flushPendingCommands();
        }
        nativePollOnce(mPtr, nextPollTimeoutMillis);

        synchronized (this) {
            if (mQuiting) {
                return null;
            }

            // Try to retrieve the next message.  Return if found.
            final long now = SystemClock.uptimeMillis();
            Message prevMsg = null;
            Message msg = mMessages;
            if (msg != null &amp;&amp; msg.target == null) {
                // Stalled by a barrier.  Find the next asynchronous message in the queue.
                do {
                    prevMsg = msg;
                    msg = msg.next;
                } while (msg != null &amp;&amp; !msg.isAsynchronous());
            }
            if (msg != null) {
                if (now &lt; msg.when) {
                    // Next message is not ready.  Set a timeout to wake up when it is ready.
                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                } else {
                    // Got a message.
                    mBlocked = false;
                    if (prevMsg != null) {
                        prevMsg.next = msg.next;
                    } else {
                        mMessages = msg.next;
                    }
                    msg.next = null;
                    if (false) Log.v("MessageQueue", "Returning message: " + msg);
                    msg.markInUse();
                    return msg;
                }
            } else {
                // No more messages.
                nextPollTimeoutMillis = -1;
            }

            // If first time idle, then get the number of idlers to run.
            // Idle handles only run if the queue is empty or if the first message
            // in the queue (possibly a barrier) is due to be handled in the future.
            if (pendingIdleHandlerCount &lt; 0
                    &amp;&amp; (mMessages == null || now &lt; mMessages.when)) {
                pendingIdleHandlerCount = mIdleHandlers.size();
            }
            if (pendingIdleHandlerCount &lt;= 0) {
                // No idle handlers to run.  Loop and wait some more.
                mBlocked = true;
                continue;
            }

            if (mPendingIdleHandlers == null) {
                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
            }
            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
        }

        // Run the idle handlers.
        // We only ever reach this code block during the first iteration.
        for (int i = 0; i &lt; pendingIdleHandlerCount; i++) {
            final IdleHandler idler = mPendingIdleHandlers[i];
            mPendingIdleHandlers[i] = null; // release the reference to the handler

            boolean keep = false;
            try {
                keep = idler.queueIdle();
            } catch (Throwable t) {
                Log.wtf("MessageQueue", "IdleHandler threw exception", t);
            }

            if (!keep) {
                synchronized (this) {
                    mIdleHandlers.remove(idler);
                }
            }
        }

        // Reset the idle handler count to 0 so we do not run them again.
        pendingIdleHandlerCount = 0;

        // While calling an idle handler, a new message could have been delivered
        // so go back and look again for a pending message without waiting.
        nextPollTimeoutMillis = 0;
    }
}
</code></pre>

<pre><code>
队列被激活之后，首先判断队首是不是消息屏障，如果是则跳过所有的同步消息，查找最先要处理的异步消息。如果第一个待处理的消息还没有到要处理的时机则设置激活等待时间；否则这个消息就是需要处理的消息，将该消息设置为 &lt;code&gt;inuse&lt;/code&gt;，并将队列设置为非  &lt;code&gt;blocked&lt;/code&gt; 状态，然后返回该消息。&lt;code&gt;next()&lt;/code&gt; 方法是在  &lt;code&gt;Looper.loop()&lt;/code&gt; 中被调用的，&lt;code&gt;Looper&lt;/code&gt; 在获得要处理的消息之后就会调用和消息关联的 &lt;code&gt;Handler&lt;/code&gt; 来分发消息，这里再回顾一下：
</code></pre>

<p>  public static void loop() {
        final Looper me = myLooper();
        if (me == null) {
            throw new RuntimeException(&ldquo;No Looper; Looper.prepare() wasn&rsquo;t called on this thread.&rdquo;);
        }
        final MessageQueue queue = me.mQueue;
        &hellip;
        for (;;) {
            Message msg = queue.next(); // might block
            if (msg == null) {
                // No message indicates that the message queue is quitting.
                return;
            }</p>

<pre><code>        msg.target.dispatchMessage(msg);

        msg.recycle();
    }
}
</code></pre>

<p>```</p>

<p>如果队列中没有消息或者第一个待处理的消息时机未到，且也没有其他利用队列空闲要处理的事务，则将队列设置为设置 <code>blocked</code> 状态，进入等待状态；否则就利用队列空闲处理其它事务。</p>

<p>至此，已经对 <code>Android</code> 多线程相关的主要概念 <code>Thread</code>, <code>HandlerThread</code>, <code>Handler</code>, <code>Looper</code>, <code>Message</code>, <code>MessageQueue</code> 作了一番介绍，下一篇就要讲讲 <code>AsyncTask</code>，这是为了简化 <code>UI</code> 多线程编程为提供的一个便利工具类。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android多线程分析之三：Handler，Looper的实现]]></title>
    <link href="http://luozhaohui.github.io/blog/2014/07/12/android-thread-tutoria03/"/>
    <updated>2014-07-12T20:53:20+08:00</updated>
    <id>http://luozhaohui.github.io/blog/2014/07/12/android-thread-tutoria03</id>
    <content type="html"><![CDATA[<h2>引言</h2>

<p>在前文<a href="https://luozhaohui.github.io/blog/2014/07/10/android-thread-tutoria02/">Android多线程分析之二：Thread的实现</a>中已经详细分析了<code>Android Thread</code> 是如何创建，运行以及销毁的，其重点是对相应 <code>native</code> 方法进行分析，今天我将聚焦于 <code>Android Framework</code> 层多线程相关的类：<code>Handler</code>, <code>Looper</code>, <code>MessageQueue</code>, <code>Message</code> 以及它们与<code>Thread</code> 之间的关系。可以用一个不太妥当的比喻来形容它们之间的关联：如果把 <code>Thread</code> 比作生产车间，那么 <code>Looper</code> 就是放在这车间里的生产线，这条生产线源源不断地从 <code>MessageQueue</code> 中获取材料 <code>Messsage</code>，并分发处理 <code>Message</code> (由于 <code>Message</code> 通常是完备的，所以 <code>Looper</code> 大多数情况下只是调度让 <code>Message</code> 的 <code>Handler</code> 去处理 <code>Message</code>)。正是因为消息需要在 <code>Looper</code> 中处理，而 <code>Looper</code> 又需运行在 <code>Thread</code> 中，所以不能随随便便在非 <code>UI</code> 线程中进行 <code>UI</code> 操作。 <code>UI</code> 操作通常会通过投递消息来实现，只有往正确的 <code>Looper</code> 投递消息才能得到处理，对于 <code>UI</code> 来说，这个 <code>Looper</code> 一定是运行在 <code>UI</code> 线程中。</p>

<!--more-->


<h2>示例</h2>

<p>在编写 <code>app</code> 的过程中，我们常常会这样来使用 <code>Handler</code>：</p>

<pre><code class="java">Handler mHandler = new Handler();
mHandler.post(new Runnable(){
    @Override
    public void run() {
        // do somework
    }
});
</code></pre>

<p>或者如这系列文章<a href="https://luozhaohui.github.io/blog/2014/07/08/android-thread-tutoria01/">Android多线程分析之一：使用Thread异步下载图像</a>中的示例那样：</p>

<pre><code class="java">    private Handler mHandler= new Handler(){
        @Override
        public void handleMessage(Message msg) {
            Log.i("UI thread", " &gt;&gt; handleMessage()");

            switch(msg.what){
            case MSG_LOAD_SUCCESS:
                Bitmap bitmap = (Bitmap) msg.obj;
                mImageView.setImageBitmap(bitmap);

                mProgressBar.setProgress(100);
                mProgressBar.setMessage("Image downloading success!");
                mProgressBar.dismiss();
                break;

            case MSG_LOAD_FAILURE:
                mProgressBar.setMessage("Image downloading failure!");
                mProgressBar.dismiss();
                break;
            }
        }
    };

    Message msg = mHandler.obtainMessage(MSG_LOAD_FAILURE, null);
    mHandler.sendMessage(msg);
</code></pre>

<h2>Handler</h2>

<p>那么，在 <code>Handler</code> 的 <code>post/sendMessage</code> 背后到底发生了什么事情呢？下面就来解开这个谜团。
首先我们从 <code>Handler</code> 的构造函数开始分析：</p>

<pre><code class="java">    final MessageQueue mQueue; 
    final Looper mLooper; 
    final Callback mCallback; 
    final boolean mAsynchronous;

    public Handler(Looper looper, Callback callback, boolean async) {
        mLooper = looper;
        mQueue = looper.mQueue;
        mCallback = callback;
        mAsynchronous = async;
    }

    public Handler(Callback callback, boolean async) {
        mLooper = Looper.myLooper();
        if (mLooper == null) {
            throw new RuntimeException(
                "Can't create handler inside thread that has not called Looper.prepare()");
        }
        mQueue = mLooper.mQueue;
        mCallback = callback;
        mAsynchronous = async;
    }

    public Handler() {
        this(null, false);
    }
</code></pre>

<p>上面列出了 <code>Handler</code> 的一些成员变量：</p>

<blockquote><p><code>mLooper</code>：线程的消息处理循环，注意：并非每一个线程都有消息处理循环，因此 <code>Framework</code> 中线程可以分为两种：有 <code>Looper</code> 的和无 <code>Looper</code> 的。为了方便 <code>app</code> 开发，<code>Framework</code> 提供了一个有 <code>Looper</code> 的 <code>Thread</code> 实现：<code>HandlerThread</code>。在前一篇<a href="https://luozhaohui.github.io/blog/2014/07/10/android-thread-tutoria02/">Android多线程分析之二：Thread的实现</a>中也提到了两种不同 <code>Thread</code> 的 <code>run()</code> 方法的区别。</p></blockquote>

<pre><code class="java">/**
 * Handy class for starting a new thread that has a looper. The looper can then be 
 * used to create handler classes. Note that start() must still be called.
 */
public class HandlerThread extends Thread {
    Looper mLooper;
    /**
     * Call back method that can be explicitly overridden if needed to execute some
     * setup before Looper loops.
     */
    protected void onLooperPrepared() {
    }

    public void run() {
        mTid = Process.myTid();
        Looper.prepare();
        synchronized (this) {
            mLooper = Looper.myLooper();
            notifyAll();
        }
        Process.setThreadPriority(mPriority);
        onLooperPrepared();
        Looper.loop();
        mTid = -1;
    }

    /**
     * This method returns the Looper associated with this thread. If this thread not been started
     * or for any reason is isAlive() returns false, this method will return null. If this thread 
     * has been started, this method will block until the looper has been initialized.  
     * @return The looper.
     */
    public Looper getLooper() {
        if (!isAlive()) {
            return null;
        }

        // If the thread has been started, wait until the looper has been created.
        synchronized (this) {
            while (isAlive() &amp;&amp; mLooper == null) {
                try {
                    wait();
                } catch (InterruptedException e) {
                }
            }
        }
        return mLooper;
    }
}
</code></pre>

<h2>Looper</h2>

<p>这个 <code>HandlerThread</code> 与 <code>Thread</code> 相比，多了一个类型为 <code>Looper</code> 成员变量 <code>mLooper</code>，它是在 <code>run()</code> 函数中由 <code>Looper::prepare()</code> 创建的，并保存在 <code>TLS</code> 中：</p>

<pre><code class="java">/** Initialize the current thread as a looper.
      * This gives you a chance to create handlers that then reference
      * this looper, before actually starting the loop. Be sure to call
      * {@link #loop()} after calling this method, and end it by calling
      * {@link #quit()}.
      */
    public static void prepare() {
        prepare(true);
    }

    private static void prepare(boolean quitAllowed) {
        if (sThreadLocal.get() != null) {
            throw new RuntimeException("Only one Looper may be created per thread");
        }
        sThreadLocal.set(new Looper(quitAllowed));
    }
</code></pre>

<p>然后通过 <code>Looper::myLooper()</code> 获取创建的 <code>Looper</code>：</p>

<pre><code class="java">    /**
     * Return the Looper object associated with the current thread.  Returns
     * null if the calling thread is not associated with a Looper.
     */
    public static Looper myLooper() {
        return sThreadLocal.get();
    }
</code></pre>

<p>最后通过 <code>Looper::Loop()</code> 方法运行消息处理循环：从 <code>MessageQueue</code> 中取出消息，并分发处理该消息，不断地循环这个过程。这个方法将在后面介绍。</p>

<blockquote><p><code>Handler</code> 的成员变量 <code>mQueue</code> 是其成员变量 <code>mLooper</code> 的成员变量，这里只是为了简化书写，单独拿出来作为 <code>Handler</code> 的成员变量；成员变量 <code>mCallback</code> 提供了另一种使用<code>Handler</code> 的简便途径：只需实现回调接口 <code>Callback</code>，而无需子类化<code>Handler</code>，下面会讲到的：</p></blockquote>

<pre><code class="java">    /**
     * Callback interface you can use when instantiating a Handler to avoid
     * having to implement your own subclass of Handler.
     */
    public interface Callback {
        public boolean handleMessage(Message msg);
    }
</code></pre>

<p>成员变量 <code>mAsynchronous</code> 是标识是否异步处理消息，如果是的话，通过该 <code>Handler obtain</code> 得到的消息都被强制设置为异步的。
同是否有无 <code>Looper</code> 来区分 <code>Thread</code> 一样，<code>Handler</code> 的构造函数也分为自带 <code>Looper</code> 和外部 <code>Looper</code> 两大类：如果提供了 <code>Looper</code>，在消息会在该 <code>Looper</code> 中处理，否则消息就会在当前线程的 <code>Looper</code> 中处理，注意这里要确保当前线程一定有 <code>Looper</code>。所有的 <code>UI thread</code> 都是有 <code>Looper</code> 的，因为 <code>view/widget</code> 的实现中大量使用了消息，需要 <code>UI thread</code> 提供 <code>Looper</code> 来处理，可以参考<code>view.java</code>：</p>

<p>view.java
<code>java
    public boolean post(Runnable action) {
        final AttachInfo attachInfo = mAttachInfo;
        if (attachInfo != null) {
            return attachInfo.mHandler.post(action);
        }
        // Assume that post will succeed later
        ViewRootImpl.getRunQueue().post(action);
        return true;
    }
</code></p>

<p>ViewRootImpl.java</p>

<pre><code class="java">    private void performTraversals() {
        ....
        // Execute enqueued actions on every traversal in case a detached view enqueued an action
        getRunQueue().executeActions(attachInfo.mHandler);
      ...
    }

    static RunQueue getRunQueue() {
        RunQueue rq = sRunQueues.get();
        if (rq != null) {
            return rq;
        }
        rq = new RunQueue();
        sRunQueues.set(rq);
        return rq;
    }

    /**
     * The run queue is used to enqueue pending work from Views when no Handler is
     * attached.  The work is executed during the next call to performTraversals on
     * the thread.
     * @hide
     */
    static final class RunQueue {
    ...
        void executeActions(Handler handler) {
            synchronized (mActions) {
                final ArrayList&lt;HandlerAction&gt; actions = mActions;
                final int count = actions.size();

                for (int i = 0; i &lt; count; i++) {
                    final HandlerAction handlerAction = actions.get(i);
                    handler.postDelayed(handlerAction.action, handlerAction.delay);
                }

                actions.clear();
            }
        }
    }
</code></pre>

<p>从上面的代码可以看出，作为所有控件基类的 <code>view</code> 提供了 <code>post</code> 方法，用于向 <code>UI thread</code> 发送消息，并在 <code>UI thread</code> 的 <code>Looper</code> 中处理这些消息，而 <code>UI thread</code> 一定有 <code>Looper</code> 这是由 <code>ActivityThread</code> 来保证的：</p>

<pre><code class="java">public final class ActivityThread {
...
    final Looper mLooper = Looper.myLooper();
}
</code></pre>

<p><code>UI</code> 操作需要向 <code>UI</code> 线程发送消息并在其 <code>Looper</code> 中处理这些消息。这就是为什么我们不能在非 <code>UI</code> 线程中更新 <code>UI</code> 的原因，在控件在非 <code>UI</code> 线程中构造 <code>Handler</code> 时，要么由于非 <code>UI</code> 线程没有 <code>Looper</code> 使得获取 <code>myLooper</code> 失败而抛出 <code>RunTimeException</code>，要么即便提供了 <code>Looper</code>，但这个 <code>Looper</code> 并非 <code>UI</code> 线程的 <code>Looper</code> 而不能处理控件消息。为此在 <code>ViewRootImpl</code> 中有一个强制检测 <code>UI</code> 操作是否是在 <code>UI</code> 线程中处理的方法 <code>checkThread()</code>：该方法中的 <code>mThread</code> 是在 <code>ViewRootImpl</code> 的构造函数中赋值的，它就是 <code>UI</code> 线程；该方法中的 <code>Thread.currentThread()</code> 是当前进行 <code>UI</code> 操作的线程，如果这个线程不是非 <code>UI</code> 线程就会抛出异常<code>CalledFromWrongThreadException</code>。</p>

<pre><code class="java">    void checkThread() {
        if (mThread != Thread.currentThread()) {
            throw new CalledFromWrongThreadException(
                    "Only the original thread that created a view hierarchy can touch its views.");
        }
    }
</code></pre>

<p>如果修改<a href="https://luozhaohui.github.io/blog/2014/07/08/android-thread-tutoria01/">Android多线程分析之一：使用Thread异步下载图像</a>中示例，下载完图像 <code>bitmap</code> 之后，在 <code>Thread</code> 的 <code>run()</code> 函数中设置 <code>ImageView</code> 的图像为该 <code>bitmap</code>，即会抛出上面提到的异常：</p>

<pre><code>W/dalvikvm(796): threadid=11: thread exiting with uncaught exception (group=0x40a71930)
E/AndroidRuntime(796): FATAL EXCEPTION: Thread-75
E/AndroidRuntime(796): android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.
E/AndroidRuntime(796):  at android.view.ViewRootImpl.checkThread(ViewRootImpl.java:4746)
E/AndroidRuntime(796):  at android.view.ViewRootImpl.requestLayout(ViewRootImpl.java:823)
E/AndroidRuntime(796):  at android.view.View.requestLayout(View.java:15473)
E/AndroidRuntime(796):  at android.view.View.requestLayout(View.java:15473)
E/AndroidRuntime(796):  at android.view.View.requestLayout(View.java:15473)
E/AndroidRuntime(796):  at android.view.View.requestLayout(View.java:15473)
E/AndroidRuntime(796):  at android.view.View.requestLayout(View.java:15473)
E/AndroidRuntime(796):  at android.widget.ImageView.setImageDrawable(ImageView.java:406)
E/AndroidRuntime(796):  at android.widget.ImageView.setImageBitmap(ImageView.java:421)
E/AndroidRuntime(796):  at com.example.thread01.MainActivity$2$1.run(MainActivity.java:80)
</code></pre>

<h2>处理消息</h2>

<p><code>Handler</code> 的构造函数暂且介绍到这里，接下来介绍：<code>handleMessage</code> 和 <code>dispatchMessage</code>：</p>

<pre><code class="java">/**
     * Subclasses must implement this to receive messages.
     */
    public void handleMessage(Message msg) {
    }

    /**
     * Handle system messages here.
     */
    public void dispatchMessage(Message msg) {
        if (msg.callback != null) {
            handleCallback(msg);
        } else {
            if (mCallback != null) {
                if (mCallback.handleMessage(msg)) {
                    return;
                }
            }
            handleMessage(msg);
        }
    }
</code></pre>

<p>前面提到有两种方式来设置处理消息的代码：一种是设置 <code>Callback</code> 回调，一种是子类化 <code>Handler</code>。而子类化 <code>Handler</code> 其子类就要实现 <code>handleMessage</code> 来处理自定义的消息，如前面的匿名子类示例一样。<code>dispatchMessage</code> 是在 <code>Looper::Loop()</code> 中被调用，即它是在线程的消息处理循环中被调用，这样就能让 <code>Handler</code> 不断地处理各种消息。在 <code>dispatchMessage</code> 的实现中可以看到，如果 <code>Message</code> 有自己的消息处理回调，那么就优先调用消息自己的消息处理回调：</p>

<pre><code class="java">    private static void handleCallback(Message message) {
        message.callback.run();
    }
</code></pre>

<p>否则看 <code>Handler</code> 是否有消息处理回调 <code>mCallback</code>，如果有且 <code>mCallback</code> 成功处理了这个消息就返回了，否则就调用 <code>handleMessage</code>（通常是子类的实现） 来处理消息。</p>

<p>在分析 <code>Looper::Loop()</code> 这个关键函数之前，先来理一理 <code>Thread，Looper，Handler，MessageQueue</code> 的关系：<code>Thread</code> 需要有 <code>Looper</code> 才能处理消息（也就是说 <code>Looper</code> 是运行在 <code>Thread</code> 中），这是通过在自定义 <code>Thread</code> 的 <code>run()</code> 函数中调用 <code>Looper::prepare()</code> 和 <code>Looper::loop()</code> 来实现，然后在 <code>Looper::loop()</code> 中不断地从 <code>MessageQueue</code> 获取由 <code>Handler</code> 投递到其中的 <code>Message</code>，并调用 <code>Message</code> 的成员变量 <code>Handler</code> 的 <code>dispatchMessage</code> 来处理消息。</p>

<p>下面先来看看 <code>Looper</code> 的构造函数：</p>

<pre><code class="java">    final MessageQueue mQueue;
    final Thread mThread;
    volatile boolean mRun;

    private Looper(boolean quitAllowed) {
        mQueue = new MessageQueue(quitAllowed);
        mRun = true;
        mThread = Thread.currentThread();
    }
</code></pre>

<p><code>Looper</code> 的构造函数很简单，创建 <code>MessageQueue</code>，保存当前线程到 <code>mThread</code> 中。但它是私有的，只能通过两个静态函数 <code>prepare()</code>/<code>prepareMainLooper()</code> 来调用，前面已经介绍了 <code>prepare()</code>,下面来介绍 <code>prepareMainLooper()</code>:</p>

<pre><code class="java">/**
     * Initialize the current thread as a looper, marking it as an
     * application's main looper. The main looper for your application
     * is created by the Android environment, so you should never need
     * to call this function yourself.  See also: {@link #prepare()}
     */
    public static void prepareMainLooper() {
        prepare(false);
        synchronized (Looper.class) {
            if (sMainLooper != null) {
                throw new IllegalStateException("The main Looper has already been prepared.");
            }
            sMainLooper = myLooper();
        }
    }
</code></pre>

<p><code>prepareMainLooper</code> 是通过调用 <code>prepare</code> 实现的，不过传入的参数为 <code>false</code>，表示 <code>main Looper</code> 不允许中途被中止，创建之后将 <code>looper</code> 保持在静态变量 <code>sMainLooper</code> 中。整个 <code>Framework</code> 框架只有两个地方调用了 <code>prepareMainLooper</code> 方法：</p>

<h3>ServerThread</h3>

<p><code>SystemServer.java</code> 中的 <code>ServerThread</code>，<code>ServerThread</code> 的重要性就不用说了，绝大部分 <code>Android Service</code> 都是这个线程中初始化的。这个线程是在 <code>Android</code> 启动过程中的 <code>init2()</code> 方法启动的：</p>

<pre><code class="java">    public static final void init2() {
        Slog.i(TAG, "Entered the Android system server!");
        Thread thr = new ServerThread();
        thr.setName("android.server.ServerThread");
        thr.start();
    }

class ServerThread extends Thread {
    @Override
    public void run() {
        ...
        Looper.prepareMainLooper();
        ...
        Looper.loop();
        Slog.d(TAG, "System ServerThread is exiting!");
    }
}
</code></pre>

<h3>ActivityThread</h3>

<p>以及 <code>ActivityThread.java</code> 的 <code>main()</code> 方法：</p>

<pre><code class="java">public static void main(String[] args) {
        ....
        Looper.prepareMainLooper();

        ActivityThread thread = new ActivityThread();
        thread.attach(false);

        if (sMainThreadHandler == null) {
            sMainThreadHandler = thread.getHandler();
        }

        AsyncTask.init();

        Looper.loop();

        throw new RuntimeException("Main thread loop unexpectedly exited");
    }
</code></pre>

<p><code>ActivityThread</code> 的重要性也不言而喻，它是 <code>Activity</code> 的主线程，也就是 <code>UI</code> 线程。注意这里的 <code>AsyncTask.init()</code>，在后面介绍 <code>AsyncTask</code> 时会详细介绍的，这里只提一下：<code>AsyncTask</code> 能够进行 <code>UI</code> 操作正是由于在这里调用了 <code>init()</code>。</p>

<h2>Looper::Loop()</h2>

<p>有了前面的铺垫，这下我们就可以来分析 <code>Looper::Loop()</code> 这个关键函数了：</p>

<pre><code class="java">/**
     * Run the message queue in this thread. Be sure to call
     * {@link #quit()} to end the loop.
     */
    public static void loop() {
        final Looper me = myLooper();
        if (me == null) {
            throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");
        }
        final MessageQueue queue = me.mQueue;
        ...
        for (;;) {
            Message msg = queue.next(); // might block
            if (msg == null) {
                // No message indicates that the message queue is quitting.
                return;
            }

            msg.target.dispatchMessage(msg);

            msg.recycle();
        }
    }
</code></pre>

<p><code>loop()</code> 的实现非常简单，一如前面一再说过的那样：不断地从 <code>MessageQueue</code> 中获取消息，分发消息，回收消息。从上面的代码可以看出: <code>loop()</code> 仅仅是一个不断循环作业的生产流水线，而 <code>MessageQueue</code> 则为它提供原材料 <code>Message</code>，让它去分发处理。至于 <code>Handler</code> 是怎么提交消息到 <code>MessageQueue</code> 中，<code>MessageQueue</code> 又是怎么管理消息的，且待下文分解。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android多线程分析之二：Thread的实现]]></title>
    <link href="http://luozhaohui.github.io/blog/2014/07/10/android-thread-tutoria02/"/>
    <updated>2014-07-10T21:21:40+08:00</updated>
    <id>http://luozhaohui.github.io/blog/2014/07/10/android-thread-tutoria02</id>
    <content type="html"><![CDATA[<h2>引言</h2>

<p>在前文<a href="https://luozhaohui.github.io/blog/2014/07/08/android-thread-tutoria01/">Android多线程分析之一：使用Thread异步下载图像</a>中演示了如何使用<code>Thread</code>处理异步事务。示例中这个<code>Java Thread</code>类都是位于<code>Framework</code>层的类，它自身是通过<code>JNI</code>转调<code>dalvik</code>里面的<code>Thread</code>相关方法实现的。因此要分析<code>Andriod</code> 中的线程，就需要分析这两层中的与线程相关的代码，这就是本文要探讨的主题。本文将把<code>Framework</code>层中的<code>Java Thread</code>称为<code>Android Thread</code>，而把<code>dalvik</code>中的 <code>Thread</code>成为<code>dalvik Thread</code>。</p>

<!--more-->


<h2>源码路径</h2>

<p>本文涉及到的 <code>Android</code> 源码路径：
<code>
android/libcore/luni/src/main/java/java/lang/Runnable.java
android/libcore/luni/src/main/java/java/lang/Thread.java
android/libcore/luni/src/main/java/java/lang/ThreadGroup.java
android/libcore/luni/src/main/java/java/lang/VMThread.java
android/dalvik/vm/native/java_lang_VMThread.cpp
android/dalvik/vm/Thread.cpp
</code></p>

<h2>Android Thread</h2>

<p>首先来分析<code>Android Thread</code>，这个类的源码在<code>android/libcore/luni/src/main/java/java/lang/Thread.java</code>，它实现了<code>Runnable</code>接口。<code>Runnable</code>只有一个无参无返回值的<code>void run()</code>的接口：</p>

<pre><code class="java">/**
 * Represents a command that can be executed. Often used to run code in a
 * different {@link Thread}.
 */
public interface Runnable {

    /**
     * Starts executing the active part of the class' code. This method is
     * called when a thread is started that has been created with a class which
     * implements {@code Runnable}.
     */
    public void run();
}
</code></pre>

<p><code>Android Thread</code>存在六种状态，这些状态定义在枚举<code>State</code>中，源码注释写的很清晰，在这里就不罗嗦了：
<code>java
    /**
     * A representation of a thread's state. A given thread may only be in one
     * state at a time.
     */
    public enum State {
        /**
         * The thread has been created, but has never been started.
         */
        NEW,
        /**
         * The thread may be run.
         */
        RUNNABLE,
        /**
         * The thread is blocked and waiting for a lock.
         */
        BLOCKED,
        /**
         * The thread is waiting.
         */
        WAITING,
        /**
         * The thread is waiting for a specified amount of time.
         */
        TIMED_WAITING,
        /**
         * The thread has been terminated.
         */
        TERMINATED
    }
</code></p>

<p><code>Android Thread</code>类中一些关键成员变量如下：
<code>
    volatile VMThread vmThread;
    volatile ThreadGroup group;
    volatile boolean daemon;    
    volatile String name;
    volatile int priority;
    volatile long stackSize;
    Runnable target;
    private static int count = 0;
    private long id;
    ThreadLocal.Values localValues;
</code></p>

<blockquote><p><code>vmThread</code>：可视为对<code>dalvik thread</code>的简单封装，<code>Thread</code>类通过<code>VMThread</code>里面的<code>JNI</code>方法来调用<code>dalvik</code>中操作线程的方法，通过它的成员变量<code>thread</code>和<code>vmata</code>，我们可以将<code>Android Thread</code>和<code>dalvik Thread</code>的关联起来；<br/>
<code>group</code>：每一个线程都属于一个<code>group</code>，当线程被创建时就会加入一个特定的<code>group</code>，当线程运行结束，会从这个<code>group</code>中移除；<br/>
<code>daemon</code>：当前线程是不是守护线程，守护线程只会在没有非守护线程运行的情况下才会运行；<br/>
<code>priority</code>：线程优先级，<code>Java Thread</code>类的线程优先级取值范围为 [1, 10]，默认优先级为 5；<br/>
<code>stackSize</code>：线程栈大小，默认为 0，即使用默认的线程栈大小（由<code>dalvik&lt;</code>中的全局变量<code>gDvm.stackSize</code>决定）；<br/>
<code>target</code>：一个<code>Runnable</code>对象，<code>Thread</code>的<code>run()</code>方法中会转调该<code>target</code>的<code>run()</code>方法，这是线程真正处理事务的地方；<br/>
<code>id</code>：线程<code>id</code>，通过递增<code>count</code>得到该<code>id</code>，如果没有显式给线程设置名字，那么就会使用<code>Thread+id</code>当作线程的名字。注意这不是真正意义上的线程<code>id</code>，即在<code>logcat</code>中打印的<code>tid</code>并不是这个<code>id</code>，那<code>tid</code>是指<code>dalvik</code>线程的<code>id</code>；
<code>localValues</code>：线程本地存储（<code>TLS</code>）数据；</p></blockquote>

<p>接下来，我们来看<code>Android Thread</code>的构造函数，大部分构造函数都是通过转调静态函数<code>create</code>实现的，下面来详细分析<code>create</code>这个关键函数：</p>

<pre><code class="java">    private void create(ThreadGroup group, Runnable runnable, String threadName, long stackSize) {
        Thread currentThread = Thread.currentThread();
        if (group == null) {
            group = currentThread.getThreadGroup();
        }

        if (group.isDestroyed()) {
            throw new IllegalThreadStateException("Group already destroyed");
        }

        this.group = group;

        synchronized (Thread.class) {
            id = ++Thread.count;
        }

        if (threadName == null) {
            this.name = "Thread-" + id;
        } else {
            this.name = threadName;
        }

        this.target = runnable;
        this.stackSize = stackSize;

        this.priority = currentThread.getPriority();

        this.contextClassLoader = currentThread.contextClassLoader;

        // Transfer over InheritableThreadLocals.
        if (currentThread.inheritableValues != null) {
            inheritableValues = new ThreadLocal.Values(currentThread.inheritableValues);
        }

        // add ourselves to our ThreadGroup of choice
        this.group.addThread(this);
    }
</code></pre>

<p>首先，通过静态函数<code>currentThread</code>获取创建线程所在的当前线程，然后将当前线程的一些属性传递给即将创建的新线程。这是通过<code>VMThread</code>转调<code>dalvik</code>中的代码实现的。</p>

<pre><code class="java">    public static Thread currentThread() {
        return VMThread.currentThread();
    }
</code></pre>

<h2>dalvik Thread</h2>

<p><code>VMThread</code>的<code>currentThread</code>是一个<code>native</code>方法，其<code>JNI</code>实现为<code>android/dalvik/vm/native/java_lang_VMThread.cpp</code>中的<code>Dalvik_java_lang_VMThread_currentThread</code>方法：</p>

<pre><code class="cpp">static void Dalvik_java_lang_VMThread_currentThread(const u4* args,
    JValue* pResult)
{
    UNUSED_PARAMETER(args);

    RETURN_PTR(dvmThreadSelf()-&gt;threadObj);
}
</code></pre>

<p>该方法里的<code>dvmThreadSelf()</code>方法定义在<code>android/dalvik/vm/Thread.cpp</code>中：</p>

<pre><code class="cpp">Thread* dvmThreadSelf()
{
    return (Thread*) pthread_getspecific(gDvm.pthreadKeySelf);
}
</code></pre>

<p>从上面的调用栈可以看到，每一个<code>dalvik</code>线程都会将自身存放在<code>key</code>为<code>pthreadKeySelf</code> 的线程本地存储中，获取当前线程时，只需要根据这个<code>key</code>查询获取即可，<code>dalvik Thread</code>有一个名为<code>threadObj</code> 的成员变量：</p>

<pre><code class="cpp">    /* the java/lang/Thread that we are associated with */
    Object*     threadObj;
</code></pre>

<p><code>dalvik Thread</code>这个成员变量<code>threadObj</code>关联的就是对应的<code>Android Thread</code>对象，所以通过<code>native</code>方法<code>VMThread.currentThread()</code>返回的是存储在<code>TLS</code>中的当前<code>dalvik</code>线程对应的<code>Android Thread</code>。</p>

<p>接着分析上面的代码，如果没有给新线程指定<code>group</code>那么就会指定<code>group</code>为当前线程所在的<code>group</code>中，然后给新线程设置<code>name</code>，<code>priority</code>等。最后通过调用<code>ThreadGroup</code>的<code>addThread</code>方法将新线程添加到<code>group</code>中：</p>

<pre><code class="java">    /**
     * Called by the Thread constructor.
     */
    final void addThread(Thread thread) throws IllegalThreadStateException {
        synchronized (threadRefs) {
            if (isDestroyed) {
                throw new IllegalThreadStateException();
            }
            threadRefs.add(new WeakReference&lt;Thread&gt;(thread));
        }
    }
</code></pre>

<p><code>ThreadGroup</code>的代码相对简单，它有一个名为<code>threadRefs</code>的列表，持有属于同一组的<code>thread</code>引用，可以对一组<code>thread</code>进行一些线程操作。</p>

<p>上面分析的是<code>Android Thread</code>的构造过程，从上面的分析可以看出，<code>Android Thread</code>的构造方法仅仅是设置了一些线程属性，并没有真正去创建一个新的<code>dalvik Thread</code>，<code>dalvik Thread</code>创建过程要等到客户代码调用<code>Android Thread</code>的<code>start()</code>方法才会进行。下面我们来分析<code>Java Thread</code>的<code>start()</code>方法：</p>

<pre><code class="java">public synchronized void start() {

        if (hasBeenStarted) {
            throw new IllegalThreadStateException("Thread already started."); // TODO Externalize?
        }

        hasBeenStarted = true;

        VMThread.create(this, stackSize);
    }
}
</code></pre>

<p><code>Android Thread</code>的 <code>start</code> 方法很简单，仅仅是转调 <code>VMThread</code> 的 <code>native</code> 方法 <code>create</code>，其 <code>JNI</code> 实现为 <code>android/dalvik/vm/native/java_lang_VMThread.cpp</code> 中的 <code>Dalvik_java_lang_VMThread_create</code> 方法：</p>

<pre><code class="cpp">static void Dalvik_java_lang_VMThread_create(const u4* args, JValue* pResult)
{
    Object* threadObj = (Object*) args[0];
    s8 stackSize = GET_ARG_LONG(args, 1);

    /* copying collector will pin threadObj for us since it was an argument */
    dvmCreateInterpThread(threadObj, (int) stackSize);
    RETURN_VOID();
}
</code></pre>

<h2>Create 线程</h2>

<p><code>dvmCreateInterpThread</code> 的实现在 <code>Thread.cpp</code> 中，由于这个函数的内容很长，在这里只列出关键的地方：</p>

<pre><code class="cpp">bool dvmCreateInterpThread(Object* threadObj, int reqStackSize)
{
    Thread* self = dvmThreadSelf();
    ...
    Thread* newThread = allocThread(stackSize); 
    newThread-&gt;threadObj = threadObj;
    ...
    Object* vmThreadObj = dvmAllocObject(gDvm.classJavaLangVMThread, ALLOC_DEFAULT);
    dvmSetFieldInt(vmThreadObj, gDvm.offJavaLangVMThread_vmData, (u4)newThread);
    dvmSetFieldObject(threadObj, gDvm.offJavaLangThread_vmThread, vmThreadObj);
    ...
    pthread_t threadHandle;
    int cc = pthread_create(&amp;threadHandle, &amp;threadAttr, interpThreadStart, newThread);

    /*
     * Tell the new thread to start.
     *
     * We must hold the thread list lock before messing with another thread.
     * In the general case we would also need to verify that newThread was
     * still in the thread list, but in our case the thread has not started
     * executing user code and therefore has not had a chance to exit.
     *
     * We move it to VMWAIT, and it then shifts itself to RUNNING, which
     * comes with a suspend-pending check.
     */
    dvmLockThreadList(self);

    assert(newThread-&gt;status == THREAD_STARTING);
    newThread-&gt;status = THREAD_VMWAIT;
    pthread_cond_broadcast(&amp;gDvm.threadStartCond);

    dvmUnlockThreadList();
    ...
}

/*
 * Alloc and initialize a Thread struct.
 *
 * Does not create any objects, just stuff on the system (malloc) heap.
 */
static Thread* allocThread(int interpStackSize)
{
    Thread* thread;
    thread = (Thread*) calloc(1, sizeof(Thread));
    ...
    thread-&gt;status = THREAD_INITIALIZING;
}
</code></pre>

<p>首先，通过调用 <code>allocThread</code> 创建一个名为 <code>newThread</code> 的<code>dalvik Thread</code> 并设置一些属性，将设置其成员变量 <code>threadObj</code> 为传入的 <code>Android Thread</code>，这样<code>dalvik Thread</code>就与<code>Android Thread</code>关联起来了；然后创建一个名为 <code>vmThreadObj</code> 的 <code>VMThread</code> 对象，设置其成员变量 <code>vmData</code> 为 <code>newThread</code>，设置<code>Android Thread threadObj</code>的成员变量 <code>vmThread</code> 为这个 <code>vmThreadObj</code>，这样<code>Android Thread</code>通过 <code>VMThread</code> 的成员变量 <code>vmData</code> 就和<code>dalvik Thread</code>关联起来了。</p>

<h2>Start 线程</h2>

<p>然后，通过 <code>pthread_create</code> 创建 <code>pthread</code> 线程，并让这个线程 <code>start</code>，这样就会进入该线程的 <code>thread entry</code> 运行，下来我们来看新线程的 <code>thread entry</code> 方法 <code>interpThreadStart</code>，同样只列出关键的地方：</p>

<pre><code class="cpp">/*
 * pthread entry function for threads started from interpreted code.
 */
static void* interpThreadStart(void* arg)
{
    Thread* self = (Thread*) arg;

    std::string threadName(dvmGetThreadName(self));
    setThreadName(threadName.c_str());

    /*
     * Finish initializing the Thread struct.
     */
    dvmLockThreadList(self);
    prepareThread(self);

    while (self-&gt;status != THREAD_VMWAIT)
        pthread_cond_wait(&amp;gDvm.threadStartCond, &amp;gDvm.threadListLock);

    dvmUnlockThreadList();

    /*
     * Add a JNI context.
     */
    self-&gt;jniEnv = dvmCreateJNIEnv(self);

    /*
     * Change our state so the GC will wait for us from now on.  If a GC is
     * in progress this call will suspend us.
     */
    dvmChangeStatus(self, THREAD_RUNNING);

    /*
     * Execute the "run" method.
     *
     * At this point our stack is empty, so somebody who comes looking for
     * stack traces right now won't have much to look at.  This is normal.
     */
    Method* run = self-&gt;threadObj-&gt;clazz-&gt;vtable[gDvm.voffJavaLangThread_run];
    JValue unused;

    ALOGV("threadid=%d: calling run()", self-&gt;threadId);
    assert(strcmp(run-&gt;name, "run") == 0);
    dvmCallMethod(self, run, self-&gt;threadObj, &amp;unused);
    ALOGV("threadid=%d: exiting", self-&gt;threadId);

    /*
     * Remove the thread from various lists, report its death, and free
     * its resources.
     */
    dvmDetachCurrentThread();

    return NULL;
}

/*
 * Finish initialization of a Thread struct.
 *
 * This must be called while executing in the new thread, but before the
 * thread is added to the thread list.
 *
 * NOTE: The threadListLock must be held by the caller (needed for
 * assignThreadId()).
 */
static bool prepareThread(Thread* thread)
{
    assignThreadId(thread);
    thread-&gt;handle = pthread_self();
    thread-&gt;systemTid = dvmGetSysThreadId();

    setThreadSelf(thread);
    ...

    return true;
}

/*
 * Explore our sense of self.  Stuffs the thread pointer into TLS.
 */
static void setThreadSelf(Thread* thread)
{
    int cc;

    cc = pthread_setspecific(gDvm.pthreadKeySelf, thread);
    ...
}
</code></pre>

<p>在新线程的 <code>thread entry</code> 方法 <code>interpThreadStart</code> 中，首先设置线程的名字，然后通过调用 <code>prepareThread</code> 设置线程 <code>id</code> 以及其它一些属性，并调用 <code>setThreadSelf</code> 将新<code>dalvik Thread</code>自身保存在 <code>TLS</code> 中，这样之后就能通过 <code>dvmThreadSelf</code> 方法从 <code>TLS</code> 中获取它。然后修改状态为 <code>THREAD_RUNNING</code>，并调用对应<code>Android Thread</code>的 <code>run</code> 方法，运行客户代码：</p>

<pre><code class="java">    public void run() {
        if (target != null) {
            target.run();
        }
    }
</code></pre>

<p>对于继承自<code>Android Thread</code>带有 <code>Looper</code> 的 <code>Android HandlerThread</code> 来说，会调用它覆写 <code>run()</code> 方法：（关于 <code>Looper</code> 的话题下一篇会讲到，这里暂且略过）</p>

<pre><code class="java">    public void run() {
        mTid = Process.myTid();
        Looper.prepare();
        synchronized (this) {
            mLooper = Looper.myLooper();
            notifyAll();
        }
        Process.setThreadPriority(mPriority);
        onLooperPrepared();
        Looper.loop();
        mTid = -1;
    }
</code></pre>

<h2>Detach 线程</h2>

<p><code>target</code> 在前面已经做了介绍，它是线程真正处理逻辑事务的地方。一旦逻辑事务处理完毕从 <code>run</code> 中返回，线程就会回到 <code>interpThreadStart</code> 方法中，继续执行 <code>dvmDetachCurrentThread</code> 方法：</p>

<pre><code class="cpp">/*
 * Detach the thread from the various data structures, notify other threads
 * that are waiting to "join" it, and free up all heap-allocated storage.
 * /
void dvmDetachCurrentThread()
{
    Thread* self = dvmThreadSelf();
    Object* vmThread;
    Object* group;
    ...
    group = dvmGetFieldObject(self-&gt;threadObj, gDvm.offJavaLangThread_group);

    /*
     * Remove the thread from the thread group.
     */
    if (group != NULL) {
        Method* removeThread =
            group-&gt;clazz-&gt;vtable[gDvm.voffJavaLangThreadGroup_removeThread];
        JValue unused;
        dvmCallMethod(self, removeThread, group, &amp;unused, self-&gt;threadObj);
    }

    /*
     * Clear the vmThread reference in the Thread object.  Interpreted code
     * will now see that this Thread is not running.  As this may be the
     * only reference to the VMThread object that the VM knows about, we
     * have to create an internal reference to it first.
     */
    vmThread = dvmGetFieldObject(self-&gt;threadObj,
                    gDvm.offJavaLangThread_vmThread);
    dvmAddTrackedAlloc(vmThread, self);
    dvmSetFieldObject(self-&gt;threadObj, gDvm.offJavaLangThread_vmThread, NULL);

    /* clear out our struct Thread pointer, since it's going away */
    dvmSetFieldObject(vmThread, gDvm.offJavaLangVMThread_vmData, NULL);

    ...

    /*
     * Thread.join() is implemented as an Object.wait() on the VMThread
     * object.  Signal anyone who is waiting.
     */
    dvmLockObject(self, vmThread);
    dvmObjectNotifyAll(self, vmThread);
    dvmUnlockObject(self, vmThread);

    dvmReleaseTrackedAlloc(vmThread, self);
    vmThread = NULL;

    ...

    dvmLockThreadList(self);

    /*
     * Lose the JNI context.
     */
    dvmDestroyJNIEnv(self-&gt;jniEnv);
    self-&gt;jniEnv = NULL;

    self-&gt;status = THREAD_ZOMBIE;

    /*
     * Remove ourselves from the internal thread list.
     */
    unlinkThread(self);

    ...

    releaseThreadId(self);
    dvmUnlockThreadList();

    setThreadSelf(NULL);

    freeThread(self);
}

/*
 * Free a Thread struct, and all the stuff allocated within.
 */
static void freeThread(Thread* thread)
{
    ...
    free(thread);
}
</code></pre>

<p>在 <code>dvmDetachCurrentThread</code> 函数里，首先获取当前线程 <code>self</code>，这里获得的就是当前执行 <code>thread entry</code> 的新线程，然后通过其对应的<code>Android Thread</code>对象 <code>threadObj</code> 获取该对象所在 <code>group</code>，然后将 <code>threadObj</code> 这个<code>Android Thread</code>对象从 <code>group</code> 中移除；接着清除 <code>Android</code> 与 <code>dalvik</code> 线程之间的关联关系，并通知 <code>join</code> 该线程的其它线程；最后，设置线程状态为 <code>THREAD_ZOMBIE</code>，清除 <code>TLS</code> 中存储的线程值，并通过调用 <code>freeThread</code> 释放内存，至此线程就终结了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android多线程分析之一：使用Thread异步下载图像]]></title>
    <link href="http://luozhaohui.github.io/blog/2014/07/08/android-thread-tutoria01/"/>
    <updated>2014-07-08T20:38:35+08:00</updated>
    <id>http://luozhaohui.github.io/blog/2014/07/08/android-thread-tutoria01</id>
    <content type="html"><![CDATA[<p>打算整理一下对<code>Android Framework</code>中多线程相关知识的理解，主要集中在<code>Framework</code>层的<code>thread</code>, <code>Handler</code>, <code>Looper</code>, <code>MessageQueue</code>, <code>Message</code>, <code>AysncTask</code>，当然不可避免地要涉及到<code>native</code>方法，因此也会分析<code>dalvik</code>中和线程以及消息处理相关的代码：如<code>dalvik</code>中的<code>C++ Thread</code>类以及<code>MessageQueue</code>类。本文将从一个使用<code>Thread</code>的简单应用入手，引入<code>Thread</code>这个话题，接下来的几篇文章会依次介绍前面提到的那些主题。</p>

<!--more-->


<h2>权限</h2>

<p>这是一个使用<code>Android Thread</code>从网络上异步下载图片并在<code>ImageView</code>中显示的的简单示例。因为需要访问网络，所以要在<code>manifest.xml</code>中添加网络访问权限：</p>

<pre><code class="xml">    &lt;uses-permission android:name="android.permission.INTERNET"&gt;
    &lt;/uses-permission&gt;
</code></pre>

<h2>布局</h2>

<p>布局文件很简单，一个<code>Button，一个<code>ImageView：</p>

<pre><code class="xml">&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:padding="10dip" &gt;

    &lt;Button
        android:id="@+id/LoadButton"
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:text="Load"&gt;
    &lt;/Button&gt;

    &lt;ImageView
        android:id="@+id/ImageVivew" 
        android:layout_width="match_parent" 
        android:layout_height="400dip" 
        android:scaleType="centerInside" 
        android:padding="2dp"&gt;
    &lt;/ImageView&gt; 

&lt;/LinearLayout&gt;
</code></pre>

<h2>代码</h2>

<p>接下来看代码。首先来看定义：图片的 <code>url</code> 路径，两个消息值以及一些控件：</p>

<pre><code class="java">    private static final String sImageUrl = "http://fashion.qqread.com/ArtImage/20110225/0083_13.jpg";

    private static final int MSG_LOAD_SUCCESS = 0;
    private static final int MSG_LOAD_FAILURE = 1;

    private Button mLoadButton;
    private ProgressDialog mProgressBar;
    private ImageView mImageView;
</code></pre>

<p>然后来看控件的设置：</p>

<pre><code class="java">    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        Log.i("UI thread", " &gt;&gt; onCreate()");

        mProgressBar = new ProgressDialog(this);
        mProgressBar.setCancelable(true);
        mProgressBar.setMessage("Image downloading ...");
        mProgressBar.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
        mProgressBar.setMax(100);

        mImageView = (ImageView)this.findViewById(R.id.ImageVivew);

        mLoadButton = (Button)this.findViewById(R.id.LoadButton);
        mLoadButton.setOnClickListener(new View.OnClickListener() {
            @Override 
            public void onClick(View v) {
                mProgressBar.setProgress(0);
                mProgressBar.show();

                new Thread() {
                    @Override
                    public void run() {
                        Log.i("Load thread", " &gt;&gt; run()");
                        Bitmap bitmap = loadImageFromUrl(sImageUrl);
                        if (bitmap != null) {
                            Message msg = mHandler.obtainMessage(MSG_LOAD_SUCCESS, bitmap);
                            mHandler.sendMessage(msg);
                        }
                        else {
                            Message msg = mHandler.obtainMessage(MSG_LOAD_FAILURE, null);
                            mHandler.sendMessage(msg);
                        }
                    }
                }.start();
            }
        });
    }
</code></pre>

<p><code>loadImageFromUrl</code>是一个从网络下载<code>Bitmap</code>的<code>static</code>函数：</p>

<pre><code class="java">    static Bitmap loadImageFromUrl(String uil) {
        Bitmap bitmap = null;
        try{
            InputStream in = new java.net.URL(sImageUrl).openStream();
            bitmap = BitmapFactory.decodeStream(in);
            in.close();
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        return bitmap;
    }
</code></pre>

<p><code>mHandler</code>是主线程也就是<code>UI</code>线程处理消息的<code>Handler</code>：</p>

<pre><code class="java">    private Handler mHandler= new Handler(){
        @Override
        public void handleMessage(Message msg) {
            Log.i("UI thread", " &gt;&gt; handleMessage()");

            switch(msg.what){
            case MSG_LOAD_SUCCESS:
                Bitmap bitmap = (Bitmap) msg.obj;
                mImageView.setImageBitmap(bitmap);

                mProgressBar.setProgress(100);
                mProgressBar.setMessage("Image downloading success!");
                mProgressBar.dismiss();
                break;

            case MSG_LOAD_FAILURE:
                mProgressBar.setMessage("Image downloading failure!");
                mProgressBar.dismiss();
                break;
            }
        }
    };
</code></pre>

<h2>综述</h2>

<p>纵观上面的代码，当点击<code>load</code>按钮时，会创建一个匿名<code>Thread</code>，并调用其<code>start()</code>启动运行线程，在这个线程中进行图像下载并解码成<code>Bitmap</code>，然后通过<code>Handler</code>向<code>UI</code>线程发送消息以通知下载结果。这都是在匿名<code>Thead</code>中处理的。主线程也就是<code>UI</code>线程收到消息之后，会分发给<code>Handler</code>，在它的<code>handleMessage</code>方法中根据消息<code>id</code>来处理下载结果，要么成功要么失败，并相应地更新<code>UI</code>。</p>

<p>运行该示例：</p>

<p>可以从<code>logcat</code>的第四栏看到<code>UI thread(tid: 817)</code>和<code>Load thread(tid: 830)</code>的线程<code>id</code>是不同的，因为它们是两个独立的线程。</p>

<p><img src="/images/posts/20140709-android-thread-tutoria01_1.png" alt="Android多线程分析之一：使用Thread异步下载图像" /></p>

<p>在匿名线程下载完毕之后，为什么不直接在这个线程的<code>run()</code>中更新<code>UI</code>呢？这样做有什么后果？这些问题将在后文详细解答。</p>
]]></content>
  </entry>
  
</feed>
